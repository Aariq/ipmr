% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_implementation.R, R/utils-dom-states.R,
%   R/utils-export.R
\name{define_impl}
\alias{define_impl}
\alias{make_impl_args_list}
\alias{define_domains}
\alias{define_pop_state}
\alias{define_state_vars}
\alias{define_env_state}
\alias{define_hier_effs}
\title{Helpers for IPM construction}
\usage{
define_impl(proto_ipm, kernel_impl_list)

make_impl_args_list(kernel_names, int_rule, dom_start, dom_end, ...)

define_domains(proto_ipm, ...)

define_pop_state(proto_ipm, ..., pop_vectors = list())

define_state_vars(proto_ipm, ...)

define_env_state(proto_ipm, ..., data_list)

define_hier_effs(proto_ipm, ...)
}
\arguments{
\item{proto_ipm}{The name of object you wish to append the new kernel to.}

\item{kernel_impl_list}{A named list. Names correspond to kernel names. Each
kernel should have 3 slots defined - the \code{int_rule} (integration rule),
the \code{dom_start} (the domain the kernel begins on), and the \code{dom_end}
(the domain the kernel ends on). It is safest to use \code{make_impl_args_list}
to generate this.}

\item{kernel_names}{A character vector with the names of the kernels
that parameters are being defined for.}

\item{int_rule}{The integration rule to be used for the kernel. The default is
"midpoint". "trapezoid" and "g-l" (Gauss-Legendre) will be implemented as well.
 If "g-l", additional arguments need to be supplied (\strong{Work on this later!!}).}

\item{dom_start}{The name of the state variable for the kernel at time \emph{t}.}

\item{dom_end}{The name of the state variable for the kernel at time \emph{t+1}.
This is usually the same as \code{dom_start}, but general IPMs
with discrete classes or IPMs that move from one state to another (e.g. tree
seedling going from a height domain to a DBH domain at T+1) may have another
value here. For cases with a discrete stage, kernels moving individuals from
discrete to continuous should have a state variable entered here and an \code{NA}
for \code{dom_start}. For kernels moving from continuous to discrete, vice versa.
For discrete to discrete, both are \code{NA}.}

\item{...}{Named expressions. See details for more information on their usage in
each \code{define_*} function.}

\item{pop_vectors}{If the population vectors are already pre-defined (i.e. are
not defined by a function passed to \code{...}), then they can
be passed as a named list here.}

\item{data_list}{A list of named values that correspond to constants in the formula.
You do not need to specify vectors corresponding to the domains here.}
}
\value{
All \code{define_*} functions return a proto_ipm. \code{make_impl_args_list}
returns a list, and so must be used within a call to \code{define_impl} or
before initiating the piped model creation procedure.
}
\description{
Helpers for IPM construction
}
\details{
These are helper functions to define certain types of IPM classes. It is recommended
to use them within the IPM construction pipeline somewhere between \code{add_kernels}
and \code{make_ipm}. The order in which they are called does not matter provided
all values on the left hand side of the \code{...} appear in the right hand side
of another expression used elsewhere. Expressions where the left hand side does
not appear anywhere else will be ignored during construction, and so will not
be present in the returned \code{ipm} object.

Most \code{define_*} functions takes dots in the same way: named expressions
are captured and evaluated later in the appropriate contexts with their respective
kernels. Suffix expansion is supported so that hierarchical models with
year/plot/what-have-you effects do not need to  be rewritten 10s or 100s of times.

The one exception to this is \code{define_domains}. It takes named numeric
vectors of length 3 where the name corresponds to the
state variable, the first entry is the lower bound of the domain, the second
is the upper bound of the domain, and the third entry is the number of
meshpoints (applies to \code{int_rule = "midpoint"} only! Other rules are not
implemented yet).

\code{define_impl} is meant to help distinguish the process of
generating the kernels' mathematical form from their implementation details.
It takes a \code{proto_ipm} object and returns a modified one containing the
implementation information.

\code{make_impl_args_list} helps generate that
information in the correct format. It is usually easiest to call \code{make_impl_args_list}
before calling \code{init_ipm} and then substituting that variable into
the call to \code{define_impl}. Alternatively, one can do something like
\code{define_impl(kernel_impl_list = make_impl_arg_list(...))} within the course
of the model definitition pipeline.
}
