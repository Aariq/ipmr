% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{print.simple_di_det_ipm}
\alias{print.simple_di_det_ipm}
\alias{print.simple_di_stoch_kern_ipm}
\alias{print.simple_di_stoch_param_ipm}
\title{Generics for IPM classes}
\usage{
\method{print}{simple_di_det_ipm}(x, compute_lambda = TRUE,
  sig_digits = 3, ...)

\method{print}{simple_di_stoch_kern_ipm}(x, compute_lambda = TRUE,
  lambda_type = c("stochastic", "deterministic"),
  compute_type = c("pop_size", "eigen"), sig_digits = 3, ...)

\method{print}{simple_di_stoch_param_ipm}(x, compute_lambda = TRUE,
  lambda_type = c("stochastic", "deterministic"),
  compute_type = c("pop_size", "eigen"), sig_digits = 3, ...)
}
\arguments{
\item{x}{An object produced by \code{make_ipm}.}

\item{compute_lambda}{A logical indicating whether or not to calculate lambdas
for the iteration kernels and display them}

\item{sig_digits}{The number of significant digits to round to if \code{
comput_lambda = TRUE}.}

\item{...}{Ignored}

\item{lambda_type}{If \code{compute_lambda} is \code{TRUE}, then either
\code{"stochastic"} or \code{"deterministic"}. \code{"deterministic"} will return
the dominant eigenvalue of the iteration kernel from each iteration. \code{
"stochastic"} depends on \code{compute_type}.}

\item{compute_type}{Either \code{"pop_size"} or \code{"eigen"}. \code{"pop_size"}
computes lambda as the ratio of population sizes between successive time steps
and then takes the geometric mean. \code{"eigen"} computes the dominant eigenvalue
of each iteration kernel and then takes the geometric mean. For large population
vectors, \code{"pop_size"} will likely be substantially faster. Note that
option \code{"pop_size"} is only possible if an initial population vector was
supplied when constructing the IPM.

 @export}
}
\value{
\code{x} invisibly.
}
\description{
Generics for IPM classes
}
