% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_implementation.R
\name{define_impl}
\alias{define_impl}
\alias{make_impl_args_list}
\title{Define implementation parameters}
\usage{
define_impl(proto_ipm, kernel_impl_list)

make_impl_args_list(kernel_names, int_rule, dom_start, dom_end, ...)
}
\arguments{
\item{proto_ipm}{The name of object you wish to append the new kernel to.}

\item{kernel_impl_list}{A named list. Names correspond to kernel names. Each
kernel should have 3 slots defined - the \code{int_rule} (integration rule),
the \code{dom_start} (the domain the kernel begins on), and the \code{dom_end}
(the domain the kernel ends on). It is safest to use \code{make_impl_args_list}
to generate this.}

\item{kernel_names}{A character vector with the names of the kernels
that parameters are being defined for.}

\item{int_rule}{The integration rule to be used for the kernel. The default is
"midpoint". "trapezoid" and "g-l" (Gauss-Legendre) will be implemented as well.
If "g-l", additional arguments need to be supplied (\strong{Work on this later!!}).}

\item{dom_start}{The name of the state variable for the kernel at time \emph{t}.}

\item{dom_end}{The name of the state variable for the kernel at time \emph{t+1}.
This is usually the same as \code{dom_start}, but general IPMs
with discrete classes or IPMs that move from one state to another (e.g. tree
seedling going from a height domain to a DBH domain at T+1) may have another
value here. For cases with a discrete stage, kernels moving individuals from
discrete to continuous should have a state variable entered here and an \code{NA}
for \code{dom_start}. For kernels moving from continuous to discrete, vice versa.
For discrete to discrete, both are \code{NA}.}

\item{...}{Additional arguments required for \code{int_rule = 'g-l'}.}
}
\value{
A \code{proto_ipm} with the implementation details stored.
}
\description{
Define implementation parameters
}
\details{
\code{define_impl} is meant to help distinguish the process of
generating the kernels' mathematical form from their implementation details.
It takes a \code{proto_ipm} object and returns a modified one containing the
implementation information.

\code{make_impl_args_list} helps generate that
information in the correct format. It is usually easiest to call \code{make_impl_args_list}
before calling \code{init_ipm} and then substituting that variable into
the call to \code{define_impl}. Alternatively, one can do something like
\code{define_impl(kernel_impl_list = make_impl_arg_list(...))} within the course
of the model definitition pipeline.
}
