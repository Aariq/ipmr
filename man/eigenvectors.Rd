% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{right_ev}
\alias{right_ev}
\alias{right_ev.simple_di_det_ipm}
\alias{right_ev.general_di_det_ipm}
\alias{left_ev}
\alias{left_ev.simple_di_det_ipm}
\alias{left_ev.general_di_det_ipm}
\title{Compute the standardized left and right eigenvectors via iteration}
\usage{
right_ev(ipm, iterations)

\method{right_ev}{simple_di_det_ipm}(ipm, iterations = 100)

\method{right_ev}{general_di_det_ipm}(ipm, iterations = 100)

left_ev(ipm, iterations)

\method{left_ev}{simple_di_det_ipm}(ipm, iterations = 100)

\method{left_ev}{general_di_det_ipm}(ipm, iterations = 100)
}
\arguments{
\item{ipm}{Output from \code{make_ipm()}.}

\item{iterations}{The number of times to iterate the model to reach
convergence. Default is 100.}
}
\value{
A list of named numeric vector(s) corresponding to the stable trait distribution
function (\code{right_ev}) or the reproductive values for each trait (\code{left_ev}).
}
\description{
Compute the standardized left and right eigenvectors via iteration
}
\details{
For \code{right_ev}, if the model has already been iterated, then
these functions will just extract population state of the final iteration and
return that in a named list. Each element of the list is a vector with length
\code{>= 1} and corresponds each state variable's portion of the eigenvector.

For \code{left_ev}, the transpose iteration (\emph{sensu} Ellner & Rees 2006,
Appendix A) is worked out based on the \code{state_start} and \code{state_end}
in the model's \code{proto_ipm} object. The model is then iterated for
\code{iterations} times to produce a standardized left eigenvector.
}
