% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{right_ev}
\alias{right_ev}
\alias{right_ev.simple_di_det_ipm}
\alias{right_ev.general_di_det_ipm}
\alias{left_ev}
\alias{left_ev.general_di_det_ipm}
\title{Compute the standardized left and right eigenvectors via iteration}
\usage{
right_ev(ipm, ...)

\method{right_ev}{simple_di_det_ipm}(ipm, n_iterations = 100, ...)

\method{right_ev}{general_di_det_ipm}(
  ipm,
  n_iterations = 100,
  mega_mat = NULL,
  mega_vec = NULL,
  keep_mega = FALSE,
  ...
)

left_ev(ipm, ...)

\method{left_ev}{general_di_det_ipm}(ipm, mega_mat, mega_vec, n_iterations = 100, keep_mega = FALSE, ...)
}
\arguments{
\item{ipm}{Output from \code{make_ipm()}.}

\item{...}{other arguments passed to methods}

\item{n_iterations}{The number of times to iterate the model to reach
convergence. Default is 100.}

\item{mega_mat}{A vector of names and/or 0s specifying the relationship
between the kernels in the model. The names should correspond to kernel
names, with 0s corresponding to sparse areas of the mega-matrix. The names can
be either symbols or characters. These functions support suffix expansion as in
\code{define_k(ernel)}, so expressions don't need to be re-written for every
combination hierarchical effects.}

\item{mega_vec}{A vector of names specifying the format of the population
vector. The names can be either symbols or characters.}

\item{keep_mega}{A logical. TRUE returns a list with the mega matrix
and full eigenvector, FALSE returns a list with each state's contribution
to eigenvector. Default is FALSE, mostly for internal usage.}
}
\value{
A list of named numeric vector(s) corresponding to the stable trait distribution
function (\code{right_ev}) or the reproductive values for each trait (\code{left_ev}).
}
\description{
Compute the standardized left and right eigenvectors via iteration
}
\details{
If the model has already been iterated, then these functions
will just extract population state of the final iteration and return
that in a named list. Each element of the list is a vector with length
\code{>= 1} and corresponds each state variable's portion of the eigenvector.

Note that for \code{*_di_stoch_kern_ipm}'s, these generics will create a mean
matrix and then compute the left/right eigenvectors for that. For
\code{*_di_stoch_param_ipm}'s, it will compute the average environment kernel
(e.g. using the means from the \code{env_seq} slot of the IPM).

\code{mega_mat} fits the pieces of the model together to create a
a transpose of the model to iterate with. Kernel names/0s should be supplied
in ROW MAJOR order (think \code{byrow = TRUE}. \code{ipmr} supplies
a helper function for large models \code{format_mega_mat}
to help with age-size models or ones with a lot of hierarchical effects.
}
\examples{

data(gen_di_det_ex)

# mega matrix is specifed as a row-major vector/matrix of symbols. You can also
# supply a character vector/matrix. mega_vec is done the same way.
# DO NOT supply arguments like nrow or ncol if using \code{matrix(...)}.
# The function expects to work these out on its own.

ipmr_v <- left_ev(gen_di_det_ex,
                  mega_mat     = c(stay_discrete, go_discrete,
                                   leave_discrete, P),
                  mega_vec = c(b, ht),
                  n_iterations = 100)

}
