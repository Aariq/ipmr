% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_ipm.R
\name{make_ipm}
\alias{make_ipm}
\alias{make_ipm.simple_di_det}
\alias{make_ipm.simple_di_stoch_kern}
\alias{make_ipm.simple_di_stoch_param}
\alias{make_ipm.general_di_det}
\alias{make_ipm.general_di_stoch_kern}
\alias{make_ipm.general_di_stoch_param}
\title{Methods to implement an IPM}
\usage{
make_ipm(proto_ipm, return_all = FALSE, usr_funs = list(), ...)

\method{make_ipm}{simple_di_det}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = FALSE,
  iterations = 50
)

\method{make_ipm}{simple_di_stoch_kern}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = FALSE,
  iterations = 50,
  kernel_seq = NULL
)

\method{make_ipm}{simple_di_stoch_param}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50
)

\method{make_ipm}{general_di_det}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50
)

\method{make_ipm}{general_di_stoch_kern}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NULL
)

\method{make_ipm}{general_di_stoch_param}(
  proto_ipm,
  return_all = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50
)
}
\arguments{
\item{proto_ipm}{The proto_ipm object you wish to implement. This should be the
output of \code{define_kernel}, \code{define_k}, or the \code{define_*} functions.}

\item{return_all}{A logical indicating whether to return the environments that
the kernel expressions are evaluated in. This is useful for developer
debugging and not much else.}

\item{usr_funs}{An optional list of user-specified functions that are passed
on to the evaluation environments. This can help make vital rate expressions
more concise and expressive. Names in this list should exactly match the names
of the function calls in the \code{...} or \code{formula}.}

\item{...}{Other arguments passed to methods}

\item{domain_list}{An optional list of new domain information to implement
the IPM with.}

\item{iterate}{A logical indicating whether or not iterate the model before exiting
or just return the iteration kernels. For density dependent (\code{dd}) and/or
stochastic parameter resampled models (\code{stoch_param}), this should always
be \code{TRUE}.}

\item{iterations}{If \code{iterate} is \code{TRUE}, then the number of iterations
to simulate.}

\item{kernel_seq}{The sequence of kernels to use during the iterations.
This can either be a vector of integers corresponding to kernel names (e.g.
kernels for different years - \code{2011:2018}),
a character vector corresponding to kernel names (e.g. kernels from different
sites - \code{'a', 'b', 'c'}), a Markov chain matrix with
transition probabilities between given states (NOT YET IMPLEMENTED), or empty.
If empty, the model will try to run deterministically for each unique combination
of hierarchical variables (if any).}
}
\value{
The \code{make_ipm.*} methods will always return a list of length 6
containing the following components:

\itemize{
  \item{\strong{iterators}}{: iteration kernel(s) (if specified by \code{define_k}),
                            otherwise contains \code{NA}.}
  \item{\strong{sub_kernels}}{: the sub_kernels specified in \code{define_kernel}.}
  \item{\strong{env_list}}{: a list containing the evaluation environments of
                           kernel. This will always be empty unless \code{
                           return_all} is \code{TRUE}. Mostly here for developer
                           debugging.}
  \item{\strong{env_seq}}{: a matrix with dimension \code{n_iterations} X 1 of
                             kernel indices indicating the order
                             in which kernels are to be/were resampled OR
                             a matrix with as many columns as stochastic parameters
                             \code{n_iterations} rows.}
  \item{\strong{pop_state}}{: population vectors stored as an instance of the
                             stored as a list of arrays. The first dimension
                             of each array corresponds to the state variable,
                             and the second dimsension corresponds to time
                             steps.}
  \item{\strong{proto_ipm}}{: the \code{proto_ipm} object used to implement
                             the model.}
}

In addition to the list class, each object will have the class from
\code{model_class} defined in \code{init_ipm} plus \code{'_ipm'}. This is to
facilitate \code{print}, \code{plot}, and \code{lambda} methods. For example,
a \code{'simple_di_stoch_kern'} model will have the class
\code{'simple_di_stoch_kern_ipm'} once it has been implemented using
\code{make_ipm}.
}
\description{
The \code{make_ipm.*} methods convert a \code{proto_ipm} into a
set of discretized kernels and population vectors. Methods have different
requirements, so be sure to read the parameter documentation. \code{
vignettes('Introduction to ipmr', 'ipmr')} also contains helpful information.
}
\details{
When \code{kernel_seq} is a character vector, names
are matched using \code{grepl()}. When it is an integer vector, the vector
is first checked to make sure they are all present in kernel names. The model
procedure will stop if thay are not all present.
}
\author{
Sam Levin
}
