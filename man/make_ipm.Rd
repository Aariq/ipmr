% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_ipm.R
\name{make_ipm}
\alias{make_ipm}
\alias{make_ipm.simple_di_det}
\alias{make_ipm.simple_di_stoch_kern}
\alias{make_ipm.simple_di_stoch_param}
\alias{make_ipm.general_di_det}
\title{Methods to implement an IPM}
\usage{
make_ipm(proto_ipm, return_all = FALSE, usr_funs = list(), ...)

\method{make_ipm}{simple_di_det}(proto_ipm, return_all = FALSE,
  domain_list = NULL, usr_funs = list(), iterate = FALSE,
  iterations = 50, ...)

\method{make_ipm}{simple_di_stoch_kern}(proto_ipm, return_all = FALSE,
  domain_list = NULL, iterate = FALSE, iterations = 50,
  kernel_seq = NULL, usr_funs = list, ...)

\method{make_ipm}{simple_di_stoch_param}(proto_ipm, return_all = FALSE,
  domain_list = NULL, iterate = TRUE, iterations = 50,
  usr_funs = list(), ...)

\method{make_ipm}{general_di_det}(proto_ipm, return_all = FALSE,
  domain_list = NULL, iterate = TRUE, iterations = 50,
  usr_funs = list(), ...)
}
\arguments{
\item{proto_ipm}{The proto_ipm object you wish to implement. This should be the
output of \code{add_kernel}, \code{add_K}, or the \code{define_*} functions.}

\item{return_all}{A logical indicating whether to return the environments that
the kernel expressions are evaluated in. This is useful for developer
debugging and not much else.}

\item{usr_funs}{An optional list of user-specified functions that are passed
on to the evaluation environments. This can help make vital rate expressions
more concise and expressive. Names in this list should exactly match the names
of the function calls in the \code{...} or \code{formula}.}

\item{...}{Other arguments passed to methods}

\item{domain_list}{An optional list of new domain information to implement
the IPM with.}

\item{iterate}{A logical indicating whether or not iterate the model before exiting
or just return the iteration kernels. For density dependent (\code{dd}) and/or
stochastic parameter resampled models (\code{stoch_param}), this should always
be \code{TRUE}.}

\item{iterations}{If \code{iterate} is \code{TRUE}, then the number of iterations
to simulate.}

\item{kernel_seq}{The sequence of kernels to use during the iterations.
This can either be a vector of integers corresponding to kernel indices,
a character vector corresponding to kernel names, a Markov chain matrix with
transition probabilities between given states (NOT YET IMPLEMENTED), or empty.
If empty, a random sequence will be generated internally from a uniform
distribution.}
}
\value{
The \code{make_ipm.*det} methods will always return a list of length 4
containing the following components:

\itemize{
  \item{\strong{iterators}}{: iteration kernel(s) (if specified by \code{add_K}),
                            otherwise contains \code{NA}.}
  \item{\strong{sub_kernels}}{: the sub_kernels specified in \code{add_kernel}.}
  \item{\strong{pop_state}}{: population vectors stored in a list of arrays.
  Dimension one corresponds the continuous state, and dimension 2 is time (
  requires generalization for higher dimensional kernels!!!).}
  \item{\strong{proto_ipm}}{: the \code{proto_ipm} object used to implement
                             the model.}
}
 The \code{make_ipm.*stoch} methods will always return a list of length 5
containing the following components:

\itemize{
  \item{\strong{iterators}}{: iteration kernel(s) (if specified by \code{add_K}),
                            otherwise contains \code{NA}.}
  \item{\strong{sub_kernels}}{: the sub_kernels specified in \code{add_kernel}.}
  \item{\strong{env_list}}{: a list containing the evaluation environments of
                           kernel. This will always be empty unless \code{
                           return_all} is \code{TRUE}. Mostly here for developer
                           debugging.}
  \item{\strong{env_seq}}{: a matrix with dimension \code{n_iterations} X 1 of
                             kernel indices indicating the order
                             in which kernels are to be/were resampled OR
                             a matrix with as many columns as stochastic parameters
                             \code{n_iterations} rows.}
  \item{\strong{pop_state}}{: population vectors stored as an instance of the
                             \code{pop_state} class.}
  \item{\strong{proto_ipm}}{: the \code{proto_ipm} object used to implement
                             the model.}
}
}
\description{
The \code{make_ipm.*} methods convert a \code{proto_ipm} into a
set of discretized kernels and population vectors. Methods have different
requirements, so be sure to read the parameter documentation. \code{
vignettes('Introduction to ipmr', 'ipmr')} also contains helpful information.
}
\author{
Sam Levin
}
