<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to ipmr • ipmr</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to ipmr">
<meta property="og:description" content="ipmr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">ipmr</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="Unreleased version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="divider">
    <li class="dropdown-header">Introduction to ipmr</li>
    <li>
      <a href="../articles/ipmr-introduction.html">Introduction to ipmr</a>
    </li>
    <li>
      <a href="../articles/general-ipms.html">General IPMs</a>
    </li>
    <li>
      <a href="../articles/hierarchical-notation.html">Hierarchical Notation</a>
    </li>
    <li>
      <a href="../articles/age_x_size.html">Age-Size IPMs</a>
    </li>
    <li>
      <a href="../articles/density-dependence.html">Density Dependent IPMs</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">Generic Functions</li>
    <li>
      <a href="../articles/generic-funs.html">List of Generic and Helper Functions in ipmr</a>
    </li>
    <li>
      <a href="../articles/generic-progress.html">Generic Progress</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">proto_ipm Overview</li>
    <li>
      <a href="../articles/proto-ipms.html">proto_ipm Data Structure</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">ipmr Checks</li>
    <li>
      <a href="../articles/sanity-checks.html">Sanity checks for ipmr examples</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Introduction to ipmr</h1>
            
      
      
      <div class="hidden name"><code>ipmr-introduction.Rmd</code></div>

    </div>

    
    
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p><code>ipmr</code> is a package for implementing integral projection models of varying degrees of complexity. It uses mathematical-ish expressions to build up the iteration kernels from smaller pieces, as well as helpers to ensure that models are implemented correctly. Finally, it provides machinery for stochastic simulations. basic analyses, and model diagnostics. More complicated analysis functions are being implemented in the <a href="https://github.com/levisc8/irage">irage package</a>.</p>
<p><strong>This package does not help with fitting regression models to demographic data!</strong> This is a distinct enough problem that it should not be in the purview of this package - and there are much better tools out there already that can do a much better job of helping you with that than I can. Some of my favorites are <code>lme4</code>, <code>brms</code>, <code>mgcv</code>, and <code>nlme</code>. <code>IPMpack</code> handles the regression modelling and IPM construction, though be forewarned, there are certain types of models that you simply cannot construct with it! <code>IPMpack</code> is no longer on CRAN, but can be installed from the <code>MetaCRAN/IPMpack</code> <a href="https://github.com/cran/IPMpack">Github page</a> or running <code><a href="https://devtools.r-lib.org//reference/remote-reexports.html">devtools::install_github("CRAN/IPMpack")</a></code>.</p>
<p>Unfortunately, <code>ipmr</code> does not yet have built-in functions for dealing with uncertainty. The goal is to change that soon, but for now, doing this will require <code>for</code> loops and storing the results of each iteration. Some example code is provided at the end of this vignette.</p>
</div>
<div id="types-of-models-in-ipmr" class="section level2">
<h2 class="hasAnchor">
<a href="#types-of-models-in-ipmr" class="anchor"></a>Types of models in <code>ipmr</code>
</h2>
<p>The first step of defining a model in <code>ipmr</code> is to initialize the model using <code><a href="../reference/init_ipm.html">init_ipm()</a></code>. This function has two arguments: <code>model_class</code>, and <code>has_age</code>. We will ignore <code>has_age</code> for now, because age-size models are a complicated topic and have their <a href="https://levisc8.github.io/ipmr/articles/age_x_size.html">own vignette</a>.</p>
<p>The <code>model_class</code> defines the basic infrastructure that will be available for subsequent analyses and helps make sure the kernels are correctly implemented from the underlying vital rates. <code>model_class</code> should be a character string with at least 3 (but possibly 4) entries separated by underscores (<code>_</code>). Below, the are the possible entries for each position.</p>
<ul>
<li>
<p>Position 1: <code>"simple"</code>/<code>"general"</code></p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li>
<strong>simple</strong>: This describes an IPM with a single continuous state variable and no discrete stages.</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li>
<strong>general</strong>: This describes and IPM with either more than one continuous state variable, one or more discrete stages, or both of the above. Basically, anything other than an IPM with a single continuous state variable.</li>
</ol></li>
</ul>
</li>
<li>
<p>Position 2: <code>"di"</code>/<code>"dd"</code></p>
<ul>
<li><p>A. <strong>di</strong>: This is used to denote a density-independent IPM.</p></li>
<li><p>B. <strong>dd</strong>: This is used to denote a density-dependent IPM.</p></li>
</ul>
</li>
<li>
<p>Position 3: <code>"det"</code>/<code>"stoch"</code></p>
<ul>
<li><p>A. <strong>det</strong>: This is used to denote a deterministic IPM. If this is used in the third position of <code>model_class</code>, there should not be a fourth entry.</p></li>
<li><p>B. <strong>stoch</strong>: This is used to denote a stochastic IPM. If this is used in the third position of <code>model_class</code>, there should always be a fourth entry. The two possibilities for the fourth are described next.</p></li>
</ul>
</li>
<li>
<p>Position 4: <code>"kern"</code>/<code>"param"</code> (Complete definitions found in <a href="https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.12405">Metcalf et al. 2015</a>)</p>
<ul>
<li><p>A. <strong>kern</strong>: This describes an IPM with discretely varying parameters such that their values are known before the model is specified. This is usually the case with models that estimate fixed and/or random year/site effects and for which defining a multivariate joint distribution to sample parameters from is not desirable/needed. These models can be a bit more computationally efficient than the <code>param</code> alternative because all kernels can be constructed before the iteration procedure begins, as opposed to requiring reconstruction for every single iteration.</p></li>
<li><p>B. <strong>param</strong>: This describes an IPM with parameters that are re-sampled from some distribution at each iteration of the model (usually a multivariate joint distribution). This can be a multivariate normal defined by covarying slopes and intercepts, or posterior distribution from a Bayesian model. All that is required is that the parameters for the distribution are specified and that the function that generates the parameters at each iteration returns named lists that correspond to the parameter names in the model. Jump down to the <code>"simple_di_stoch_param"</code> example for some inspiration in writing those.</p></li>
</ul>
</li>
</ul>
<p>With the type of model selected, the <code>model_class</code> becomes a string and the call to <code>init_ipm</code> is composed like so: <code><a href="../reference/init_ipm.html">init_ipm(model_class = "position1_position_2_position3_position4")</a></code>.</p>
<p>The rest of this vignette will deal with simple, density independent IPMs. If you already know that you need a general IPM (i.e. an IPM with discrete stages and/or multiple continuous state variables), I still strongly recommend reading at least one complete example here before you start with <a href="https://levisc8.github.io/ipmr/articles/general-ipms.html">those</a>.</p>
</div>
<div id="specifying-a-simple-deterministic-ipm-without-density-dependence" class="section level2">
<h2 class="hasAnchor">
<a href="#specifying-a-simple-deterministic-ipm-without-density-dependence" class="anchor"></a>Specifying a simple deterministic IPM without density dependence</h2>
<p>This is the simplest model that <code>ipmr</code> works with. It is an IPM with a single continuous state variable and no density dependent functions. We’ll walk through the steps required to implement such an IPM before getting into more complex models.</p>
<p>The vital rate functions and code that might be used to generate models corresponding to them are below.</p>
<ol style="list-style-type: decimal">
<li>
<p>Survival (<code>s</code>): a generalized linear model w/ a logit link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(surv ~ size_1, data = my_surv_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>Growth (<code>g</code>): a linear model with a Normal error distribution.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/lm.html">lm(size_2 ~ size_1, data = my_grow_data)</a></code>
</li>
</ul>
</li>
<li>
<p>Pr(flowering) (<code>f_r</code>): a generalized linear model w/ a logit link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(flower ~ size_1, data = my_repro_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>Seed production (<code>f_s</code>): a generalized linear model w/ log link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(seeds ~ size_1, data = my_flower_data, family = poisson())</a></code>
</li>
</ul>
</li>
<li>
<p>Recruit size distribution (<code>f_d</code>): a normal distribution w parameters <code>mu_fd</code> (mean) and <code>sd_fd</code> (standard deviation).</p>
<ul>
<li>Example code: <code>mu_fd = mean(my_recr_data$size_2, na.rm = TRUE)</code> and <code>sd_fd = sd(my_recr_data$size_2, na.rm = TRUE)</code>
</li>
</ul>
</li>
</ol>
<div id="defining-kernels" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-kernels" class="anchor"></a>Defining kernels</h3>
<p>The first step is to decide what class of model we want to implement. We have one continuous state variable and no spatial or temporal variation to deal with, and we aren’t going to deal with uncertainty (for now). Thus, we have a simple, density independent, deterministic IPM. We initialize it with <code><a href="../reference/init_ipm.html">init_ipm()</a></code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>)
</pre></div>
<p>The next step is to define the actual kernels comprising the IPM. These are defined individually with calls to <code><a href="../reference/define_kernel.html">define_kernel()</a></code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
  proto_ipm = <span class="kw">my_ipm</span>,
  name      = <span class="st">"P"</span>,
  
  <span class="co"># The formula describes how the vital rates generate the kernel</span>
  
  formula   = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
  
  <span class="co"># The family describes the type of transition that kernel produces. See below.</span>
  
  family    = <span class="st">"CC"</span>,
  
  <span class="co"># Here, we create an expression for the inverse of the link function from </span>
  <span class="co"># our GLM for survival. In this case, it's the inverse logit.</span>
  
  s         = <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>))),
  
  <span class="co"># Growth has two terms with 3 parameters - the mean and the standard deviation.</span>
  <span class="co"># We model the mean as a function of size with an intercept and slope. </span>
  <span class="co"># The standard deviation is a constant.</span>
  
  g         = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">dbh_2</span>, <span class="kw">g_mu</span>, <span class="kw">g_sd</span>),
  g_mu      = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>,
  
  data_list = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
    s_int     = <span class="fl">0.2</span>,   <span class="co"># coef(my_surv_mod)[1]</span>
    s_slope   = <span class="fl">0.5</span>,   <span class="co"># coef(my_surv_mod)[2]</span>
    g_int     = <span class="fl">0.1</span>,   <span class="co"># coef(my_grow_mod)[1]</span>
    g_slope   = <span class="fl">1.033</span>, <span class="co"># coef(my_grow_mod)[2]</span>
    g_sd      = <span class="fl">2.2</span>    <span class="co"># sd(resid(my_grow_mod))</span>
  ),
  
  <span class="co"># states should be a list of the state variables that the kernel operates on</span>
  
  states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
  has_hier_effs = <span class="fl">FALSE</span>,
  evict_cor     = <span class="fl">TRUE</span>,
  evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
) 
</pre></div>
<p>This function takes the kernel <code>name</code>, the mathematical <code>formula</code> for the kernel, and expressions for the vital rates that comprise it (<code>s</code>, <code>g</code>, <code>g_mu</code>).</p>
<p>The <code>family</code> argument refers to the type of transition that the kernel describes and has 5 options:</p>
<ol style="list-style-type: decimal">
<li><p>“CC” - a continuous -&gt; continuous transition</p></li>
<li><p>“CD” - a continuous -&gt; discrete transition</p></li>
<li><p>“DC” - a discrete -&gt; continuous transition</p></li>
<li><p>“DD” - a discrete -&gt; discrete transition</p></li>
<li><p>“IPM” - This is reserved for the <code><a href="../reference/define_kernel.html">define_k()</a></code> function introduced below.</p></li>
</ol>
<p>These aren’t important for <code>simple_*</code> IPMs, as all transitions are from a continuous state to a continuous state, but they are required for <code>general_*</code> IPMs to build properly. As such, they are required to be specified for <em>all</em> kernels.</p>
<p>In addition, the <code>data_list</code> argument holds the constant parameters (e.g. regression coefficient estimates).</p>
<p>The <code>states</code> argument refers to the state variables in use. <code>ipmr</code> internally appends an <code>_1</code> and <code>_2</code> to the names in <code>states</code>, and creates variables for them that are the meshpoints for integration. These correspond to time <em>t</em> and <em>t+1</em>, and can be used in vital rate expressions to indicate which state at which time is being acted upon.</p>
<p><code>has_hier_effs</code> is a logical indicating whether or not the model contains hierarchical effects. In this example, the model is a simple, deterministic one and so this is set to <code>FALSE</code>. However, we can use them to create <a href="#hier-effs-det">deterministic simulations for multiple sites/years</a>. Additionally, <code>*_stoch_kern</code> models will almost always need this to be set to <code>TRUE</code>, and <code>*_stoch_param</code> models can also use them. Those examples include demonstrations of that syntax, and there is a dedicated <a href="https://levisc8.github.io/ipmr/articles/hierarchical-notation.html">vignette</a> that goes into even greater detail.</p>
<p><code>evict_cor</code> refers to whether or not to correct for eviction in the kernel. If this is set to <code>TRUE</code>, then you must supply a function specifying which expressions need to be corrected and the correction to apply. <code>ipmr</code> provides <code>truncated_distributions</code> for now, though others will eventually be implemented as well. Subsequent additions are mainly to accomodate models in PADRINO, and I very strongly suggest sticking to <code>truncated_distributions</code> for your own models.</p>
<p>Finally, <code>ipmr</code> is designed to be <a href="https://magrittr.tidyverse.org/">pipe-friendly</a>. All functions prefixed with <code>define_*</code> take a <code>proto_ipm</code> as their first argument and always return a <code>proto_ipm</code>, meaning operations can be chained together with the <code><a href="../reference/%&gt;%.html">%&gt;%</a></code> operator. This function is included in <code>ipmr</code>, so there is no need to load any other packages to access it (e.g. <code>dplyr</code> or <code>magrittr</code>). The first chunk below is equivalent to the two chunks above.</p>
<div class="sourceCode" id="cb3"><pre class="downlit">
<span class="co"># the %&gt;% takes the result of the first operation and passes it as the first</span>
<span class="co"># argument to the second function.</span>

<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="op">%&gt;%</span> 
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name      = <span class="st">"P"</span>,
    formula   =  <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    family    = <span class="st">"CC"</span>,
    s         = <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>))),
    g         = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">dbh_2</span>, <span class="kw">g_mu</span>, <span class="kw">g_sd</span>),
    g_mu      = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>,
    
    data_list = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      s_int     = <span class="fl">0.2</span>,
      s_slope   = <span class="fl">0.5</span>,
      g_int     = <span class="fl">0.1</span>,
      g_slope   = <span class="fl">1.033</span>,
      g_sd      = <span class="fl">2.2</span>
    ),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>, 
                                            param = <span class="st">"g"</span>)
  )
</pre></div>
<p>We’ll now continue with specifying the rest of the model.</p>
<p>The rest of the model definition sequence in this example will use the <code><a href="../reference/%&gt;%.html">%&gt;%</a></code> operator. <em>It is not a requirement</em> - you can assign a value to <code>my_ipm</code> at each step and the model will be identical. Choose which ever process is more comfortable for you!</p>
<div class="sourceCode" id="cb4"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="op">%&gt;%</span> 
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name      = <span class="st">"P"</span>,
    formula   =  <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    family    = <span class="st">"CC"</span>,
    s         = <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>))),
    g         = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">dbh_2</span>, <span class="kw">g_mu</span>, <span class="kw">g_sd</span>),
    g_mu      = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>,
    
    data_list = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      s_int     = <span class="fl">0.2</span>,
      s_slope   = <span class="fl">0.5</span>,
      g_int     = <span class="fl">0.1</span>,
      g_slope   = <span class="fl">1.033</span>,
      g_sd      = <span class="fl">2.2</span>
    ),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>, 
                                            param = <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span> 
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name      = <span class="st">"F"</span>,
    formula   = <span class="kw">f_r</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span>,
    family    = <span class="st">"CC"</span>,
    
    <span class="co"># Again, we use the inverse logit transformation to compute pr(flowering)</span>
    f_r       = <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">f_r_int</span> <span class="op">+</span> <span class="kw">f_r_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>))),
    
    <span class="co"># We exponentiate this because of the log link in our seed production model</span>
    f_s       = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="kw">f_s_int</span> <span class="op">+</span> <span class="kw">f_s_slope</span> <span class="op">*</span> <span class="kw">dbh_1</span>),
    
    <span class="co"># In this case, both the mean and standard deviation are constants</span>
    f_d       = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">dbh_2</span>, <span class="kw">f_d_mu</span>, <span class="kw">f_d_sd</span>),
    data_list = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      f_r_int   = <span class="fl">0.5</span>,   <span class="co"># coef(my_flower_mod)[1]</span>
      f_r_slope = <span class="fl">0.1</span>,   <span class="co"># coef(my_flower_mod)[2]</span>
      f_s_int   = <span class="fl">1.2</span>,   <span class="co"># coef(my_seed_mod)[1]</span>
      f_s_slope = <span class="fl">0.03</span>,  <span class="co"># coef(my_seed_mod)[2]</span>
      f_d_mu    = <span class="fl">1.2</span>,   <span class="co"># mean(my_recr_data$size_2, na.rm = TRUE)</span>
      f_d_sd    = <span class="fl">0.7</span>    <span class="co"># sd(my_recr_data$size_2, na.rm = TRUE)</span>
    ),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  )
</pre></div>
<p>We are now ready to define the <code>K</code> kernel, also referred to as the iteration kernel.</p>
</div>
<div id="defining-an-iteration-kernel" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-an-iteration-kernel" class="anchor"></a>Defining an iteration kernel</h3>
<p>These kernels are treated slightly differently in <code>ipmr</code>. They are defined with their own function, <code><a href="../reference/define_kernel.html">define_k()</a></code>. It has fewer arguments than <code>define_kernel</code>. The primary difference is that it does not have a <code>formula</code> argument. Instead, it take <code>...</code>. This means you can specify multiple expressions to describe how the model iterates. In this case, we only specify the form of the iteration kernel. For stochastic models, we’ll need to specify how that kernel move the population state at <span class="math inline">\(t\)</span> to the state at <span class="math inline">\(t+1\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name          = <span class="st">"K"</span>,
    family        = <span class="st">"IPM"</span>,
    K             = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,           <span class="co"># define_k uses ... instead of formula = P + F</span>
    data_list     = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">FALSE</span>
  ) 
</pre></div>
<p>The <code>name</code> argument of <code>define_k</code> should always be one of <code>K</code>, <code>k</code>, or <code>K_suffix</code>, where <code>suffix</code> corresponds to a hierarchical effect. The <code>...</code> take over the role that <code>formula</code> took in the previous kernels. This is to facilitate passing multiple expressions for the iteration kernel when defining more complex models (i.e. how the population state changes with time or an age x size model). In this example, the left hand side of the expression should match the <code>name</code> because we aren’t actually iterating this kernel with a population vector. We don’t have additional parameters that need to be passed to complete the construction of the kernel, so <code>data_list</code> can be empty. Finally, we specify <code>evict_cor = FALSE</code> in the <code>K</code> because we’ve already corrected for it in the previous kernel definitions.</p>
</div>
<div id="defining-the-implementation-arguments-impl_args" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-the-implementation-arguments-impl_args" class="anchor"></a>Defining the implementation arguments (<code>impl_args</code>)</h3>
<p>Next, we need to define how the kernels are implemented numerically. This is where we define the integration rule <code>int_rule</code>, the domain the kernels begin on <code>dom_start</code>, and the domain that they finish on <code>dom_end</code>. This is done with the <code><a href="../reference/define_impl.html">define_impl()</a></code> function. It takes a named list where names correspond to the kernel names, and each entry is itself a list of length 3 containing slots <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code>. Because this is a bit specific, there is a helper function that can be called within <code>define_impl</code> or called before initializing the IPM to make sure everything is formatted correctly - <code>make_ipml_args_list()</code>.</p>
<p>The first argument to the <code>make_ipml_args_list()</code> function is <code>kernel_names</code>. This is a character vector with kernel names for which the implementation arguments are being supplied.</p>
<p>Next, <code>int_rule</code> is a character vector, and currently <code>'midpoint'</code> is the only option that is implemented. <code>'trapezoid'</code> and <code>'g-l'</code> (Gauss-Legendre) are on the to-do list. Additional rules may be added if there is more demand for certain ones (e.g. cumulative density functions like in <code>IPMpack</code>).</p>
<p><code>dom_start</code> and <code>dom_end</code> are always the same in <code>simple_*</code> IPMs. In <code>general_*</code> ones, they may be different, or, if describing a transition involving a discrete state, they may be <code>NA</code>. For all non-<code>NA</code> <code>dom_*</code>’s, they are one of the variables in the <code>states</code> list. <code>dom_start</code>’s have <code>_1</code> and <code>dom_end</code>’s have <code>_2</code> appended to them internally, so they may be referenced by vital rate functions without explicitly creating a variable for them.</p>
<p>Elements of each vector in each argument in <code><a href="../reference/define_impl.html">make_impl_args_list()</a></code> are matched by position. Thus, if you specify <code>"K"</code> as the first entry in <code>kernel_names</code>, then the first entries of <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code> should all correspond to the <code>K</code> kernel. If you specify <code>"P"</code> as the second entry, the second entries in <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code> should be the rules that correspond to the <code>P</code> kernel, and so on.</p>
<p>It is important to note that <code>make_impl_args_list</code> <em>does not return a <code>proto_ipm</code></em>. Thus, it must either be called before beginning the model definition, or inside of <code>define_impl</code>!</p>
<div class="sourceCode" id="cb6"><pre class="downlit">
<span class="co"># Alternative 1 - call make_impl_args_list() before beginning the IPM creation pipe</span>

<span class="kw">impl_args</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
  kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
  int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
  dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
  dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>)
)

<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(<span class="kw">impl_args</span>)

<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span> <span class="op">%&gt;%</span>
  
  <span class="co"># Alternative 2, put the call to make_impl_args_list() inside of define_impl(). </span>
  
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>,<span class="fl">3</span>)
    )
  )

<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span> <span class="op">%&gt;%</span>
  
  <span class="co"># Alternative 3 - skip make_ipml_args_list and create each entry by hand</span>
  
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      K = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(int_rule  = <span class="st">"midpoint"</span>,
               dom_start = <span class="st">"dbh"</span>,
               dom_end   = <span class="st">"dbh"</span>),
      P = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(int_rule  = <span class="st">"midpoint"</span>,
               dom_start = <span class="st">"dbh"</span>,
               dom_end   = <span class="st">"dbh"</span>),
      F = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(int_rule  = <span class="st">"midpoint"</span>,
               dom_start = <span class="st">"dbh"</span>,
               dom_end   = <span class="st">"dbh"</span>)
    )
  )
</pre></div>
<p>All 3 alternatives in the chunk above create the exact same output. You are free to use whichever format you think is easiest.</p>
</div>
<div id="defining-domains-for-state-variables" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-domains-for-state-variables" class="anchor"></a>Defining domains for state variables</h3>
<p>The final step in creating an IPM with <code>ipmr</code> is to define the domain of each state variable in the <code>states</code> list. This is done with the <code><a href="../reference/define_impl.html">define_domains()</a></code> function. When the <code>int_rule</code> is <code>"midpoint"</code>, this takes a named set of vectors that have 3 entries each. The name corresponds to the <code>state</code> it is associated with, the first entry is the lower bound, the second entry is the upper bound, and the third entry is the number of meshpoints.</p>
<p>Note that for other <code>int_rule</code>s, the vectors associated with each domain will look different. However, those are not yet implemented and so beyond the scope of this vignette for now.</p>
<div class="sourceCode" id="cb7"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(
    dbh = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(        <span class="co"># the name of the state variable</span>
      <span class="fl">1</span>,            <span class="co"># the lower bound for the domain</span>
      <span class="fl">30</span>,           <span class="co"># the upper bound for the domain</span>
      <span class="fl">200</span>           <span class="co"># the number of mesh points to use for integration</span>
    )    
  )
</pre></div>
</div>
</div>
<div id="implement-the-ipm" class="section level2">
<h2 class="hasAnchor">
<a href="#implement-the-ipm" class="anchor"></a>Implement the IPM</h2>
<p>The minimal set of information to generate a single deterministic kernel is now wrapped up in our <code>proto_ipm</code> and it is time to <code><a href="../reference/make_ipm.html">make_ipm()</a></code>! <code><a href="../reference/make_ipm.html">make_ipm()</a></code> is a generic function and will work with all combinations of density independent <code>model_class</code>es.</p>
<div class="sourceCode" id="cb8"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(<span class="kw">my_ipm</span>)

<span class="kw">lambda_ipmr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">my_ipm</span>, 
                      comp_method = <span class="st">'eigen'</span>)
<span class="kw">repro_value</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/right_ev.html">left_ev</a></span>(<span class="kw">my_ipm</span>)
<span class="kw">stable_dist</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/right_ev.html">right_ev</a></span>(<span class="kw">my_ipm</span>)
</pre></div>
<p>In this example, there are no additional arguments that need to be passed to <code><a href="../reference/make_ipm.html">make_ipm()</a></code> - the <code>proto_ipm</code> has all of the information needed to generate a deterministic iteration kernel. All of the <code><a href="../reference/make_ipm.html">make_ipm()</a></code> methods return a list with a length of 6 with entries:</p>
<ul>
<li><p><code>iterators</code> contains iteration kernels, AKA <code>K</code>s.</p></li>
<li><p><code>sub_kernels</code> contains, in this example, <code>P</code> and <code>F</code>.</p></li>
<li><p><code>env_list</code> is empty, but setting <code>return_all = TRUE</code> in <code><a href="../reference/make_ipm.html">make_ipm()</a></code> returns the evaluation environments for each kernel and sub-kernel. These are used by subsequent analysis methods and so are important for internal usage, but are probably of limited use to most users.</p></li>
<li><p><code>env_seq</code> contains either an integer vector with the sequence of indices used to select kernels from the <code>iterators</code> during a stochastic simulation (<code>*_stoch_kern</code>), or a matrix of parameter estimates from each iteration of the stochastic simulation (<code>*_kern_param</code>). Not relevant for <code>*_det</code> methods with a single iteration kernel and so contains either a sequence of 1s or <code>NA</code>s</p></li>
<li><p><code>pop_state</code> contains a list of matrices for each item defined in <code><a href="../reference/define_impl.html">define_pop_state()</a></code>. In this case, we never defined the initial population state, so it will be empty. When <code><a href="../reference/define_impl.html">define_pop_state()</a></code> is used with <code>iterate = TRUE</code>, the rows of each matrix correspond to the population state and columns are time steps.</p></li>
<li><p><code>proto_ipm</code> contains the <code>proto_ipm</code> object used to generate the model. This is useful for rebuilding the model with a different set of <code>impl_args</code> or parameters to see how that changes your results.</p></li>
</ul>
<p><code>lambda</code>, <code>left_ev</code>, and <code>right_ev</code> are generic functions corresponding to the dominant eigenvalue, dominant left eigenvector, and dominant right eigenvector respectively. <code>lambda</code> is available for all classes of IPMs, while <code>left/right_ev</code> is available for all deterministic IPMs. Stochastic equivalents of the latter will get implemented eventually.</p>
<div id="using-predict-methods-in-vital-rate-expressions" class="section level3">
<h3 class="hasAnchor">
<a href="#using-predict-methods-in-vital-rate-expressions" class="anchor"></a>Using <code>predict()</code> methods in vital rate expressions</h3>
<p>The vast majority of modelling pipelines entail fitting a statistical models to data to create vital rate functions. Thus, we’re typically working with model objects rather than just parameter values. Sometimes the models have many terms, including interactions and/or hierarchical effects, and the vital rate expressions are annoying to write out in full. Furthermore, the flexibility of IPMs means our vital rate models may be semi- or fully non-parameteric, and writing out the functional form may not even be possible prior to the model fitting exercise (e.g. a GAM).</p>
<p>To deal with this, many regression modelling packages provide a <code>predict</code> method for the class of models that they implement. We can use these in <code>ipmr</code> to take the place of the vital rate expressions (more common) or the kernel formulas (probably not as common).</p>
<p>We’ll go through a quick example of how to incorporate these expressions into the model building process using a data set for <em>Carpobrotus edulis</em>, an invasive succulent. This is real data collected in Israel and appears in Bogdan et al. (<em>in prep</em>). The data set is also included in <code>ipmr</code> and can be loaded by running <code><a href="https://rdrr.io/r/utils/data.html">data(iceplant_ex)</a></code>.</p>
<p>First, we’ll load in the example data set and fit some simple vital rate models. Some notes about the data:</p>
<ol style="list-style-type: decimal">
<li><p><code>log_size</code>/<code>log_size_next</code> are log transformed surface areas in <span class="math inline">\(\mathrm{m}^2\)</span>. This will be the state variable for the model, and is abbreviated <code>sa_1</code> and <code>sa_2</code> in the model implementation code below.</p></li>
<li><p><code>repro</code> indicates whether or not a plant flowered and is either 0 or 1</p></li>
<li><p><code>flower_n</code> indicates the number of flowers a reproductive plant made, so is either a positive integer or <code>NA</code>.</p></li>
</ol>
<p>The vital rates models and the IPM variable names are as follows (<code>vital_rate_model</code>, <code>IPM_variable_name</code>):</p>
<ol style="list-style-type: decimal">
<li><p>Growth (<code>grow_mod</code>, <code>g</code>)</p></li>
<li><p>Survival (<code>surv_mod</code>, <code>s</code>)</p></li>
<li><p>Probability of flowering (<code>repr_mod</code>, <code>f_p</code>)</p></li>
<li><p>Number of flowers for flowering plants (<code>seed_mod</code>, <code>f_s</code>)</p></li>
<li><p>Total number of new recruits at <span class="math inline">\(t + 1\)</span> (<code>recr_n</code>, <code>recr_n</code>)</p></li>
<li><p>Total number of flowers at <span class="math inline">\(t\)</span> (<code>flow_n</code>, <code>flow_n</code>)</p></li>
<li><p>The number of new recruits at <span class="math inline">\(t+1\)</span> per flower at <span class="math inline">\(t\)</span> (<code>NA</code>, <code>f_r</code>)</p></li>
</ol>
<ul>
<li>This is <code>f_r = recr_n / flow_n</code>
</li>
</ul>
<ol start="8" style="list-style-type: decimal">
<li>Recruit size distribution (<code>recr_mu, recr_sd</code>, <code>f_d</code>)</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">ipmr</span>)

<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="kw">iceplant_ex</span>)

<span class="co"># growth model</span>

<span class="kw">grow_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span>(<span class="kw">log_size_next</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>)
<span class="kw">grow_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/residuals.html">resid</a></span>(<span class="kw">grow_mod</span>))


<span class="co"># survival model</span>

<span class="kw">surv_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">survival</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())

<span class="co"># Pr(flowering) model</span>

<span class="kw">repr_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">repro</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())

<span class="co"># Number of flowers per plant model</span>

<span class="kw">seed_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">flower_n</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">poisson</a></span>())

<span class="co"># New recruits have no size(t), but do have size(t + 1)</span>

<span class="kw">recr_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html">subset</a></span>(<span class="kw">iceplant_ex</span>, <span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">log_size</span>))

<span class="kw">recr_mu</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
<span class="kw">recr_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)

<span class="co"># This data set doesn't include information on germination and establishment.</span>
<span class="co"># Thus, we'll compute the realized recruitment parameter as the number</span>
<span class="co"># of observed recruits divided by the number of flowers produced in the prior</span>
<span class="co"># year. </span>

<span class="kw">recr_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)

<span class="kw">flow_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">flower_n</span>, na.rm = <span class="fl">TRUE</span>)

<span class="co"># Now, we bundle everything into a list as we did before. We can</span>
<span class="co"># pass the model objects directly into the list, and do not need to extract</span>
<span class="co"># coefficients. </span>

<span class="kw">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(recr_mu = <span class="kw">recr_mu</span>,
               recr_sd = <span class="kw">recr_sd</span>,
               grow_sd = <span class="kw">grow_sd</span>,
               surv_mod = <span class="kw">surv_mod</span>,
               grow_mod = <span class="kw">grow_mod</span>,
               repr_mod = <span class="kw">repr_mod</span>,
               seed_mod = <span class="kw">seed_mod</span>,
               recr_n   = <span class="kw">recr_n</span>,
               flow_n   = <span class="kw">flow_n</span>)

<span class="co"># The lower and upper bounds for integration. Adding 20% on either end to minimize</span>
<span class="co"># eviction</span>

<span class="kw">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">0.8</span>
<span class="kw">U</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">1.2</span>
</pre></div>
<p>We now have everything we need to get started. We use almost the same code as the first example to implement the model, but substitute <code><a href="https://rdrr.io/r/stats/predict.html">predict()</a></code> in for the mathematical form of the vital rate expressions. When we do this, we have to make sure that the names of the <code>newdata</code> argument in <code>predict</code> match the names in our model formula, and that the values we put into it are the names of the state variables in our model. These same caveats apply to using <code>predict</code> interactively.</p>
<div class="sourceCode" id="cb10"><pre class="downlit">
<span class="kw">pred_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">"simple_di_det"</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"P"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    
    <span class="co"># Instead of the inverse logit transformation, we use predict() here.</span>
    <span class="co"># We have to be sure that the "newdata" argument of predict is correctly specified.</span>
    <span class="co"># This means matching the names used in the model itself (log_size) to the names</span>
    <span class="co"># we give the domains (sa_1). In this case, we use "sa" (short for surface area) as</span>
    <span class="co"># the new data to generate predictions for.</span>
    
    s             = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">surv_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type    = <span class="st">'response'</span>),
    g_mu          = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">grow_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type    = <span class="st">'response'</span>),
    
    <span class="co"># We specify the rest of the kernel the same way.</span>
    
    g             = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">g_mu</span>, <span class="kw">grow_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>, 
                                            param = <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"F"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">f_p</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span> <span class="op">*</span> <span class="kw">f_r</span>,
    
    <span class="co"># As above, we use predict(model_object). We make sure the names of the "newdata"</span>
    <span class="co"># match the names in the vital rate model formulas, and the values match the </span>
    <span class="co"># names of domains they use.</span>
    
    f_p           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">repr_mod</span>,
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type    = <span class="st">'response'</span>),
    f_s           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">seed_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type    = <span class="st">'response'</span>),
    f_r           = <span class="kw">recr_n</span> <span class="op">/</span> <span class="kw">flow_n</span>,
    f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">recr_mu</span>, <span class="kw">recr_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>,
                                            param = <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name          = <span class="st">"K"</span>,
    family        = <span class="st">"IPM"</span>,
    K             = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(
    sa = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">L</span>,
           <span class="kw">U</span>,
           <span class="fl">100</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(iterate = <span class="fl">FALSE</span>)
</pre></div>
<p><code><a href="../reference/make_ipm.html">make_ipm()</a></code> can handle most types of widely used model classes without any additional effort (e.g. <code>lm</code>, <code>glm</code>, <code>lme4</code>, <code>brms</code>, <code>nlme</code>, <code>stanfit</code>, <code>betareg</code>). The list of method available in <code>ipmr</code> is not exhaustive though, and sometimes there will be errors.</p>
<p>If you are sure that a <code>predict</code> method exists for your model type, but you get errors along the lines of <code>Element &lt;some number&gt; of</code>.x<code>must be a vector, not a call</code>, this usually means that I forgot to add the class of model you’re trying to use to <code>ipmr</code>. We can get around this by wrapping those model objects in <code><a href="../reference/use_vr_model.html">use_vr_model()</a></code>. Please also create an <a href="https://github.com/levisc8/ipmr/issues">Issue here</a> describing the model class you’re trying to work with so it can be added to future versions.</p>
<p>Say our growth model isn’t recognized by <code>ipmr</code>. We try to <code><a href="../reference/make_ipm.html">make_ipm()</a></code>, and get our obscure error message about <code>.x</code>. The snippet below shows how to rectify this. We wrap our model objects in <code><a href="../reference/use_vr_model.html">use_vr_model()</a></code> when creating the <code>data_list</code>, and then re-run it with the exact same code as above. <code><a href="../reference/use_vr_model.html">use_vr_model()</a></code> tells <code>ipmr</code> that this object is a model object, not a raw parameter value. As the package (hopefully) gets used more widely, this issue should disappear, and <code><a href="../reference/use_vr_model.html">use_vr_model()</a></code> will (hopefully) become obsolete.</p>
<div class="sourceCode" id="cb11"><pre class="downlit">
<span class="kw">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(recr_mu = <span class="kw">recr_mu</span>,
               recr_sd = <span class="kw">recr_sd</span>,
               grow_sd = <span class="kw">grow_sd</span>,
               surv_mod = <span class="fu"><a href="../reference/use_vr_model.html">use_vr_model</a></span>(<span class="kw">surv_mod</span>),  <span class="co"># wrap the model</span>
               grow_mod = <span class="fu"><a href="../reference/use_vr_model.html">use_vr_model</a></span>(<span class="kw">grow_mod</span>),  <span class="co"># wrap the model</span>
               repr_mod = <span class="fu"><a href="../reference/use_vr_model.html">use_vr_model</a></span>(<span class="kw">repr_mod</span>),  <span class="co"># wrap the model</span>
               seed_mod = <span class="fu"><a href="../reference/use_vr_model.html">use_vr_model</a></span>(<span class="kw">seed_mod</span>),  <span class="co"># wrap the model</span>
               recr_n   = <span class="kw">recr_n</span>,
               flow_n   = <span class="kw">flow_n</span>)


<span class="kw">pred_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">"simple_di_det"</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"P"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    s             = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">surv_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type = <span class="st">'response'</span>),
    g_mu          = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">grow_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type = <span class="st">'response'</span>),
    g             = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">g_mu</span>, <span class="kw">grow_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"F"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">f_p</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span> <span class="op">*</span> <span class="kw">f_r</span>,
    f_p           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">repr_mod</span>,
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type = <span class="st">'response'</span>),
    f_s           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">seed_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type = <span class="st">'response'</span>),
    f_r           = <span class="kw">recr_n</span> <span class="op">/</span> <span class="kw">flow_n</span>,
    f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">recr_mu</span>, <span class="kw">recr_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name          = <span class="st">"K"</span>,
    family        = <span class="st">"IPM"</span>,
    K             = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(
    sa = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">L</span>,
           <span class="kw">U</span>,
           <span class="fl">100</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(iterate = <span class="fl">FALSE</span>)
</pre></div>
</div>
</div>
<div id="defining-more-complicated-models" class="section level2">
<h2 class="hasAnchor">
<a href="#defining-more-complicated-models" class="anchor"></a>Defining more complicated models</h2>
<p>In the example above, we created a model with a single, deterministic kernel defined by a single state variable. Next, we’ll go through an example showing how to build kernels that are constructed from discretely varying parameter estimates.</p>
<div id="hier-effs-det" class="section level3">
<h3 class="hasAnchor">
<a href="#hier-effs-det" class="anchor"></a>Deterministic simulations with hierarchical models</h3>
<p>Say we have multiple sites sampled in the same year, but are only interested in their asymptotic dynamics (perhaps to compare performance across space). <code>ipmr</code> uses a syntax that closely mirrors the mathematical notation of these models to successively build up more complicated expressions without requiring that much extra code as compared to the examples above.</p>
<p>The general idea is to append a suffix to each variable that is modified, and supply a list of values that the suffix can actually take in the <code>levels_hier_effs</code> slot of <code><a href="../reference/define_kernel.html">define_kernel()</a></code>. There is an entire vignette dedicated to translating math to R code to the <code>ipmr</code> syntax <a href="https://levisc8.github.io/ipmr/articles/hierarchical-notation.html">here</a>.</p>
<p><strong>NOTE:</strong> Because of the way <code>ipmr</code> handles population vectors internally, <strong>the only suffix that isn’t allowed is <code>_pop</code></strong>. This is unfortunate, but can be worked around. Please use <code>_site</code> or <code>_popul</code> or something instead. Sorry!</p>
<p>For this example, we’ll use the following vital rate models. The <code>(g)lmer</code> functions are from the <code>lme4</code> package.</p>
<ol style="list-style-type: decimal">
<li>
<p>survival (<code>s_site</code>): a logistic regression with a random site intercept (<code>s_r_site</code>).</p>
<ul>
<li>Example model formula: <code>glmer(surv ~ size_1 + (1 | site), data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>growth (<code>g_site</code>): A linear regression random site intercept (<code>g_r_site</code>).</p>
<ul>
<li>Example model formula: <code>lmer(size_2 ~ size_1 + (1 | site), data = my_grow_data, family = gaussian()))</code>
</li>
</ul>
</li>
<li>
<p>pr(flowering) (<code>p_r</code>): A logistic regression. This has no random site effect.</p>
<ul>
<li>Example model formula: <code>glm(flower ~ size_1 , data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>seed production (<code>f_s_site</code>): A poisson regression with a random site intercept (<code>f_s_r_site</code>)</p>
<ul>
<li>Example model formula: <code>glmer(seed_num ~ size_1 + (1 | site), data = my_surv_data, family = poisson()))</code>
</li>
</ul>
</li>
<li><p>recruit size distribution (<code>f_d</code>): A normal distribution with two constant parameters, the mean (<code>mu_fd</code>) and standard deviation (<code>sd_fd</code>).</p></li>
</ol>
<p>For models where parameters come from a joint distribution (e.g. regressions with multiple responses, Bayesian multi-level models), <code>*_stoch_param</code> methods are usually more appropriate.</p>
<p>The chunk below takes the place of fitting regression models to actual data, so the code that replaces this chunk will look a little different (and probably involve the use of <code>fixef(some_vital_rate_model</code> and <code><a href="https://rdrr.io/pkg/lme4/man/ranef.html">ranef(some_vital_rate_model)</a></code>)).</p>
<div class="sourceCode" id="cb12"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">ipmr</span>)

<span class="co"># Define some fixed parameters</span>

<span class="kw">fixed_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
  s_int     = <span class="fl">1.03</span>,   <span class="co"># fixef(my_surv_mod)[1] - uses fixef because we now have a model with random effects</span>
  s_slope   = <span class="fl">2.2</span>,    <span class="co"># fixef(my_surv_mod)[2]</span>
  g_int     = <span class="fl">3.7</span>,    <span class="co"># fixef(my_grow_mod)[1]</span>
  g_slope   = <span class="fl">0.92</span>,   <span class="co"># fixef(my_grow_mod)[2]</span>
  sd_g      = <span class="fl">0.9</span>,    <span class="co"># sd(resid(my_grow_mod))</span>
  f_r_int   = <span class="fl">0.09</span>,   <span class="co"># coef(my_repro_mod)[1] - uses coef because there are no random effects in this model</span>
  f_r_slope = <span class="fl">0.05</span>,   <span class="co"># coef(my_repro_mod)[2]</span>
  f_s_int   = <span class="fl">0.1</span>,    <span class="co"># fixef(my_flower_mod)[1]</span>
  f_s_slope = <span class="fl">0.005</span>,  <span class="co"># fixef(my_flower_mod)[2]</span>
  mu_fd     = <span class="fl">9</span>,      <span class="co"># mean(my_recr_data$size_2, na.rm = TRUE)</span>
  sd_fd     = <span class="fl">2</span>       <span class="co"># sd(my_recr_data$size_2, na.rm = TRUE)</span>
)
</pre></div>
<p>We’ve defined a <code>fixed_list</code> that holds all of the fixed parameters in our model. Next, we’ll make up some random site specific intercepts, and add those to the <code>fixed_list</code>, naming it <code>all_params_list</code>. You don’t necessarily need to rename anything, this is just for disambiguation.</p>
<div class="sourceCode" id="cb13"><pre class="downlit">
<span class="co"># Now, simulate some random intercepts for growth (g_), survival (s_), </span>
<span class="co"># and offspring production (f_s_). This part is for the purpose of the example.</span>

<span class="co"># First, we create vector of values that each random component can take.</span>

<span class="kw">g_r_int</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.3</span>) <span class="co"># unlist(ranef(my_grow_mod)) for an lme4 output</span>
<span class="kw">s_r_int</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.7</span>) <span class="co"># unlist(ranef(my_surv_mod)) for an lme4 output</span>
<span class="kw">f_s_r_int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.2</span>) <span class="co"># unlist(ranef(my_flower_mod)) for an lme4 output</span>

<span class="kw">nms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"r_"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, sep = <span class="st">""</span>)

<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">g_r_int</span>)   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'g_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">s_r_int</span>)   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'s_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">f_s_r_int</span>) <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'f_s_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)

<span class="co"># Each set of parameters is converted to a named list. The names should match</span>
<span class="co"># the variables referenced in each define_kernel()/define_k() call.</span>

<span class="kw">g_params</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">g_r_int</span>)
<span class="kw">s_params</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">s_r_int</span>)
<span class="kw">f_s_params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">f_s_r_int</span>)

<span class="co"># add them all together using c()</span>

<span class="kw">all_params_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">fixed_list</span>, <span class="kw">g_params</span>, <span class="kw">s_params</span>, <span class="kw">f_s_params</span>)
</pre></div>
<p>We’ve created a list where each entry is named and contains a single parameter value. This is now ready for use in <code><a href="../reference/define_kernel.html">define_kernel()</a></code></p>
<div class="sourceCode" id="cb14"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    
    <span class="co"># Our P kernels will vary from site to site, so we append the "_site" suffix</span>
    <span class="co"># to them.</span>
    
    name             = <span class="st">'P_site'</span>,  
    
    <span class="co"># Similarly, our survival and growth functions will vary from site to site</span>
    <span class="co"># so these are also modified</span>
    
    formula          = <span class="kw">s_site</span> <span class="op">*</span> <span class="kw">g_site</span>,   
    family           = <span class="st">"CC"</span>,
    
    <span class="co"># The linear predictor for the survival function can be split out</span>
    <span class="co"># into its own expression as well. This might help keep track of things.</span>
    s_lin_site       = <span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_r_site</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">ht_1</span>,
    s_site           = <span class="fl">1</span> <span class="op">/</span> (<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span><span class="kw">s_lin_site</span>)),
    
    <span class="co"># Again, we modify the vital rate expression to include "_site".</span>
    
    g_site           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">ht_2</span>, mean = <span class="kw">mu_g_site</span>, sd = <span class="kw">sd_g</span>),
    mu_g_site        = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">ht_1</span> <span class="op">+</span> <span class="kw">g_r_site</span>,
    
    data_list        = <span class="kw">all_params_list</span>,
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    
    <span class="co"># Here, we tell ipmr that the model has some hierarchical variable, and </span>
    <span class="co"># provide a list describing the values it can take. The values in </span>
    <span class="co"># levels_hier_effs are substituted for "site" everywhere in the model, except</span>
    <span class="co"># for the data list. This is why we had to make sure that the names there</span>
    <span class="co"># matched the levels we supply here.</span>
    
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(site = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    
    <span class="co"># We must also modify the variables in the eviction function</span>
    
    evict_cor        = <span class="fl">TRUE</span>,
    evict_fun        = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g_site"</span>)
    
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    
    <span class="co"># The F kernel also varies from site to site</span>
    
    name             = <span class="st">"F_site"</span>,             
    formula          = <span class="kw">f_r</span> <span class="op">*</span> <span class="kw">f_s_site</span> <span class="op">*</span> <span class="kw">f_d</span>,
    family           = <span class="st">"CC"</span>,
    
    <span class="co"># In this example, we didn't include a site level effect for probability</span>
    <span class="co"># of flowering, only seed production. Thus, this expression is NOT modified.</span>
    
    f_r_lin          = <span class="kw">f_r_int</span> <span class="op">+</span> <span class="kw">f_r_slope</span> <span class="op">*</span> <span class="kw">ht_1</span>,
    f_r              = <span class="fl">1</span> <span class="op">/</span> (<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span> <span class="kw">f_r_lin</span>)),
    
    <span class="co"># We modify the seed production expression with the site effect</span>
    
    f_s_site         = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="kw">f_s_int</span> <span class="op">+</span> <span class="kw">f_s_r_site</span> <span class="op">+</span> <span class="kw">f_s_slope</span> <span class="op">*</span> <span class="kw">ht_1</span>),
    f_d              = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">ht_2</span>, mean = <span class="kw">mu_fd</span>, sd = <span class="kw">sd_fd</span>),
    data_list        = <span class="kw">all_params_list</span>,
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    
    <span class="co"># As in the P kernel, we specify the levels the hierarchical variable</span>
    <span class="co"># can take, and modify the eviction function.</span>
    
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(site = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">TRUE</span>,
    evict_fun        = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    
    <span class="co"># We also modify the K expressions. </span>
    
    name             = <span class="st">'K_site'</span>,
    K_site           = <span class="kw">P_site</span> <span class="op">+</span> <span class="kw">F_site</span>,
    family           = <span class="st">"IPM"</span>,
    data_list        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>)),
    has_hier_effs    = <span class="fl">TRUE</span>,
    
    <span class="co"># As in the P kernel, we specify the levels the hierarchical variable</span>
    <span class="co"># can take, and modify the eviction function.</span>
    
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(site = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      
      <span class="co"># The impl_args are also modified with the suffix</span>
      
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K_site"</span>, <span class="st">"P_site"</span>, <span class="st">"F_site"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(ht = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.2</span>, <span class="fl">40</span>, <span class="fl">100</span>)) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(iterate  = <span class="fl">FALSE</span>)
  

<span class="co"># By default, ipmr computes lambdas based on population sizes, not eigenvalues.</span>
<span class="co"># We can change that behavior for simple IPMs by specifying comp_method = "eigen"</span>

<span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">my_ipm</span>, comp_method = <span class="st">"eigen"</span>)
</pre></div>
<p>Aside from appending <code>_site</code> to a number of variables, the code is pretty much the same as the first example. <code>ipmr</code> automatically substitutes 1, 2, 3, 4, and 5 for each occurence of <code>site</code> in the kernel formulas and vital rate expressions. Thus, <code>P_site</code> is expanded to <code>P_1</code>, <code>P_2</code>, <code>P_3</code>, <code>P_4</code>, <code>P_5</code>, <code>s_yr</code> to <code>s_1</code>, <code>s_2</code>, <code>s_3</code>, <code>s_4</code>, and <code>s_5</code>. <code>s_r_site</code> is converted to <code>s_r_1</code>, <code>s_r_2</code>, etc. This is why we needed to make sure the names in <code>all_params_list</code> had the actual numbers appended to them.</p>
<p>For more complicated models, you may need multiple suffixes. In those cases, you can append them in order you like to each variable. For example, sites (<code>_site</code>) and years (<code>_yr</code>) could be appended to survival (<code>s_</code>) like so:</p>
<p><code>s_site_yr = some_expression</code></p>
<p>The <code>levels_hier_effs</code> list then gets modified like so:</p>
<p><code>levels_hier_effs = list(site = c("A", "B", "C"), yr = c(2001:2005))</code></p>
</div>
<div id="disc-varying" class="section level3">
<h3 class="hasAnchor">
<a href="#disc-varying" class="anchor"></a>Defining a stochastic IPM in a discretely varying environment</h3>
<p>In the example above, we first created a model with a single, deterministic kernel defined by a single state variable. Then we modeled multiple sites with deterministic kernels that varied from site to site. Next, we’ll go through an example showing how to build stochastic models from kernels that are constructed from discretely varying parameter estimates.</p>
<p>The example below is the same as the last example, except that this time, our hierarchical effect is “year” (suffixed <code>_yr</code>) and we’ll run a simulation by randomly choosing a year’s kernel at each iteration (“kernel resampling”), rather than just building them for every year. This will require us to specify a population vector before running the model. Along the way, we’ll also learn how to pass custom functions to the model.</p>
<p>The vital rate models are as follows:</p>
<ol style="list-style-type: decimal">
<li>
<p>survival (<code>s_yr</code>): a logistic regression with a random year intercept (<code>s_r_yr</code>).</p>
<ul>
<li>Example model formula: <code>glmer(surv ~ size_1 + (1 | yr), data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>growth (<code>g_yr</code>): A linear regression random year intercept (<code>g_r_yr</code>).</p>
<ul>
<li>Example model formula: <code>lmer(size_2 ~ size_1 + (1 | yr), data = my_grow_data, family = gaussian()))</code>
</li>
</ul>
</li>
<li>
<p>pr(flowering) (<code>p_r</code>): A logistic regression. This has no random year effect.</p>
<ul>
<li>Example model formula: <code>glm(flower ~ size_1 , data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>seed production (<code>f_s_yr</code>): A poisson regression with a random year intercept (<code>f_s_r_yr</code>)</p>
<ul>
<li>Example model formula: <code>glmer(seed_num ~ size_1 + (1 | yr), data = my_surv_data, family = poisson()))</code>
</li>
</ul>
</li>
<li><p>recruit size distribution (<code>f_d</code>): A normal distribution with two constant parameters, the mean (<code>mu_fd</code>) and standard deviation (<code>sd_fd</code>).</p></li>
</ol>
<p>The chunk below takes the place of fitting regression models to actual data, so the code that replaces this chunk will look a little different (and probably involve the use of <code>coef(some_vital_rate_model</code>)).</p>
<div class="sourceCode" id="cb15"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">ipmr</span>)

<span class="co"># Define some fixed parameters</span>

<span class="kw">fixed_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
  s_int     = <span class="fl">1.03</span>,   <span class="co"># fixef(my_surv_mod)[1] - uses fixef because we now have a model with random effects</span>
  s_slope   = <span class="fl">2.2</span>,    <span class="co"># fixef(my_surv_mod)[2]</span>
  g_int     = <span class="fl">3.7</span>,    <span class="co"># fixef(my_grow_mod)[1]</span>
  g_slope   = <span class="fl">0.92</span>,   <span class="co"># fixef(my_grow_mod)[2]</span>
  sd_g      = <span class="fl">0.9</span>,    <span class="co"># sd(resid(my_grow_mod))</span>
  f_r_int   = <span class="fl">0.09</span>,   <span class="co"># coef(my_repro_mod)[1] - uses coef because there are no random effects in this model</span>
  f_r_slope = <span class="fl">0.05</span>,   <span class="co"># coef(my_repro_mod)[2]</span>
  f_s_int   = <span class="fl">0.1</span>,    <span class="co"># fixef(my_flower_mod)[1]</span>
  f_s_slope = <span class="fl">0.005</span>,  <span class="co"># fixef(my_flower_mod)[2]</span>
  mu_fd     = <span class="fl">9</span>,      <span class="co"># mean(my_recr_data$size_2, na.rm = TRUE)</span>
  sd_fd     = <span class="fl">2</span>       <span class="co"># sd(my_recr_data$size_2, na.rm = TRUE)</span>
)
</pre></div>
<p>We’ve defined a <code>fixed_list</code> that holds all of the fixed parameters in our model. Next, we’ll make up some random year specific intercepts, and add those to the <code>fixed_list</code>, naming it <code>all_params_list</code>. You don’t necessarily need to rename anything, this is just for disambiguation.</p>
<div class="sourceCode" id="cb16"><pre class="downlit">
<span class="co"># Now, simulate some random intercepts for growth (g_), survival (s_), </span>
<span class="co"># and offspring production (f_s_). This part is for the purpose of the example.</span>

<span class="co"># First, we create vector of values corresponding to </span>

<span class="kw">g_r_int</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.3</span>) <span class="co"># unlist(ranef(my_grow_mod)) for an lme4 output</span>
<span class="kw">s_r_int</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.7</span>) <span class="co"># unlist(ranef(my_surv_mod)) for an lme4 output</span>
<span class="kw">f_s_r_int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.2</span>) <span class="co"># unlist(ranef(my_flower_mod)) for an lme4 output</span>

<span class="kw">nms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"r_"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, sep = <span class="st">""</span>)

<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">g_r_int</span>)   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'g_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">s_r_int</span>)   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'s_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">f_s_r_int</span>) <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'f_s_'</span>, <span class="kw">nms</span>, sep = <span class="st">""</span>)

<span class="co"># Each set of parameters is converted to a named list. The names should match</span>
<span class="co"># the variables referenced in each define_kernel()/define_k() call.</span>

<span class="kw">g_params</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">g_r_int</span>)
<span class="kw">s_params</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">s_r_int</span>)
<span class="kw">f_s_params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">f_s_r_int</span>)

<span class="co"># add them all together using c()</span>

<span class="kw">all_params_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">fixed_list</span>, <span class="kw">g_params</span>, <span class="kw">s_params</span>, <span class="kw">f_s_params</span>)
</pre></div>
<p>We’ve created a list where each entry is named and contains a single parameter value. This is now ready for use in <code><a href="../reference/define_kernel.html">define_kernel()</a></code></p>
</div>
<div id="defining-custom-functions-to-pass-to-the-building-process" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-custom-functions-to-pass-to-the-building-process" class="anchor"></a>Defining custom functions to pass to the building process</h3>
<p>We have our parameter values. In the next step, we’ll compose some helper functions to make the vital rate expressions inside of <code><a href="../reference/define_kernel.html">define_kernel()</a></code> a bit more concise and expressive. These are passed in a list to the <code>usr_funs</code> argument of <code><a href="../reference/make_ipm.html">make_ipm()</a></code>.</p>
<div class="sourceCode" id="cb17"><pre class="downlit">
<span class="kw">inv_logit</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">sv</span>, <span class="kw">int</span>, <span class="kw">slope</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">int</span> <span class="op">+</span> <span class="kw">slope</span> <span class="op">*</span> <span class="kw">sv</span>)))
  )
}

<span class="co"># same as above, but handles the extra term from the random effect we simulated.</span>

<span class="kw">inv_logit_r</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">sv</span>, <span class="kw">int</span>, <span class="kw">slope</span>, <span class="kw">r_eff</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>(<span class="kw">int</span> <span class="op">+</span> <span class="kw">slope</span> <span class="op">*</span> <span class="kw">sv</span> <span class="op">+</span> <span class="kw">r_eff</span>)))
  )
}

<span class="kw">pois_r</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">sv</span>, <span class="kw">int</span>, <span class="kw">slope</span>, <span class="kw">r_eff</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(
      <span class="kw">int</span> <span class="op">+</span> <span class="kw">slope</span> <span class="op">*</span> <span class="kw">sv</span> <span class="op">+</span> <span class="kw">r_eff</span>
    )
  )
}

<span class="kw">my_funs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(inv_logit   = <span class="kw">inv_logit</span>,
                inv_logit_r = <span class="kw">inv_logit_r</span>,
                pois_r      = <span class="kw">pois_r</span>)
</pre></div>
<p>The only requirement for these functions is that they contain valid R code, and they return either real numbers or integers.</p>
</div>
<div id="implement-the-ipm-1" class="section level3">
<h3 class="hasAnchor">
<a href="#implement-the-ipm-1" class="anchor"></a>Implement the IPM</h3>
<p>With the functions and parameter values defined, we are now ready to begin composing the model. Each expression’s syntax will look very similar to the deterministic example - the main difference is we are not pretending that our hierarchical effect is year (<code>_yr</code>) as opposed to site.</p>
<div class="sourceCode" id="cb18"><pre class="downlit">
<span class="kw">my_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_stoch_kern'</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name             = <span class="st">'P_yr'</span>,         <span class="co"># P because P_yr</span>
    formula          = <span class="kw">s_yr</span> <span class="op">*</span> <span class="kw">g_yr</span>,    <span class="co"># g and s become g_yr and s_yr, respectively</span>
    family           = <span class="st">"CC"</span>,
    
    <span class="co"># Note the usage of the inv_logit_r, which we defined in the block above.</span>
    <span class="co"># it is passed to make_ipm() </span>
    
    s_yr             = <span class="fu">inv_logit_r</span>(<span class="kw">ht_1</span>, <span class="kw">s_int</span>, <span class="kw">s_slope</span>, <span class="kw">s_r_yr</span>), 
    g_yr             = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">ht_2</span>, mean = <span class="kw">mu_g_yr</span>, sd = <span class="kw">sd_g</span>),
    mu_g_yr          = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">ht_1</span> <span class="op">+</span> <span class="kw">g_r_yr</span>,
    
    <span class="co"># all_params_list contains the named parameters g_r_1, g_r_2, s_r_1, s_r_2, etc.</span>
    <span class="co"># This is the only level where the user is required to fully expand the name</span>
    <span class="co"># X hier_level combinations. </span>
    
    data_list        = <span class="kw">all_params_list</span>,
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(yr = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">TRUE</span>,
    
    <span class="co"># reference to g_yr in evict_fun is also updated</span>
    
    evict_fun        = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g_yr"</span>)
    
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name             = <span class="st">"F_yr"</span>,             <span class="co"># Update the names as we did for the P kernel</span>
    formula          = <span class="kw">f_r</span> <span class="op">*</span> <span class="kw">f_s_yr</span> <span class="op">*</span> <span class="kw">f_d</span>,
    family           = <span class="st">"CC"</span>,
    f_r              = <span class="fu">inv_logit</span>(<span class="kw">ht_1</span>, <span class="kw">f_r_int</span>, <span class="kw">f_r_slope</span>),
    f_s_yr           = <span class="fu">pois_r</span>(<span class="kw">ht_1</span>, <span class="kw">f_s_int</span>, <span class="kw">f_s_slope</span>, <span class="kw">f_s_r_yr</span>),
    f_d              = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">ht_2</span>, mean = <span class="kw">mu_fd</span>, sd = <span class="kw">sd_fd</span>),
    data_list        = <span class="kw">all_params_list</span>,
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(yr = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">TRUE</span>,
    evict_fun        = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name             = <span class="st">'K_yr'</span>,
    K_yr             = <span class="kw">P_yr</span> <span class="op">+</span> <span class="kw">F_yr</span>,
    family           = <span class="st">"IPM"</span>,
    data_list        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>)),
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(yr = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K_yr"</span>, <span class="st">"P_yr"</span>, <span class="st">"F_yr"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(ht = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.2</span>, <span class="fl">40</span>, <span class="fl">100</span>)) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(usr_funs = <span class="kw">my_funs</span>,
           iterate  = <span class="fl">FALSE</span>)
</pre></div>
<p>The only major difference between the IPM definition in the first example and this one is that we’ve passed custom functions to the call to <code><a href="../reference/make_ipm.html">make_ipm()</a></code>, and altered our vital rate expressions to use them instead of the pure math for each variable transformation. On the other hand, the contents of the output <em>will</em> look a little different.</p>
<ul>
<li><p>The <code>iterators</code> slot of <code>my_ipm</code> now contains 5 K kernels - one for each year of data.</p></li>
<li><p>The <code>sub_kernels</code> slot of <code>my_ipm</code> now contains 5 P and 5 F kernels (10 total) - again, one for each year of data.</p></li>
<li><p>All other slots will look the same as in the previous <code>simple_di_det</code> example.</p></li>
</ul>
<p>To run an actual simulation for, say, 100 time steps, we can remove the existing <code>K</code> using the helper <code><a href="../reference/define_kernel.html">remove_k()</a></code>, add a new one with <code><a href="../reference/define_kernel.html">define_k()</a></code>, and reimplement the model. This requires defining an expression that relates the population state at <code>t+1</code> to the K kernel and population state at <code>t</code> (done in <code>define_k</code>), defining an initial population state (done in <code>define_pop_state</code>), and running <code><a href="../reference/make_ipm.html">make_ipm(iterate = TRUE, iterations = insert_desired_number_iterations)</a></code>.</p>
<div class="sourceCode" id="cb19"><pre class="downlit">
<span class="kw">my_iterated_ipm</span> <span class="op">&lt;-</span> <span class="kw">my_ipm</span><span class="op">$</span><span class="kw">proto_ipm</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">remove_k</a></span>() <span class="op">%&gt;%</span>                        <span class="co"># remove the existing K and define a new one</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name             = <span class="st">"K_yr"</span>,
    K_yr             = <span class="kw">P_yr</span> <span class="op">+</span> <span class="kw">F_yr</span>,
    
    <span class="co"># n_ht_t and n_ht_t_1 are automatically created internally when </span>
    <span class="co"># define_pop_state() is called. We do not need to create them</span>
    <span class="co"># in the data_list or anything, just to specify n_ht in define_pop_state()</span>
    
    n_ht_t_1         = <span class="kw">K_yr</span> <span class="op">%*%</span> <span class="kw">n_ht_t</span>,
    family           = <span class="st">'IPM'</span>,
    data_list        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    states           = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    has_hier_effs    = <span class="fl">TRUE</span>,
    levels_hier_effs = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(yr = <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>),
    evict_cor        = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  
  <span class="co"># This time arond, we don't need to define impl_args for every kernel, just </span>
  <span class="co"># the new K. We can also skip defining the domains, those are already done</span>
  <span class="co"># too.</span>
  
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K_yr"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'midpoint'</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>)
    )
  ) <span class="op">%&gt;%</span>
  
  <span class="co"># Initialize the population vector. This can take any expression. Note that</span>
  <span class="co"># the population state has an n_ prefixed to it to indicate that it is</span>
  <span class="co"># describing the population distribution function. ipmr will automatically</span>
  <span class="co"># create variables n_ht_t and n_ht_t_1 when constructing the IPM.  </span>
  
  <span class="fu"><a href="../reference/define_impl.html">define_pop_state</a></span>(n_ht = <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">100</span>)) <span class="op">%&gt;%</span> 
  
  <span class="co"># We use the kernel_seq argument to pass a pre-specified sequence of kernels</span>
  <span class="co"># into the function, and retrieve it later using my_iterated_ipm$env_seq</span>

  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(usr_funs   = <span class="kw">my_funs</span>,
           kernel_seq = <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, <span class="fl">100</span>, replace = <span class="fl">TRUE</span>),
           iterate    = <span class="fl">TRUE</span>,
           iterations = <span class="fl">100</span>)
  

<span class="co"># lambda(comp_method = 'pop_size', type = 'stochastic') computes</span>
<span class="co"># the mean of the log'd values computed by type = 'all' (Caswell 2001, p 396).</span>
<span class="co"># This is the default option for stochastic models.</span>

<span class="kw">stoch_lambda</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">my_iterated_ipm</span>)

<span class="co"># lambda(comp_method = 'pop_size', type = 'all') will compute the population </span>
<span class="co"># growth rate for every time step as the sum(n_ht_t_1) / sum(n_ht_t).</span>

<span class="kw">iteration_lambdas</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">my_iterated_ipm</span>, type_lambda = <span class="st">'all'</span>)
</pre></div>
<p>100 iterations is not enough to estimate stochastic growth rates (<span class="math inline">\(\lambda_s\)</span>), but the computations can take some time with a lot of iterations, and are not practical for demonstration purposes.</p>
</div>
</div>
<div id="simple-ipms-for-continuously-varying-environments" class="section level2">
<h2 class="hasAnchor">
<a href="#simple-ipms-for-continuously-varying-environments" class="anchor"></a>Simple IPMs for continuously varying environments</h2>
<p>In some cases, it is not desirable to work with single estimates of a random variable, and we prefer to work with the distributions they come from. Environmental variables like climate may be random with reasonably well known distributions. A stochastic simulation can incorporate information to help us understand the consequences of this random variability.</p>
<p>Unfortunately, this also means that we can’t obtain a set of kernels without iterating the model at least once, because we have to sample from the parameter distributions at least once. This is where the <code>*_stoch_param</code> methods come in handy. <code>*_stoch_param</code> methods are slightly less computationally efficient than their <code>*_stoch_kern*</code> counterparts because they must rebuild the iteration kernel for every single iteration. However, they are fantastic tools for exploring continuous variation.</p>
<p>Below is an example that demonstrates how to work with environmental variation. <code>ipmr</code> is careful to only evaluate each expression in <code><a href="../reference/define_impl.html">define_env_state()</a></code> once per iteration, so we can safely work with multivariate distributions using very little additional code. It is important to note that this not necessarily the same thing as incorporating parameter uncertainty into your model.</p>
<p>Equivalent code is demonstrated in the comments. The parameters for the growth and survival functions will be sampled from distributions for temperature and precipitation one time per iteration, and an example of a function to pass to <code><a href="../reference/define_impl.html">define_env_state()</a></code> is included in the first chunk below.</p>
<div id="defining-initial-conditions" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-initial-conditions" class="anchor"></a>Defining initial conditions</h3>
<p>Stochastic simulations require specification of the initial conditions. <code>ipmr</code> aims to make this straightforward for you by providing two helpers - <code><a href="../reference/define_impl.html">define_pop_state()</a></code> and <code><a href="../reference/define_impl.html">define_env_state()</a></code>.</p>
<div id="define_pop_state" class="section level4">
<h4 class="hasAnchor">
<a href="#define_pop_state" class="anchor"></a><code>define_pop_state()</code>
</h4>
<p>We were briefly introduced to <code><a href="../reference/define_impl.html">define_pop_state()</a></code> earlier. It takes either</p>
<ol style="list-style-type: decimal">
<li>
<p>a named set of expressions that, when evaluated, generate a population vector</p>
<ul>
<li>example: <code>define_pop_state(n_dbh = runif(100)</code>) for a model with 100 meshpoints.</li>
</ul>
</li>
</ol>
<p><strong>or</strong></p>
<ol start="2" style="list-style-type: decimal">
<li>
<p>a named list of pre-generated population vectors in the <code>pop_vectors</code> argument. This format is useful for programming with population vectors that are computed elsewhere.</p>
<ul>
<li>example: <code><a href="../reference/define_impl.html">define_pop_state(pop_vectors = list(n_dbh = init_dbh_vector))</a></code>, where <code>init_dbh_vector</code> is generated somewhere earlier in the script.</li>
</ul>
</li>
</ol>
<p>In <code><a href="../reference/define_impl.html">define_pop_state()</a></code>, populations should be defined as <code>n_&lt;insert_state_variable_here&gt;</code>. If this function is used in the IPM definition code, then 2 additional helper variables are generated: <code>n_stateVariable_t</code> and <code>n_stateVariable_t_1</code>. These can be used to reference the population states in vital rate and/or kernel expressions. They must be referenced in the <code>...</code> of <code><a href="../reference/define_kernel.html">define_k()</a></code> as well, because otherwise <code>ipmr</code> doesn’t know how to iterate the model.</p>
</div>
<div id="define_env_state" class="section level4">
<h4 class="hasAnchor">
<a href="#define_env_state" class="anchor"></a><code>define_env_state()</code>
</h4>
<p><code><a href="../reference/define_impl.html">define_env_state()</a></code> takes a named set of expressions in the <code>...</code> and then a data list, much like how <code><a href="../reference/define_kernel.html">define_kernel()</a></code>/<code><a href="../reference/define_kernel.html">define_k()</a></code> take them. The values created need to be in a list that has names corresponding to the parameter names in the vital rate expressions. In this example, they are called <code>s_int</code>, <code>s_slope</code>, <code>g_int</code>, <code>g_slope</code>, and <code>g_sd</code>. The <code>data_list</code> in this section should contain any variables used in the function we define (in this example, <code>posterior_distribs</code>). we can reference them in the vital rate expressions in each kernel definition as if they were in the <code>data_list</code> of <code>define_kernel/define_k()</code>.</p>
</div>
</div>
<div id="vital-rate-models" class="section level3">
<h3 class="hasAnchor">
<a href="#vital-rate-models" class="anchor"></a>Vital rate models</h3>
<p>The first chunk below initializes the parameters and functions that the model uses. It takes the place of the usual vital rate model fitting process.</p>
<p>This example uses models for survival and growth that include environmental covariates. To limit complexity, we won’t include an interaction term, but you are free to include as many as you want in your own models. We define a single function to sample the environmental distributions to illustrate how to use continuously varying parameter distributions in <code>ipmr</code>. This only uses two models and one function to limit the the complexity of the example - there is no upper limit on the number of parameters or functions you can use in your own models.</p>
<p>The vital rate functions are described here:</p>
<ol style="list-style-type: decimal">
<li>
<p>survival (<code>s</code>): a logistic regression.</p>
<ul>
<li>example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(survival ~ size_1 + temp + precip, data = my_surv_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>growth (<code>g</code>): a linear regression</p>
<ul>
<li>example model formula: <code>brm(size_2 ~ size_1 + temp + precip, data = my_grow_data)</code>
</li>
</ul>
</li>
<li>
<p>flower probability (<code>f_r</code>): A logistic regression.</p>
<ul>
<li>example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(repro ~ size_1, data = my_repro_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>seed production (<code>f_s</code>): a logistic regression.</p>
<ul>
<li>example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(flower_n ~ size_1, data = my_flower_data, family = poisson())</a></code>
</li>
</ul>
</li>
<li>
<p>recruit sizes (<code>f_d</code>): A normal distribution</p>
<ul>
<li>example code: mean (<code>f_d_mu</code>) <code><a href="https://rdrr.io/r/base/mean.html">mean(my_recruit_data$size_2, na.rm = TRUE)</a></code> and standard deviation (<code>f_d_sd</code>) <code><a href="https://rdrr.io/r/stats/sd.html">sd(my_recruit_data$size_2, na.rm = TRUE)</a></code>
</li>
</ul>
</li>
</ol>
<p>And the the parameter values are given here:</p>
<div class="sourceCode" id="cb20"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">ipmr</span>)

<span class="co"># Define the fixed parameters in a list. The temperature and precipitation</span>
<span class="co"># coefficients are defined as s_temp, s_precip, g_temp, and g_precip.</span>

<span class="kw">constant_params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
  s_int     = <span class="op">-</span><span class="fl">5</span>,
  s_slope   = <span class="fl">2.2</span>,
  s_precip  = <span class="fl">0.0002</span>,
  s_temp    = <span class="op">-</span><span class="fl">0.003</span>,
  g_int     = <span class="fl">0.2</span>,
  g_slope   = <span class="fl">1.01</span>,
  g_sd      = <span class="fl">1.2</span>,
  g_temp    = <span class="op">-</span><span class="fl">0.002</span>,
  g_precip  = <span class="fl">0.004</span>,
  f_r_int   = <span class="fl">0.3</span>,
  f_r_slope = <span class="fl">0.03</span>,
  f_s_int   = <span class="fl">0.4</span>,
  f_s_slope = <span class="fl">0.001</span>,
  f_d_mu    = <span class="fl">1.1</span>,
  f_d_sd    = <span class="fl">0.1</span>
)

<span class="co"># Now, we create a set of environmental covariates. In this example, we use</span>
<span class="co"># a normal distribution for temperature and a Gamma for precipitation. </span>

<span class="kw">env_params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
  temp_mu = <span class="fl">8.9</span>,
  temp_sd = <span class="fl">1.2</span>,
  precip_shape = <span class="fl">1000</span>,
  precip_rate  = <span class="fl">2</span>
)

<span class="co"># We define a wrapper function that samples from these distributions</span>

<span class="kw">sample_env</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">env_params</span>) {
  
  <span class="co"># We generate one value for each covariate per iteration, and return it </span>
  <span class="co"># as a named list. We can reference the names in this list in vital rate </span>
  <span class="co"># expressions.</span>
  
  <span class="kw">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">1</span>,
                <span class="kw">env_params</span><span class="op">$</span><span class="kw">temp_mu</span>, 
                <span class="kw">env_params</span><span class="op">$</span><span class="kw">temp_sd</span>)
  
  <span class="kw">precip</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span>(<span class="fl">1</span>, 
                   shape = <span class="kw">env_params</span><span class="op">$</span><span class="kw">precip_shape</span>,
                   rate = <span class="kw">env_params</span><span class="op">$</span><span class="kw">precip_rate</span>)
  
  <span class="kw">out</span>        <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(temp = <span class="kw">temp</span>, precip = <span class="kw">precip</span>)
  
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="kw">out</span>)
  
}


<span class="co"># Again, we can define our own functions and pass them into calls to make_ipm. This</span>
<span class="co"># isn't strictly necessary, but can make the model code more readable/less error prone.</span>

<span class="kw">inv_logit</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">lin_term</span>) {
  <span class="fl">1</span><span class="op">/</span>(<span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span><span class="kw">lin_term</span>))
}
</pre></div>
</div>
<div id="the-continuously-varying-ipm" class="section level3">
<h3 class="hasAnchor">
<a href="#the-continuously-varying-ipm" class="anchor"></a>The continuously varying IPM</h3>
<p>We now have parameter estimates. Time to build the IPM!</p>
<div class="sourceCode" id="cb21"><pre class="downlit">
<span class="kw">init_pop_vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">100</span>)

<span class="kw">param_resamp_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_stoch_param'</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name    = <span class="st">'P'</span>,
    formula = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    family  = <span class="st">'CC'</span>,
    
    <span class="co"># Parameters created by define_env_state() can be referenced by name just like</span>
    <span class="co"># any other parameter in the model.</span>
    
    g_mu    = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span> <span class="op">+</span> <span class="kw">g_temp</span> <span class="op">*</span> <span class="kw">temp</span> <span class="op">+</span> <span class="kw">g_precip</span> <span class="op">*</span> <span class="kw">precip</span>,
    s_lin_p = <span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span> <span class="op">+</span> <span class="kw">s_temp</span> <span class="op">*</span> <span class="kw">temp</span> <span class="op">+</span> <span class="kw">s_precip</span> <span class="op">*</span> <span class="kw">precip</span>,
    s       = <span class="fu">inv_logit</span>(<span class="kw">s_lin_p</span>),
    g       = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">surf_area_2</span>, <span class="kw">g_mu</span>, <span class="kw">g_sd</span>),
    
    
    data_list = <span class="kw">constant_params</span>,
    states    = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">'F'</span>,
    formula       = <span class="kw">f_r</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span>,
    family        = <span class="st">'CC'</span>,
    f_r_lin_p     = <span class="kw">f_r_int</span> <span class="op">+</span> <span class="kw">f_r_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span>,
    f_r           = <span class="fu">inv_logit</span>(<span class="kw">f_r_lin_p</span>),
    f_s           = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="kw">f_s_int</span> <span class="op">+</span> <span class="kw">f_s_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span>),
    f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">surf_area_2</span>, <span class="kw">f_d_mu</span>, <span class="kw">f_d_sd</span>),
    data_list     = <span class="kw">constant_params</span>,
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name = <span class="st">'K'</span>,
    
    <span class="co"># Note that here, we specify both the form of the iteration kernel and</span>
    <span class="co"># the iteration procedure. </span>
    
    K               = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
    n_surf_area_t_1 = <span class="kw">K</span> <span class="op">%*%</span> <span class="kw">n_surf_area_t</span>,
    family          = <span class="st">'IPM'</span>,
    data_list       = <span class="kw">constant_params</span>,
    states          = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs   = <span class="fl">FALSE</span>,
    evict_cor          = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>,<span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(surf_area = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">10</span>, <span class="fl">100</span>))
</pre></div>
<p>The continuously varying parameters and the expressions that generate them should be passed into <code><a href="../reference/define_impl.html">define_env_state()</a></code>. <code><a href="../reference/make_ipm.html">make_ipm()</a></code> will ensure that these are evaluated only once per iteration of the model, so that we can safely work with joint distributions that generate multiple parameter estimates per draw.</p>
<p>The <code>...</code> part of <code><a href="../reference/define_impl.html">define_env_state()</a></code> should be expressions that generate the variables we would like to reference. <code>temp</code> and <code>precip</code> are the names that will be generated by the IPM code, and so are the names that should be referenced in the kernels’ vital rate expressions, not <code>env_covs</code>. we don’t need to remember that we called this particular object <code>env_covs</code> when we write our vital rate expressions, but it does have to be named something for the IPM code to run.</p>
<p>The <code>data_list</code> contains the list of parameter values for the environmental covariates. In this example, the environmental variables don’t co-vary, but this is not a requirement. We could just as easily specify them as coming from a multivariate distribution, and modify our <code>env_sample</code> function accordingly.</p>
<div class="sourceCode" id="cb22"><pre class="downlit">
<span class="kw">param_resamp_model</span> <span class="op">&lt;-</span> <span class="kw">param_resamp_model</span> <span class="op">%&gt;%</span>
  
  <span class="fu"><a href="../reference/define_impl.html">define_env_state</a></span>(
    env_covs   = <span class="fu">sample_env</span>(<span class="kw">env_params</span>),
    data_list  = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(env_params = <span class="kw">env_params</span>,
                      sample_env = <span class="kw">sample_env</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_pop_state</a></span>(
    pop_vectors = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      n_surf_area_t = <span class="kw">init_pop_vec</span>
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(usr_funs   = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(inv_logit  = <span class="kw">inv_logit</span>),
           iterate    = <span class="fl">TRUE</span>,
           iterations = <span class="fl">10</span>)

<span class="co"># By default, lambda computes stochastic lambda with stochastic models </span>

<span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">param_resamp_model</span>)

<span class="co"># We can get lambdas for each time step by adding type_lambda = "all"</span>

<span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">param_resamp_model</span>, type_lambda = <span class="st">'all'</span>)

<span class="co"># If we want to see the actual draws that were used at each step of the </span>
<span class="co"># model iteration, we can access these using the output's $env_seq slot.</span>

<span class="kw">param_resamp_model</span><span class="op">$</span><span class="kw">env_seq</span>
</pre></div>
</div>
<div id="pre-determined-sequences-of-environmental-covariates" class="section level3">
<h3 class="hasAnchor">
<a href="#pre-determined-sequences-of-environmental-covariates" class="anchor"></a>Pre-determined sequences of environmental covariates</h3>
<p>In some cases, we might want to provide a sequence of environmental values ahead of time, as opposed to sampling them at each iteration. We can do this by re-writing the <code>sample_env</code> function so that it takes the current model iteration as a parameter that selects values from the pre-specified environmental values. <code>ipmr</code> defines the variable <code>t</code> internally, which we can reference in our expressions. First, we re-define the model:</p>
<div class="sourceCode" id="cb23"><pre class="downlit">
<span class="kw">param_resamp_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_stoch_param'</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name    = <span class="st">'P'</span>,
    formula = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    family  = <span class="st">'CC'</span>,
    
    <span class="co"># Parameters created by define_env_state() can be referenced by name just like</span>
    <span class="co"># any other parameter in the model.</span>
    
    g_mu    = <span class="kw">g_int</span> <span class="op">+</span> <span class="kw">g_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span> <span class="op">+</span> <span class="kw">g_temp</span> <span class="op">*</span> <span class="kw">temp</span> <span class="op">+</span> <span class="kw">g_precip</span> <span class="op">*</span> <span class="kw">precip</span>,
    s_lin_p = <span class="kw">s_int</span> <span class="op">+</span> <span class="kw">s_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span> <span class="op">+</span> <span class="kw">s_temp</span> <span class="op">*</span> <span class="kw">temp</span> <span class="op">+</span> <span class="kw">s_precip</span> <span class="op">*</span> <span class="kw">precip</span>,
    s       = <span class="fu">inv_logit</span>(<span class="kw">s_lin_p</span>),
    g       = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">surf_area_2</span>, <span class="kw">g_mu</span>, <span class="kw">g_sd</span>),
    
    
    data_list = <span class="kw">constant_params</span>,
    states    = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">'F'</span>,
    formula       = <span class="kw">f_r</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span>,
    family        = <span class="st">'CC'</span>,
    f_r_lin_p     = <span class="kw">f_r_int</span> <span class="op">+</span> <span class="kw">f_r_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span>,
    f_r           = <span class="fu">inv_logit</span>(<span class="kw">f_r_lin_p</span>),
    f_s           = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="kw">f_s_int</span> <span class="op">+</span> <span class="kw">f_s_slope</span> <span class="op">*</span> <span class="kw">surf_area_1</span>),
    f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">surf_area_2</span>, <span class="kw">f_d_mu</span>, <span class="kw">f_d_sd</span>),
    data_list     = <span class="kw">constant_params</span>,
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name = <span class="st">'K'</span>,
    
    <span class="co"># Note that here, we specify both the form of the iteration kernel and</span>
    <span class="co"># the iteration procedure. </span>
    
    K               = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
    n_surf_area_t_1 = <span class="kw">K</span> <span class="op">%*%</span> <span class="kw">n_surf_area_t</span>,
    family          = <span class="st">'IPM'</span>,
    data_list       = <span class="kw">constant_params</span>,
    states          = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    has_hier_effs   = <span class="fl">FALSE</span>,
    evict_cor          = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>,<span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(surf_area = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">10</span>, <span class="fl">100</span>))
</pre></div>
<p>Next, we generate some parameter values for <code>temp</code> and <code>precip</code>:</p>
<div class="sourceCode" id="cb24"><pre class="downlit">
<span class="kw">env_states</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(precip = <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span>(<span class="fl">10</span>, shape = <span class="fl">1000</span>, rate = <span class="fl">2</span>),
                         temp   = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">10</span>, mean = <span class="fl">8.9</span>, sd = <span class="fl">1.2</span>))
</pre></div>
<p>In this case, we are trying to sample these in a specific order - the 1st row first, the 2nd row second, 3rd row third, etc. Instead of writing a function that generates random draws from a distribution, we write one that samples rows from this data frame and creates a named list. <code>ipmr</code> generates a helper variable, <code>t</code>, that lets us access the current model iteration. Thus, our function to generate the environmental variables at each time step could look like this:</p>
<div class="sourceCode" id="cb25"><pre class="downlit">
<span class="kw">sample_env</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">env_states</span>, <span class="kw">iteration</span>) {
  
  <span class="kw">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="kw">env_states</span>[<span class="kw">iteration</span>, ])
  <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">out</span>) <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">env_states</span>)
  
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="kw">out</span>)
  
}
</pre></div>
<p>We can now <code><a href="../reference/define_impl.html">define_env_state()</a></code> and <code><a href="../reference/define_impl.html">define_pop_state()</a></code>:</p>
<div class="sourceCode" id="cb26"><pre class="downlit">
<span class="kw">param_resamp_model</span> <span class="op">&lt;-</span> <span class="kw">param_resamp_model</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_env_state</a></span>(env_params = <span class="fu">sample_env</span>(<span class="kw">env_states</span>, iteration = <span class="kw">t</span>),
                   data_list = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
                     env_states = <span class="kw">env_states</span>,
                     sample_env = <span class="kw">sample_env</span>
                   )) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_pop_state</a></span>(
    pop_vectors = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      n_surf_area_t = <span class="kw">init_pop_vec</span>
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(usr_funs   = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(inv_logit  = <span class="kw">inv_logit</span>),
           iterate    = <span class="fl">TRUE</span>,
           iterations = <span class="fl">10</span>)
</pre></div>
<p>Notice that we set <code>iteration = t</code> in the call to <code>sample_env</code>. Otherwise, everything else looks the same as before.</p>
</div>
</div>
<div id="uncertainty-in-simple-ipms" class="section level2">
<h2 class="hasAnchor">
<a href="#uncertainty-in-simple-ipms" class="anchor"></a>Uncertainty in simple IPMs</h2>
<p>Currently, <code>ipmr</code> doesn’t contain functions to deal with uncertainty. The goal is to change that soon. In the meantime, here is an example of how to deal with that in the context of a simple, deterministic IPM. The procedure is similar for kernel- and parameter-resampled models, and can be adapted to suit those as needed.</p>
<p>There are a multitude of ways to incorporate uncertainty and other sources of continuous variation into regression models and IPMs, and that variety is beyond the scope of this vignette. The following resources are excellent introductions to both and themselves contain a multitude of further readings:</p>
<ol style="list-style-type: decimal">
<li><p><a href="https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#introduction">wiki for GLMMs</a></p></li>
<li><p><a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12405">Metcalf et al 2015</a>.</p></li>
</ol>
<p>For the purpose of this example, we’ll use the iceplant data set and do a bootstrapping procedure on the raw data. At each iteration of the bootstrap, we’ll re-run the regression models, and then re-build the IPM. We’ll store the lambda values for each one, and then repeat the procedure 1000 times.</p>
<p>First, we construct our vital rate models and IPM from the observed data.</p>
<div class="sourceCode" id="cb27"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">ipmr</span>)

<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="kw">iceplant_ex</span>)

<span class="kw">grow_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span>(<span class="kw">log_size_next</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>)
<span class="kw">grow_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/residuals.html">resid</a></span>(<span class="kw">grow_mod</span>))

<span class="kw">surv_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">survival</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())
<span class="kw">repr_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">repro</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())
<span class="kw">seed_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">flower_n</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">iceplant_ex</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">poisson</a></span>())
<span class="kw">recr_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html">subset</a></span>(<span class="kw">iceplant_ex</span>, <span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">log_size</span>))

<span class="kw">recr_mu</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
<span class="kw">recr_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
<span class="kw">recr_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
<span class="kw">flow_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">flower_n</span>, na.rm = <span class="fl">TRUE</span>)

<span class="kw">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(recr_mu = <span class="kw">recr_mu</span>,
               recr_sd = <span class="kw">recr_sd</span>,
               grow_sd = <span class="kw">grow_sd</span>,
               surv_mod = <span class="kw">surv_mod</span>,
               grow_mod = <span class="kw">grow_mod</span>,
               repr_mod = <span class="kw">repr_mod</span>,
               seed_mod = <span class="kw">seed_mod</span>,
               recr_n   = <span class="kw">recr_n</span>,
               flow_n   = <span class="kw">flow_n</span>)

<span class="kw">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">0.8</span>
<span class="kw">U</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">1.2</span>

<span class="kw">obs_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">"simple_di_det"</span>) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"P"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
    
    <span class="co"># Instead of the inverse logit transformation, we use predict() here.</span>
    <span class="co"># We have to be sure that the "newdata" argument of predict is correctly specified.</span>
    <span class="co"># This means matching the names used in the model itself (log_size) to the names</span>
    <span class="co"># we give the domains. In this case, we use "sa" (short for surface area) as</span>
    <span class="co"># the new data to generate predictions for.</span>
    
    s             = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">surv_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type    = <span class="st">'response'</span>),
    g_mu          = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">grow_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type    = <span class="st">'response'</span>),
    
    <span class="co"># We specify the rest of the kernel the same way.</span>
    
    g             = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">g_mu</span>, <span class="kw">grow_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>, 
                                            param = <span class="st">"g"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
    name          = <span class="st">"F"</span>,
    family        = <span class="st">"CC"</span>,
    formula       = <span class="kw">f_p</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span> <span class="op">*</span> <span class="kw">f_r</span>,
    
    <span class="co"># As above, we use predict(model_object). We make sure the names of the "newdata"</span>
    <span class="co"># match the names in the vital rate model formulas, and the values match the </span>
    <span class="co"># names of domains they use.</span>
    
    f_p           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">repr_mod</span>,
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                            type    = <span class="st">'response'</span>),
    f_s           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">seed_mod</span>, 
                            newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                            type    = <span class="st">'response'</span>),
    f_r           = <span class="kw">recr_n</span> <span class="op">/</span> <span class="kw">flow_n</span>,
    f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">recr_mu</span>, <span class="kw">recr_sd</span>),
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="kw">params</span>,
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">TRUE</span>,
    evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>,
                                            param = <span class="st">"f_d"</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
    name          = <span class="st">"K"</span>,
    family        = <span class="st">"IPM"</span>,
    K             = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
    states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
    data_list     = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    has_hier_effs = <span class="fl">FALSE</span>,
    evict_cor     = <span class="fl">FALSE</span>
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
      kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>),
      dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>)
    )
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(
    sa = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">L</span>,
           <span class="kw">U</span>,
           <span class="fl">100</span>)
  ) <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(iterate = <span class="fl">FALSE</span>)

<span class="kw">lambda_obs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">obs_ipm</span>, comp_method = <span class="st">'eigen'</span>)
</pre></div>
<p>Next, we’ll initialize a vector to hold the lambdas at each timestep. We’re also going to split out the new recruits from the other data. We only have 12, and the model building won’t work if we happen to not pull any of them out when we resample the data.</p>
<div class="sourceCode" id="cb28"><pre class="downlit">
<span class="kw">all_lambdas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span>(<span class="fl">1000L</span>)

<span class="kw">recr_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html">subset</a></span>(<span class="kw">iceplant_ex</span>, <span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">log_size</span>))

<span class="kw">adults</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html">subset</a></span>(<span class="kw">iceplant_ex</span>, <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">log_size</span>))
</pre></div>
<p>Now, we wrap the whole modelling chunk from above in a for loop, and refit the model, storing the results at every iteration.</p>
<div class="sourceCode" id="cb29"><pre class="downlit">
<span class="co">for</span>(<span class="kw">i</span> <span class="co">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">1000</span>) {

  <span class="kw">sample_ind</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="kw">adults</span>), by = <span class="fl">1</span>)
  
  <span class="kw">boot_ind</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="kw">sample_ind</span>, size = <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="kw">adults</span>), replace = <span class="fl">TRUE</span>)
  
  <span class="kw">boot_data</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(<span class="kw">adults</span>[<span class="kw">boot_ind</span>, ],
                      <span class="kw">recr_data</span>)
  
  <span class="kw">grow_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span>(<span class="kw">log_size_next</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">boot_data</span>)
  <span class="kw">grow_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/residuals.html">resid</a></span>(<span class="kw">grow_mod</span>))
  
  <span class="kw">surv_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">survival</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">boot_data</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())
  <span class="kw">repr_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">repro</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">boot_data</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span>())
  <span class="kw">seed_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span>(<span class="kw">flower_n</span> <span class="op">~</span> <span class="kw">log_size</span>, data = <span class="kw">boot_data</span>, family = <span class="fu"><a href="https://rdrr.io/r/stats/family.html">poisson</a></span>())

  <span class="kw">recr_mu</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
  <span class="kw">recr_sd</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
  <span class="kw">recr_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="kw">recr_data</span><span class="op">$</span><span class="kw">log_size_next</span>)
  <span class="kw">flow_n</span>   <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="kw">boot_data</span><span class="op">$</span><span class="kw">flower_n</span>, na.rm = <span class="fl">TRUE</span>)
  
  <span class="kw">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(recr_mu = <span class="kw">recr_mu</span>,
                 recr_sd = <span class="kw">recr_sd</span>,
                 grow_sd = <span class="kw">grow_sd</span>,
                 surv_mod = <span class="kw">surv_mod</span>,
                 grow_mod = <span class="kw">grow_mod</span>,
                 repr_mod = <span class="kw">repr_mod</span>,
                 seed_mod = <span class="kw">seed_mod</span>,
                 recr_n   = <span class="kw">recr_n</span>,
                 flow_n   = <span class="kw">flow_n</span>)
  
  <span class="co"># Keep the same limits for integration</span>
  
  <span class="kw">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">0.8</span>
  <span class="kw">U</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size</span>, <span class="kw">iceplant_ex</span><span class="op">$</span><span class="kw">log_size_next</span>), na.rm = <span class="fl">TRUE</span>) <span class="op">*</span> <span class="fl">1.2</span>
  
  <span class="kw">boot_ipm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">"simple_di_det"</span>) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
      name          = <span class="st">"P"</span>,
      family        = <span class="st">"CC"</span>,
      formula       = <span class="kw">s</span> <span class="op">*</span> <span class="kw">g</span>,
      s             = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">surv_mod</span>, 
                              newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                              type    = <span class="st">'response'</span>),
      g_mu          = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">grow_mod</span>, 
                              newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                              type    = <span class="st">'response'</span>),
      
      <span class="co"># We specify the rest of the kernel the same way.</span>
      
      g             = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">g_mu</span>, <span class="kw">grow_sd</span>),
      states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
      data_list     = <span class="kw">params</span>,
      has_hier_effs = <span class="fl">FALSE</span>,
      evict_cor     = <span class="fl">TRUE</span>,
      evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>, 
                                              param = <span class="st">"g"</span>)
    ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_kernel.html">define_kernel</a></span>(
      name          = <span class="st">"F"</span>,
      family        = <span class="st">"CC"</span>,
      formula       = <span class="kw">f_p</span> <span class="op">*</span> <span class="kw">f_s</span> <span class="op">*</span> <span class="kw">f_d</span> <span class="op">*</span> <span class="kw">f_r</span>,
      
      <span class="co"># As above, we use predict(model_object). We make sure the names of the "newdata"</span>
      <span class="co"># match the names in the vital rate model formulas, and the values match the </span>
      <span class="co"># names of domains they use.</span>
      
      f_p           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">repr_mod</span>,
                              newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>),
                              type    = <span class="st">'response'</span>),
      f_s           = <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span>(<span class="kw">seed_mod</span>, 
                              newdata = <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(log_size = <span class="kw">sa_1</span>), 
                              type    = <span class="st">'response'</span>),
      f_r           = <span class="kw">recr_n</span> <span class="op">/</span> <span class="kw">flow_n</span>,
      f_d           = <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="kw">sa_2</span>, <span class="kw">recr_mu</span>, <span class="kw">recr_sd</span>),
      states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
      data_list     = <span class="kw">params</span>,
      has_hier_effs = <span class="fl">FALSE</span>,
      evict_cor     = <span class="fl">TRUE</span>,
      evict_fun     = <span class="fu"><a href="../reference/truncated_distributions.html">truncated_distributions</a></span>(fun   = <span class="st">"norm"</span>,
                                              param = <span class="st">"f_d"</span>)
    ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_kernel.html">define_k</a></span>(
      name          = <span class="st">"K"</span>,
      family        = <span class="st">"IPM"</span>,
      K             = <span class="kw">P</span> <span class="op">+</span> <span class="kw">F</span>,
      states        = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"sa"</span>)),
      data_list     = <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
      has_hier_effs = <span class="fl">FALSE</span>,
      evict_cor     = <span class="fl">FALSE</span>
    ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_impl.html">define_impl</a></span>(
      <span class="fu"><a href="../reference/define_impl.html">make_impl_args_list</a></span>(
        kernel_names = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
        int_rule     = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
        dom_start    = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>),
        dom_end      = <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"sa"</span>, <span class="fl">3</span>)
      )
    ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/define_impl.html">define_domains</a></span>(
      sa = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="kw">L</span>,
             <span class="kw">U</span>,
             <span class="fl">100</span>)
    ) <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(iterate = <span class="fl">FALSE</span>)
  
  <span class="kw">all_lambdas</span>[<span class="kw">i</span>] <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="kw">boot_ipm</span>, comp_method = <span class="st">'eigen'</span>)
  
}

<span class="co"># Plot the results</span>

<span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span>(<span class="kw">all_lambdas</span>)
<span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span>(v = <span class="kw">lambda_obs</span>, col = <span class="st">'red'</span>, lwd = <span class="fl">2</span>, lty = <span class="fl">2</span>)
</pre></div>
<p>You can adapt this code to store any quantity of interest (e.g. regression coefficients, population structures).</p>
</div>
<div id="general-ipms" class="section level2">
<h2 class="hasAnchor">
<a href="#general-ipms" class="anchor"></a>General IPMs</h2>
<p>An article on these is available on the <a href="https://levisc8.github.io/ipmr/articles/general-ipms.html">website</a> and from an R session:</p>
<div class="sourceCode" id="cb30"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/utils/browseVignettes.html">browseVignettes</a></span>(<span class="st">"ipmr"</span>)
</pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by <a href="https://github.com/levisc8">Sam Levin</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
