<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to ipmr • ipmr</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to ipmr">
<meta property="og:description" content="ipmr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">ipmr</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="Unreleased version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="divider">
    <li class="dropdown-header">Introduction to ipmr</li>
    <li>
      <a href="../articles/ipmr-introduction.html">Introduction to ipmr</a>
    </li>
    <li>
      <a href="../articles/general-ipms.html">General IPMs</a>
    </li>
    <li>
      <a href="../articles/hierarchical-notation.html">Hierarchical Notation</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">Generic Functions</li>
    <li>
      <a href="../articles/generic-funs.html">List of Generic and Helper Functions in ipmr</a>
    </li>
    <li>
      <a href="../articles/generic-progress.html">Generic Progress</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">proto_ipm Overview</li>
    <li>
      <a href="../articles/proto-ipms.html">proto_ipm data structure</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">ipmr Checks</li>
    <li>
      <a href="../articles/sanity-checks.html">Sanity checks for ipmr examples</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Introduction to ipmr</h1>
            
      
      
      <div class="hidden name"><code>ipmr-introduction.Rmd</code></div>

    </div>

    
    
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p><code>ipmr</code> is a package for implementing integral projection models of varying degrees of complexity. It uses mathematical-ish expressions to build up the iteration kernels from smaller pieces, as well as helpers to ensure that models are implemented correctly. Finally, it provides machinery for stochastic simulations. basic analyses, and model diagnostics. More complicated analysis functions are being implemented in the <a href="https://github.com/levisc8/irage">irage package</a>.</p>
<p><strong>This package does not help with fitting regression models to demographic data!</strong> This is a distinct enough problem that it should not be in the purview of this package - and there are much better tools out there already that can do a much better job of helping you with that than I can. Some of my favorites are <code>lme4</code>, <code>brms</code>, <code>mgcv</code>, and <code>nlme</code>. <code>IPMpack</code> handles the regression modelling and IPM construction, though be forewarned, there are certain types of models that you simply cannot construct with it!</p>
</div>
<div id="types-of-models-in-ipmr" class="section level2">
<h2 class="hasAnchor">
<a href="#types-of-models-in-ipmr" class="anchor"></a>Types of models in <code>ipmr</code>
</h2>
<p>The first step of defining a model in <code>ipmr</code> is to initialize the model using <code><a href="../reference/init_ipm.html">init_ipm()</a></code>. This function takes a single argument: <code>model_class</code>. The <code>model_class</code> defines the basic infrastructure that will be available for subsequent analyses and helps make sure the kernels are correctly implemented from the underlying vital rates. <code>model_class</code> should be a character string with at least 3 (but possibly 4) entries separated by underscores (<code>_</code>). Below, the are the possible entries for each position.</p>
<ul>
<li>
<p>Position 1: <code>"simple"</code>/<code>"general"</code></p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li>
<strong>simple</strong>: This describes an IPM with a single continuous state variable and no discrete stages.</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li>
<strong>general</strong>: This describes and IPM with either more than one continuous state variable, one or more discrete stages, or both of the above. Basically, anything other than an IPM with a single continuous state variable.</li>
</ol></li>
</ul>
</li>
<li>
<p>Position 2: <code>"di"</code>/<code>"dd"</code></p>
<ul>
<li><p>A. <strong>di</strong>: This is used to denote a density-independent IPM.</p></li>
<li><p>B. <strong>dd</strong>: This is used to denote a density-dependent IPM.</p></li>
</ul>
</li>
<li>
<p>Position 3: <code>"det"</code>/<code>"stoch"</code></p>
<ul>
<li><p>A. <strong>det</strong>: This is used to denote a deterministic IPM. If this is used in the third position of <code>model_class</code>, there should not be a fourth entry.</p></li>
<li><p>B. <strong>stoch</strong>: This is used to denote a stochastic IPM. If this is used in the third position of <code>model_class</code>, there should always be a fourth entry. The two possibilities for the fourth are described next.</p></li>
</ul>
</li>
<li>
<p>Position 4: <code>"kern"</code>/<code>"param"</code></p>
<ul>
<li><p>A. <strong>kern</strong>: This describes an IPM with discretely varying parameters such that their values are known before the model is specified. This is usually the case with models that estimate random year/site effects and for which defining a multivariate joint distribution to sample parameters from is not desirable/needed. These models can be a bit more computationally efficient than the <code>param</code> alternative because all kernels can be constructed before the iteration procedure begins, as opposed to requiring reconstruction for every single iteration.</p></li>
<li><p>B. <strong>param</strong>: This describes an IPM with parameters that are re-sampled from some distribution at each iteration of the model (usually a multivariate joint distribution). This can be a multivariate normal defined by covarying slopes and intercepts, or posterior distribution from a Bayesian model. All that is required is that the parameters for the distribution are specified and that the function that generates the parameters at each iteration returns named lists that correspond to the parameter names in the model. Jump down to the <code>"simple_di_stoch_param"</code> example for some inspiration in writing those.</p></li>
</ul>
</li>
</ul>
<p>With the type of model selected, the <code>model_class</code> becomes a string and the call to <code>init_ipm</code> is composed like so: <code><a href="../reference/init_ipm.html">init_ipm(model_class = "position1_position_2_position3_position4")</a></code>.</p>
<p>The rest of this vignette will deal with simple, density independent IPMs. If you already know that you need a general IPM (i.e. an IPM with discrete stages and/or multiple continuous state variables), I still strongly recommend reading at least one complete example here before you start with <a href="https://levisc8.github.io/ipmr/articles/general-ipms.html">those</a>.</p>
</div>
<div id="specifying-a-simple-deterministic-ipm-without-density-dependence" class="section level2">
<h2 class="hasAnchor">
<a href="#specifying-a-simple-deterministic-ipm-without-density-dependence" class="anchor"></a>Specifying a simple deterministic IPM without density dependence</h2>
<p>This is the simplest model that <code>ipmr</code> works with. It is an IPM with a single continuous state variable, no density dependent functions, and parameters that define a single iteration kernel (as opposed to many iteration kernels). We’ll walk through the steps required to implement such an IPM before getting into more complex models.</p>
<p>The vital rate functions and code that might be used to generate models corresponding to them are below.</p>
<ol style="list-style-type: decimal">
<li>
<p>Survival (<code>s</code>): a generalized linear model w/ a logit link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(surv ~ size_1, data = my_surv_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>Growth (<code>g</code>): a linear model with a Normal error distribution.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/lm.html">lm(size_2 ~ size_1, data = my_grow_data)</a></code>
</li>
</ul>
</li>
<li>
<p>Pr(flowering) (<code>f_r</code>): a generalized linear model w/ a logit link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(flower ~ size_1, data = my_repro_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>Seed production (<code>f_s</code>): a generalized linear model w/ log link.</p>
<ul>
<li>Example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(seeds ~ size_1, data = my_flower_data, family = poisson())</a></code>
</li>
</ul>
</li>
<li>
<p>Recruit size distribution (<code>f_d</code>): a normal distribution w parameters <code>mu_fd</code> (mean) and <code>sd_fd</code> (standard deviation).</p>
<ul>
<li>Example code: <code>mu_fd = mean(my_recr_data$size_2, na.rm = TRUE)</code> and <code>sd_fd = sd(my_recr_data$size_2, na.rm = TRUE)</code>
</li>
</ul>
</li>
</ol>
<div id="defining-kernels" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-kernels" class="anchor"></a>Defining kernels</h3>
<p>The first step is to decide what class of model we want to implement. We have one continuous state variable and no spatial or temporal variation to deal with, and we aren’t going to deal with uncertainty (for now). Thus, we have a simple, density independent, deterministic IPM. We initialize it with <code><a href="../reference/init_ipm.html">init_ipm()</a></code>.</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>)</pre></body></html></div>
<p>The next step is to define the actual kernels comprising the IPM. These are defined individually with calls to <code><a href="../reference/kernel-definitions.html">define_kernel()</a></code>.</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
  <span class="kw">proto_ipm</span> <span class="kw">=</span> <span class="no">my_ipm</span>,
  <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,

  <span class="co"># The formula describes how the vital rates generate the kernel</span>

  <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,

  <span class="co"># The family describes the type of transition that kernel produces. See below.</span>

  <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,

  <span class="co"># Perform the inverse logit transformation to get the probability of survival</span>
  <span class="co"># from coefficients of the GLM</span>

  <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),

  <span class="co"># Growth has two terms with 3 parameters - the mean and the standard deviation.</span>
  <span class="co"># We model the mean as a function of size with an intercept and slope. </span>
  <span class="co"># The standard deviation is a constant.</span>

  <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
  <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

  <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
    <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,   <span class="co"># coef(my_surv_mod)[1]</span>
    <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,   <span class="co"># coef(my_surv_mod)[2]</span>
    <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,   <span class="co"># coef(my_grow_mod)[1]</span>
    <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>, <span class="co"># coef(my_grow_mod)[2]</span>
    <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>    <span class="co"># sd(resid(my_grow_mod))</span>
  ),

  <span class="co"># states should be a list of the state variables that the kernel operates on</span>

  <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
  <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
  <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
  <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
)</pre></body></html></div>
<p>This function takes the kernel <code>name</code>, the mathematical <code>formula</code> for the kernel, and expressions for the vital rates that comprise it (<code>s</code>, <code>g</code>, <code>g_mu</code>).</p>
<p>The <code>family</code> argument refers to the type of transition that the kernel describes and has 5 options:</p>
<ol style="list-style-type: decimal">
<li><p>“CC” - a continuous -&gt; continuous transition</p></li>
<li><p>“CD” - a continuous -&gt; discrete transition</p></li>
<li><p>“DC” - a discrete -&gt; continuous transition</p></li>
<li><p>“DD” - a discrete -&gt; discrete transition</p></li>
<li><p>“IPM” - This is reserved for the <code><a href="../reference/kernel-definitions.html">define_k()</a></code> function introduced below.</p></li>
</ol>
<p>These aren’t important for <code>simple_*</code> IPMs, as all transitions are from a continuous state to a continuous state, but they are required for <code>general_*</code> IPMs to build properly. As such, they are required to be specified for <em>all</em> kernels.</p>
<p>In addition, the <code>data_list</code> argument holds the constant parameters (e.g. regression coefficient estimates).</p>
<p>The <code>states</code> argument refers to the state variables in use. <code>ipmr</code> internally appends an <code>_1</code> and <code>_2</code> to the names in <code>states</code>, and creates variables for them that are the meshpoints for integration. These correspond to time <em>t</em> and <em>t+1</em>, and can be used in vital rate expressions to indicate which state at which time is being acted upon.</p>
<p><code>has_hier_effs</code> is a logical indicating whether or not the model contains hierarchical effects. In this example, the model is a simple, deterministic one and so this is set to <code>FALSE</code>. However, <code>*_stoch_kern</code> kernels will almost always need this to be set to <code>TRUE</code>, and <code>*_stoch_param</code> models can also use them. See the next example for a demonstration of that syntax (there is also a vignette with additional worked examples <a href="https://levisc8.github.io/ipmr/articles/hierarchical-notation.html">here</a>).</p>
<p><code>evict_cor</code> refers to whether or not to correct for eviction in the kernel. If this is set to <code>TRUE</code>, then you must supply a function specifying which expressions need to be corrected and the correction to apply. <code>ipmr</code> provides <code>truncated_distributions</code> for now, though others will eventually be implemented as well. Subsequent additions are mainly to accomadate models in PADRINO, and I very strongly suggest sticking to <code>truncated_distributions</code> for your own models.</p>
<p>Finally, <code>ipmr</code> is designed to be <a href="https://magrittr.tidyverse.org/">pipe-friendly</a>. All functions prefixed with <code>define_*</code> take a <code>proto_ipm</code> as their first argument and always return a <code>proto_ipm</code>, meaning operations can be chained together with the <code><a href="../reference/pipe.html">%&gt;%</a></code> operator. This function is included in <code>ipmr</code>, so there is no need to load any other packages to access it (e.g. <code>dplyr</code> or <code>magrittr</code>). The first chunk below is equivalent to the two chunks above.</p>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="co"># the %&gt;% takes the result of the first operation and passes it as the first</span>
<span class="co"># argument to the second function.</span>

<span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span>  <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,
      <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>,
      <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  )

<span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
  <span class="kw">proto_ipm</span> <span class="kw">=</span> <span class="no">my_ipm</span>,
  <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"F"</span>,
  <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
  <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,

  <span class="co"># Again, we use the inverse logit transformation to compute pr(flowering)</span>
  <span class="kw">f_r</span>       <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">f_r_int</span> + <span class="no">f_r_slope</span> * <span class="no">dbh_1</span>))),

  <span class="co"># We exponentiate this because of the log link in our seed production model</span>
  <span class="kw">f_s</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">dbh_1</span>),

  <span class="co"># In this case, both the mean and standard deviation are constants</span>
  <span class="kw">f_d</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
  <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
    <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.5</span>,   <span class="co"># coef(my_flower_mod)[1]</span>
    <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.1</span>,   <span class="co"># coef(my_flower_mod)[2]</span>
    <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">1.2</span>,   <span class="co"># coef(my_seed_mod)[1]</span>
    <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,  <span class="co"># coef(my_seed_mod)[2]</span>
    <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.2</span>,   <span class="co"># mean(my_recr_data$size_2, na.rm = TRUE)</span>
    <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.7</span>    <span class="co"># sd(my_recr_data$size_2, na.rm = TRUE)</span>
  ),
  <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
  <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
  <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
  <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
)</pre></body></html></div>
<p>The <code>F</code> kernel has the same form as the <code>P</code> kernel. We are now ready to define the <code>K</code> kernel, sometimes referred to as the iteration kernel.</p>
</div>
<div id="defining-an-iteration-kernel" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-an-iteration-kernel" class="anchor"></a>Defining an iteration kernel</h3>
<p>These kernels are treated slightly differently in <code>ipmr</code>. They are defined with their own function, <code><a href="../reference/kernel-definitions.html">define_k()</a></code>. It has fewer arguments than <code>define_kernel</code>.</p>
<p>The rest of the model definition sequence in this example will use the <code><a href="../reference/pipe.html">%&gt;%</a></code> operator. <em>It is not a requirement</em> - you can assign a value to <code>my_ipm</code> at each step and the model will be identical. Choose which ever process is more comfortable for you!</p>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,
      <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>,
      <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"F"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">f_r</span>       <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">f_r_int</span> + <span class="no">f_r_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">f_s</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">dbh_1</span>),
    <span class="kw">f_d</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,
      <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.7</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>          <span class="kw">=</span> <span class="st">"K"</span>,
    <span class="kw">family</span>        <span class="kw">=</span> <span class="st">"IPM"</span>,
    <span class="kw">K</span>             <span class="kw">=</span> <span class="no">P</span> + <span class="no">F</span>,           <span class="co"># define_k uses ... instead of formula = P + F</span>
    <span class="kw">data_list</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">FALSE</span>
  )</pre></body></html></div>
<p>The <code>name</code> argument of <code>define_k</code> should always be one of <code>K</code>, <code>k</code>, or <code>K_suffix</code>, where <code>suffix</code> corresponds to a hierarchical effect (more on those in the discretely varying environments section). The <code>...</code> take over the role that <code>formula</code> took in the previous kernels. This is to facilitate passing multiple expressions for the iteration kernel when defining more complex models (i.e. how the population state changes with time or an age x size model). In this example, the left hand side of the expression should match the <code>name</code> because we aren’t actually iterating this kernel with a population vector. Note that there are no additional parameters that need to be passed to complete the construction of the kernel, so <code>data_list</code> can be empty. It never hurts to pass the same <code>data_list</code> containing all of the parameters to each call to <code><a href="../reference/kernel-definitions.html">define_k()</a></code>/<code><a href="../reference/kernel-definitions.html">define_kernel()</a></code> though - if the parameter aren’t used in a given kernel’s definition, they are simply ignored. Finally, we specify <code>evict_cor = FALSE</code> in the <code>K</code> because we’ve already corrected for it in the previous kernel definitions.</p>
</div>
<div id="defining-the-implementation-arguments-impl_args" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-the-implementation-arguments-impl_args" class="anchor"></a>Defining the implementation arguments (<code>impl_args</code>)</h3>
<p>Next, we need to define how the kernels are implemented numerically. This is where we define the integration rule <code>int_rule</code>, the domain the kernels begin on <code>dom_start</code>, and the domain that they finish on <code>dom_end</code>. This is done with the <code><a href="../reference/define_star.html">define_impl()</a></code> function. It takes a named list where names correspond to the kernels, and each entry is itself a list of length 3 containing slots <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code>. Because this is a bit specific, there is a helper function that can be called within <code>define_impl</code> or called before initializing the IPM to make sure everything is formatted correctly - <code>make_ipml_args_list()</code>.</p>
<p>The first argument to the <code>make_ipml_args_list()</code> function is <code>kernel_names</code>. This is a character vector with kernel names for which the implementation arguments are being supplied.</p>
<p>Next, <code>int_rule</code> is a character vector, and currently <code>'midpoint'</code> is the only option that is implemented. <code>'trapezoid'</code> and <code>'g-l'</code> (Gauss-Legendre) are on the to-do list. Additional rules may be added if there is more demand for certain ones (e.g. cumulative density functions like in <code>IPMpack</code>).</p>
<p><code>dom_start</code> and <code>dom_end</code> are always the same in <code>simple_*</code> IPMs. In <code>general_*</code> ones, they may be different, or, if describing a transition involving a discrete state, they may be <code>NA</code>. For all non-<code>NA</code> <code>dom_*</code>’s, they are one of the variables in the <code>states</code> list. <code>dom_start</code>’s have <code>_1</code> and <code>dom_end</code>’s have <code>_2</code> appended to them internally, so they may be referenced by vital rate functions without explicitly creating a variable for them.</p>
<p>Elements of each vector in each argument in <code><a href="../reference/define_star.html">make_impl_args_list()</a></code> are matched by position. Thus, if you specify <code>"K"</code> as the first entry in <code>kernel_names</code>, then the first entries of <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code> should all correspond to the <code>K</code> kernel. If you specify <code>"P"</code> as the second entry, the second entries in <code>int_rule</code>, <code>dom_start</code>, and <code>dom_end</code> should be the rules that correspond to the <code>P</code> kernel, and so on.</p>
<p>It is important to note that <code>make_impl_args_list</code> <em>does not return a <code>proto_ipm</code></em>. Thus, it must either be called before beginning the model definition, or inside of <code>define_impl</code>!</p>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="co"># Alternative one - call make_impl_args_list() before beginning the IPM creation pipe</span>

<span class="no">impl_args</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
  <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
  <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
  <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
  <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>)
)

<span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,
      <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>,
      <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"F"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">f_r</span>       <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">f_r_int</span> + <span class="no">f_r_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">f_s</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">dbh_1</span>),
    <span class="kw">f_d</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,
      <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.7</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>          <span class="kw">=</span> <span class="st">"K"</span>,
    <span class="kw">family</span>        <span class="kw">=</span> <span class="st">"IPM"</span>,
    <span class="kw">K</span>             <span class="kw">=</span> <span class="no">P</span> + <span class="no">F</span>,
    <span class="kw">data_list</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">FALSE</span>
  )  <span class="kw">%&gt;%</span>
  <span class="co"># Alternative 2, put the call to make_impl_args_list() inside of define_impl(). </span>
  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>,<span class="fl">3</span>)
    )
  )</pre></body></html></div>
</div>
<div id="defining-domains-for-state-variables" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-domains-for-state-variables" class="anchor"></a>Defining domains for state variables</h3>
<p>The final essential step in creating an IPM with <code>ipmr</code> is to define the domain of each state variable in the <code>states</code> list. This is done with the <code><a href="../reference/define_star.html">define_domains()</a></code> function. When the <code>int_rule</code> is <code>"midpoint"</code>, this takes a named set of vectors that have 3 entries each. The name corresponds to the <code>state</code> it is describing, the first entry is the lower bound, the second the upper bound, and the third is the number of meshpoints.</p>
<p>Note that for other <code>int_rule</code>s, the vectors associated with each domain will look different. However, those are not yet implemented and so beyond the scope of this vignette for now.</p>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="co"># Alternative one - call make_impl_args_list() before beginning the IPM creation pipe</span>

<span class="no">impl_args</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
  <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
  <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
  <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
  <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>)
)

<span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,
      <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>,
      <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"F"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">f_r</span>       <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">f_r_int</span> + <span class="no">f_r_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">f_s</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">dbh_1</span>),
    <span class="kw">f_d</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,
      <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.7</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>          <span class="kw">=</span> <span class="st">"K"</span>,
    <span class="kw">family</span>        <span class="kw">=</span> <span class="st">"IPM"</span>,
    <span class="kw">K</span>             <span class="kw">=</span> <span class="no">P</span> + <span class="no">F</span>,
    <span class="kw">data_list</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">FALSE</span>
  )  <span class="kw">%&gt;%</span>
  <span class="co"># Alternative 2, put the call to make_impl_args_list() inside of define_impl(). </span>
  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>,<span class="fl">3</span>)
    )
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_domains</a></span>(
    <span class="kw">dbh</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(        <span class="co"># the name of the state variable</span>
      <span class="fl">1</span>,            <span class="co"># the lower bound for the domain</span>
      <span class="fl">30</span>,           <span class="co"># the upper bound for the domain</span>
      <span class="fl">200</span>           <span class="co"># the number of mesh points to use for integration</span>
    )
  )</pre></body></html></div>
</div>
</div>
<div id="implement-the-ipm" class="section level2">
<h2 class="hasAnchor">
<a href="#implement-the-ipm" class="anchor"></a>Implement the IPM</h2>
<p>The minimal set of information to generate a single deterministic kernel is now wrapped up in our <code>proto_ipm</code> and it is time to <code><a href="../reference/make_ipm.html">make_ipm()</a></code>! <code><a href="../reference/make_ipm.html">make_ipm()</a></code> is a generic function and will work with any combination of <code>model_class</code>es that are listed as “<strong>Completed and ready</strong>” <a href="https://levisc8.github.io/ipmr">here</a>.</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_det'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"P"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,

    <span class="kw">s</span>         <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">s_int</span> + <span class="no">s_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">dbh_1</span>,

    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">0.2</span>,
      <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">1.033</span>,
      <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fl">2.2</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>      <span class="kw">=</span> <span class="st">"F"</span>,
    <span class="kw">formula</span>   <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>    <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">f_r</span>       <span class="kw">=</span> <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">f_r_int</span> + <span class="no">f_r_slope</span> * <span class="no">dbh_1</span>))),
    <span class="kw">f_s</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">dbh_1</span>),
    <span class="kw">f_d</span>       <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">dbh_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
    <span class="kw">data_list</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.5</span>,
      <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.1</span>,
      <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,
      <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.2</span>,
      <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.7</span>
    ),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>          <span class="kw">=</span> <span class="st">"K"</span>,
    <span class="kw">family</span>        <span class="kw">=</span> <span class="st">"IPM"</span>,
    <span class="kw">K</span>             <span class="kw">=</span> <span class="no">P</span> + <span class="no">F</span>,
    <span class="kw">data_list</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'dbh'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">FALSE</span>
  )  <span class="kw">%&gt;%</span>
  <span class="co"># Alternative 2, put the call to make_impl_args_list() inside of define_impl(). </span>
  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K"</span>, <span class="st">"P"</span>, <span class="st">"F"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>, <span class="fl">3</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"dbh"</span>,<span class="fl">3</span>)
    )
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_domains</a></span>(
    <span class="kw">dbh</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>, <span class="fl">30</span>, <span class="fl">200</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>()

<span class="no">lambda_ipmr</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="no">my_ipm</span>,
                      <span class="kw">comp_method</span> <span class="kw">=</span> <span class="st">'eigen'</span>)
<span class="no">repro_value</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/eigenvectors.html">left_ev</a></span>(<span class="no">my_ipm</span>)
<span class="no">stable_dist</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/eigenvectors.html">right_ev</a></span>(<span class="no">my_ipm</span>)</pre></body></html></div>
<p>In this example, there are no additional arguments that need to be passed to <code><a href="../reference/make_ipm.html">make_ipm()</a></code> - the <code>proto_ipm</code> has all of the information needed to generate a deterministic iteration kernel. All of the <code><a href="../reference/make_ipm.html">make_ipm()</a></code> methods return a list with a length of 6 with entries:</p>
<ul>
<li><p><code>iterators</code> contains iteration kernels, or <code>K</code>s.</p></li>
<li><p><code>sub_kernels</code> contains, in this example, <code>P</code> and <code>F</code>.</p></li>
<li><p><code>env_list</code> is empty, but setting <code>return_all = TRUE</code> in <code><a href="../reference/make_ipm.html">make_ipm()</a></code> returns the evaluation environments for each kernel and sub-kernel. These are used by subsequent analysis methods and so are important for internal usage, but are probably of limited use to most users.</p></li>
<li><p><code>env_seq</code> contains either an integer vector with the sequence of indices used to select kernels from the <code>iterators</code> during a stochastic simulation (<code>*_stoch_kern</code>), or a matrix of parameter estimates from each iteration of the stochastic simulation (<code>*_kern_param</code>). Not relevant for <code>*_det</code> methods with a single iteration kernel and so contains either as sequence of 1s or <code>NA</code>s</p></li>
<li><p><code>pop_state</code> contains a list of matrices for each item defined in <code><a href="../reference/define_star.html">define_pop_state()</a></code>. In this case, we never defined the initial population state, so it will be empty. When <code><a href="../reference/define_star.html">define_pop_state()</a></code> is used with <code>iterate = TRUE</code>, the rows of each matrix correspond to the population state and columns are time steps.</p></li>
<li><p><code>proto_ipm</code> contains the <code>proto_ipm</code> object used to generate the model. This is useful for rebuilding the model with a different set of <code>impl_args</code> or parameters to see how that changes your results.</p></li>
</ul>
<p><code>lambda</code>, <code>left_ev</code>, and <code>right_ev</code> are generic functions corresponding to the dominant eigenvalue, dominant left eigenvector, and dominant right eigenvector respectively. <code>lambda</code> is available for all classes of IPMs, while <code>left/right_ev</code> is available for all deterministic IPMs. Stochastic equivalents of the latter will be implemented eventually.</p>
</div>
<div id="defining-more-complicated-models" class="section level2">
<h2 class="hasAnchor">
<a href="#defining-more-complicated-models" class="anchor"></a>Defining more complicated models</h2>
<p>In the example above, we created a model with a single, deterministic kernel defined by a single state variable. Next, we’ll go through an example showing how to build kernels that are constructed from discretely varying parameter estimates.</p>
<div id="defining-a-simple-ipm-in-a-discretely-varying-environment" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-a-simple-ipm-in-a-discretely-varying-environment" class="anchor"></a>Defining a simple IPM in a discretely varying environment</h3>
<p><code>ipmr</code> uses a syntax that closely mirrors the mathematical notation of these models to successively build up more complicated expressions without requiring that much extra code as compared to the example above. The first type of model will be a stochastic, kernel-resampled simulation (<code>"simple_di_stoch_kern"</code>).</p>
<p>The vital rate models are as follows:</p>
<ol style="list-style-type: decimal">
<li>
<p>survival (<code>s_yr</code>): a logistic regression with a random year intercept (<code>s_r_yr</code>).</p>
<ul>
<li>Example model formula: <code>glmer(surv ~ size_1 + (1 | yr), data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>growth (<code>g_yr</code>): A linear regression random year intercept (<code>g_r_yr</code>).</p>
<ul>
<li>Example model formula: <code>lmer(size_2 ~ size_1 + (1 | yr), data = my_grow_data, family = gaussian()))</code>
</li>
</ul>
</li>
<li>
<p>pr(flowering) (<code>p_r</code>): A logistic regression. This has no random year effect.</p>
<ul>
<li>Example model formula: <code>glm(flower ~ size_1 , data = my_surv_data, family = binomial()))</code>
</li>
</ul>
</li>
<li>
<p>seed production (<code>f_s_yr</code>): A poisson regression with a random year intercept (<code>f_s_r_yr</code>)</p>
<ul>
<li>Example model formula: <code>glmer(seed_num ~ size_1 + (1 | yr), data = my_surv_data, family = poisson()))</code>
</li>
</ul>
</li>
<li><p>recruit size distribution (<code>f_d</code>): A normal distribution with two constant parameters, the mean (<code>mu_fd</code>) and standard deviation (<code>sd_fd</code>).</p></li>
</ol>
<p>The vital rates here are not conditional on each other as they come from separate models. For models where parameters come from a joint distribution (e.g. regressions with multiple responses, Bayesian multi-level models), <code>*_stoch_param</code> methods are usually more appropriate.</p>
<p>The chunk below takes the place of fitting regression models to actual data, so the code that replaces this chunk will look a little different (and probably involve the use of <code>coef(some_vital_rate_model</code>)).</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">ipmr</span>)

<span class="co"># Define some fixed parameters</span>

<span class="no">fixed_list</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
  <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fl">1.03</span>,   <span class="co"># fixef(my_surv_mod)[1] - uses fixef because we now have a model with random effects</span>
  <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fl">2.2</span>,    <span class="co"># fixef(my_surv_mod)[2]</span>
  <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fl">3.7</span>,    <span class="co"># fixef(my_grow_mod)[1]</span>
  <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fl">0.92</span>,   <span class="co"># fixef(my_grow_mod)[2]</span>
  <span class="kw">sd_g</span>      <span class="kw">=</span> <span class="fl">0.9</span>,    <span class="co"># sd(resid(my_grow_mod))</span>
  <span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.09</span>,   <span class="co"># coef(my_repro_mod)[1] - uses coef because there are no random effects in this model</span>
  <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.05</span>,   <span class="co"># coef(my_repro_mod)[2]</span>
  <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">0.1</span>,    <span class="co"># fixef(my_flower_mod)[1]</span>
  <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.005</span>,  <span class="co"># fixef(my_flower_mod)[2]</span>
  <span class="kw">mu_fd</span>     <span class="kw">=</span> <span class="fl">9</span>,      <span class="co"># mean(my_recr_data$size_2, na.rm = TRUE)</span>
  <span class="kw">sd_fd</span>     <span class="kw">=</span> <span class="fl">2</span>       <span class="co"># sd(my_recr_data$size_2, na.rm = TRUE)</span>
)</pre></body></html></div>
<p>We’ve defined a <code>fixed_list</code> that holds all of the fixed parameters in our model. Next, we’ll make up some random year specific intercepts, and add those to the <code>fixed_list</code>, naming it <code>all_params_list</code>. You don’t necessarily need to rename anything, this is just for disambiguation.</p>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="co"># Now, simulate some random intercepts for growth (g_), survival (s_), </span>
<span class="co"># and offspring production (f_s_). This part is for the purpose of the example.</span>

<span class="co"># First, we create vector of values corresponding to </span>

<span class="no">g_r_int</span>   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.3</span>) <span class="co"># unlist(ranef(my_grow_mod)) for an lme4 output</span>
<span class="no">s_r_int</span>   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.7</span>) <span class="co"># unlist(ranef(my_surv_mod)) for an lme4 output</span>
<span class="no">f_s_r_int</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">0.2</span>) <span class="co"># unlist(ranef(my_flower_mod)) for an lme4 output</span>

<span class="no">nms</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"r_"</span>, <span class="fl">1</span>:<span class="fl">5</span>, <span class="kw">sep</span> <span class="kw">=</span> <span class="st">""</span>)

<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="no">g_r_int</span>)   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'g_'</span>, <span class="no">nms</span>, <span class="kw">sep</span> <span class="kw">=</span> <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="no">s_r_int</span>)   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'s_'</span>, <span class="no">nms</span>, <span class="kw">sep</span> <span class="kw">=</span> <span class="st">""</span>)
<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="no">f_s_r_int</span>) <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">'f_s_'</span>, <span class="no">nms</span>, <span class="kw">sep</span> <span class="kw">=</span> <span class="st">""</span>)

<span class="co"># Each set of parameters is converted to a named list. The names should match</span>
<span class="co"># the variables referenced in each define_kernel()/define_k() call.</span>

<span class="no">g_params</span>   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="no">g_r_int</span>)
<span class="no">s_params</span>   <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="no">s_r_int</span>)
<span class="no">f_s_params</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="no">f_s_r_int</span>)

<span class="co"># add them all together using c()</span>

<span class="no">all_params_list</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="no">fixed_list</span>, <span class="no">g_params</span>, <span class="no">s_params</span>, <span class="no">f_s_params</span>)</pre></body></html></div>
<p>We’ve created a list where each entry is named and contains a single parameter value. This is now ready for use in <code><a href="../reference/kernel-definitions.html">define_kernel()</a></code></p>
</div>
<div id="defining-custom-functions-to-pass-to-the-building-process" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-custom-functions-to-pass-to-the-building-process" class="anchor"></a>Defining custom functions to pass to the building process</h3>
<p>We have our parameter values. In the next step, we’ll compose some helper functions to make the vital rate expressions inside of <code><a href="../reference/kernel-definitions.html">define_kernel()</a></code> a bit more concise and expressive. These are passed in a list to the <code>usr_funs</code> argument of <code><a href="../reference/make_ipm.html">make_ipm()</a></code>.</p>
<div class="sourceCode" id="cb10"><html><body><pre class="r"><span class="no">inv_logit</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">sv</span>, <span class="no">int</span>, <span class="no">slope</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">int</span> + <span class="no">slope</span> * <span class="no">sv</span>)))
  )
}

<span class="co"># same as above, but handles the extra term from the random effect we simulated.</span>

<span class="no">inv_logit_r</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">sv</span>, <span class="no">int</span>, <span class="no">slope</span>, <span class="no">r_eff</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">int</span> + <span class="no">slope</span> * <span class="no">sv</span> + <span class="no">r_eff</span>)))
  )
}

<span class="no">pois_r</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">sv</span>, <span class="no">int</span>, <span class="no">slope</span>, <span class="no">r_eff</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(
    <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(
      <span class="no">int</span> + <span class="no">slope</span> * <span class="no">sv</span> + <span class="no">r_eff</span>
    )
  )
}

<span class="no">my_funs</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">inv_logit</span>   <span class="kw">=</span> <span class="no">inv_logit</span>,
                <span class="kw">inv_logit_r</span> <span class="kw">=</span> <span class="no">inv_logit_r</span>,
                <span class="kw">pois_r</span>      <span class="kw">=</span> <span class="no">pois_r</span>)</pre></body></html></div>
<p>The only requirement for these functions is that they contain valid R code, and their return types are either numeric or integer.</p>
</div>
<div id="implement-the-ipm-1" class="section level3">
<h3 class="hasAnchor">
<a href="#implement-the-ipm-1" class="anchor"></a>Implement the IPM</h3>
<p>With the functions and parameter values defined, we are now ready to begin composing the model. Each expression’s syntax will look a little different from before, because we are appending a suffix corresponding to the hierarchical component of the model to each parameter/vital rate/kernel that is affected by it. In this case, we’re pretending it is a year effect, denoted <code>_yr</code>, but almost any suffix will work. This can be a character or integer vector, and the list can have as many entries as required by the model (e.g. <code>yr</code> for years <em>and</em> <code>pl</code> for plots. The suffix could then become <code>_yr_pl</code> or <code>_pl_yr</code>. order doesn’t matter here). The calls to <code>define_kernel</code> and <code>define_k</code> now have <code>has_hier_effs = TRUE</code>, and <code>levels_hier_effs = list(yr = 1:5)</code>. Otherwise, the code should look quite familiar.</p>
<p><strong>NOTE:</strong> Because of the way <code>ipmr</code> handles population vectors internally, <strong>the only suffix that isn’t allowed is <code>_pop</code></strong>. This is unfortunate, but can be worked around. Please use <code>_site</code> or <code>_popul</code> or something instead. Sorry!</p>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="no">my_ipm</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_stoch_kern'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>             <span class="kw">=</span> <span class="st">'P_yr'</span>,         <span class="co"># P because P_yr</span>
    <span class="kw">formula</span>          <span class="kw">=</span> <span class="no">s_yr</span> * <span class="no">g_yr</span>,    <span class="co"># g and s become g_yr and s_yr, respectively</span>
    <span class="kw">family</span>           <span class="kw">=</span> <span class="st">"CC"</span>,

    <span class="co"># Note the usage of the inv_logit_r, which we defined in the block above.</span>
    <span class="co"># it is passed to make_ipm() </span>

    <span class="kw">s_yr</span>             <span class="kw">=</span> <span class="fu">inv_logit_r</span>(<span class="no">ht_1</span>, <span class="no">s_int</span>, <span class="no">s_slope</span>, <span class="no">s_r_yr</span>),
    <span class="kw">g_yr</span>             <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">ht_2</span>, <span class="kw">mean</span> <span class="kw">=</span> <span class="no">mu_g_yr</span>, <span class="kw">sd</span> <span class="kw">=</span> <span class="no">sd_g</span>),
    <span class="kw">mu_g_yr</span>          <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">ht_1</span> + <span class="no">g_r_yr</span>,

    <span class="co"># all_params_list contains the named parameters g_r_1, g_r_2, s_r_1, s_r_2, etc.</span>
    <span class="co"># This is the only level where the user is required to fully expand the name</span>
    <span class="co"># X hier_level combinations. </span>

    <span class="kw">data_list</span>        <span class="kw">=</span> <span class="no">all_params_list</span>,
    <span class="kw">states</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    <span class="kw">has_hier_effs</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">levels_hier_effs</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">yr</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="fl">5</span>),
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">TRUE</span>,

    <span class="co"># reference to g_yr in evict_fun is also updated</span>

    <span class="kw">evict_fun</span>        <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g_yr"</span>)

  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>             <span class="kw">=</span> <span class="st">"F_yr"</span>,             <span class="co"># Update the names as we did for the P kernel</span>
    <span class="kw">formula</span>          <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s_yr</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>           <span class="kw">=</span> <span class="st">"CC"</span>,
    <span class="kw">f_r</span>              <span class="kw">=</span> <span class="fu">inv_logit</span>(<span class="no">ht_1</span>, <span class="no">f_r_int</span>, <span class="no">f_r_slope</span>),
    <span class="kw">f_s_yr</span>           <span class="kw">=</span> <span class="fu">pois_r</span>(<span class="no">ht_1</span>, <span class="no">f_s_int</span>, <span class="no">f_s_slope</span>, <span class="no">f_s_r_yr</span>),
    <span class="kw">f_d</span>              <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">ht_2</span>, <span class="kw">mean</span> <span class="kw">=</span> <span class="no">mu_fd</span>, <span class="kw">sd</span> <span class="kw">=</span> <span class="no">sd_fd</span>),
    <span class="kw">data_list</span>        <span class="kw">=</span> <span class="no">all_params_list</span>,
    <span class="kw">states</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    <span class="kw">has_hier_effs</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">levels_hier_effs</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">yr</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="fl">5</span>),
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>        <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>             <span class="kw">=</span> <span class="st">'K_yr'</span>,
    <span class="kw">K_yr</span>             <span class="kw">=</span> <span class="no">P_yr</span> + <span class="no">F_yr</span>,
    <span class="kw">family</span>           <span class="kw">=</span> <span class="st">"IPM"</span>,
    <span class="kw">data_list</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>)),
    <span class="kw">has_hier_effs</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">levels_hier_effs</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">yr</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="fl">5</span>),
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">FALSE</span>
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K_yr"</span>, <span class="st">"P_yr"</span>, <span class="st">"F_yr"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"midpoint"</span>, <span class="fl">3</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">"ht"</span>, <span class="fl">3</span>)
    )
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_domains</a></span>(<span class="kw">ht</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.2</span>, <span class="fl">40</span>, <span class="fl">100</span>)) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(<span class="kw">usr_funs</span> <span class="kw">=</span> <span class="no">my_funs</span>,
           <span class="kw">iterate</span>  <span class="kw">=</span> <span class="fl">FALSE</span>)</pre></body></html></div>
<p><code>ipmr</code> automatically substitutes 1, 2, 3, 4, and 5 for each occurence of <code>yr</code> in the vital rate expressions. Thus, <code>P_yr</code> is expanded to <code>P_1</code>, <code>P_2</code>, <code>P_3</code>, <code>P_4</code>, <code>P_5</code>, <code>s_yr</code> to <code>s_1</code>, <code>s_2</code>, <code>s_3</code>, <code>s_4</code>, and <code>s_5</code>. <code>s_r_yr</code> is converted to <code>s_r_1</code>, <code>s_r_2</code>, etc. This is why we needed to make sure the names in <code>all_params_list</code> had the actual numbers appended to them.</p>
<p>Syntax aside, the only real difference between the IPM definition in the first example and this one is that we’ve passed custom functions to the call to <code><a href="../reference/make_ipm.html">make_ipm()</a></code>, and altered our vital rate expressions to use them instead of the pure math for each variable transformation. On the other hand, the contents of the output <em>will</em> look a little different.</p>
<ul>
<li><p>The <code>iterators</code> slot of <code>my_ipm</code> now contains 5 K kernels - one for each year of data.</p></li>
<li><p>The <code>sub_kernels</code> slot of <code>my_ipm</code> now contains 5 P and 5 F kernels (10 total) - again, one for each year of data.</p></li>
<li><p>All other slots will look the same as in the previous <code>simple_di_det</code> example.</p></li>
</ul>
<p>To run an actual simulation for, say, 100 time steps, we can remove the existing <code>K</code> using the helper <code><a href="../reference/kernel-definitions.html">remove_k()</a></code>, add a new one with <code><a href="../reference/kernel-definitions.html">define_k()</a></code>, and reimplement the model. This requires defining an expression that relates the population state at <code>t+1</code> to the K kernel and population state at <code>t</code> (done in <code>define_k</code>), defining an initial population state (done in <code>define_pop_state</code>), and running <code><a href="../reference/make_ipm.html">make_ipm(iterate = TRUE, iterations = 100)</a></code>.</p>
<div class="sourceCode" id="cb12"><html><body><pre class="r"><span class="no">my_iterated_ipm</span> <span class="kw">&lt;-</span> <span class="no">my_ipm</span>$<span class="no">proto_ipm</span> <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">remove_k</a></span>() <span class="kw">%&gt;%</span>                        <span class="co"># remove the existing K and define a new one</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span>             <span class="kw">=</span> <span class="st">"K_yr"</span>,
    <span class="kw">K_yr</span>             <span class="kw">=</span> <span class="no">P_yr</span> + <span class="no">F_yr</span>,

    <span class="co"># n_ht_t and n_ht_t_1 are automatically created internally when </span>
    <span class="co"># define_pop_state() is called. We do not need to create them</span>
    <span class="co"># in the data_list or anything, just to specify n_ht in define_pop_state()</span>

    <span class="kw">n_ht_t_1</span>         <span class="kw">=</span> <span class="no">K_yr</span> <span class="kw">%*%</span> <span class="no">n_ht_t</span>,
    <span class="kw">family</span>           <span class="kw">=</span> <span class="st">'IPM'</span>,
    <span class="kw">data_list</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(),
    <span class="kw">states</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'ht'</span>)),
    <span class="kw">has_hier_effs</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">levels_hier_effs</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">yr</span> <span class="kw">=</span> <span class="fl">1</span>:<span class="fl">5</span>),
    <span class="kw">evict_cor</span>        <span class="kw">=</span> <span class="fl">FALSE</span>
  ) <span class="kw">%&gt;%</span>

  <span class="co"># This time arond, we don't need to define impl_args for every kernel, just </span>
  <span class="co"># the new K. We can also skip defining the domains, those are already done</span>
  <span class="co"># too.</span>

  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"K_yr"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'midpoint'</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"ht"</span>)
    )
  ) <span class="kw">%&gt;%</span>

  <span class="co"># Initialize the population vector. This can take any expression. Note that</span>
  <span class="co"># the population state has an n_ prefixed to it to indicate that it is</span>
  <span class="co"># describing the population distribution function. ipmr will automatically</span>
  <span class="co"># create variables n_ht_t and n_ht_t_1 when constructing the IPM.  </span>
  <span class="fu"><a href="../reference/define_star.html">define_pop_state</a></span>(<span class="kw">n_ht</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">100</span>)) <span class="kw">%&gt;%</span>

  <span class="co"># We use the kernel_seq argument to pass a pre-specified sequence of kernels</span>
  <span class="co"># into the function, and retrieve it later using my_iterated_ipm$env_seq</span>

  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(<span class="kw">usr_funs</span>   <span class="kw">=</span> <span class="no">my_funs</span>,
           <span class="kw">kernel_seq</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="fl">1</span>:<span class="fl">5</span>, <span class="fl">100</span>, <span class="kw">replace</span> <span class="kw">=</span> <span class="fl">TRUE</span>),
           <span class="kw">iterate</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
           <span class="kw">iterations</span> <span class="kw">=</span> <span class="fl">100</span>)

<span class="co"># lambda(comp_method = 'pop_size', type = 'all') will compute the population </span>
<span class="co"># growth rate for every time step as the sum(n_ht_t_1) / sum(n_ht_t).</span>

<span class="no">det_lambdas</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="no">my_iterated_ipm</span>, <span class="kw">comp_method</span> <span class="kw">=</span> <span class="st">'pop_size'</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">'all'</span>)

<span class="co"># lambda(comp_method = 'pop_size', type = 'stochastic') computes</span>
<span class="co"># the mean of the log'd values computed by type = 'all' (Caswell 2001, p 396).</span>

<span class="no">stoch_lambda</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="no">my_iterated_ipm</span>, <span class="kw">comp_method</span> <span class="kw">=</span> <span class="st">'pop_size'</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">'stochastic'</span>)</pre></body></html></div>
<p>100 iterations is not enough to estimate stochastic growth rates (<span class="math inline">\(\lambda_s\)</span>), but the computations can take some time with a lot of iterations, and are not practical for demonstration purposes.</p>
</div>
</div>
<div id="simple-ipms-for-continuously-varying-environments" class="section level2">
<h2 class="hasAnchor">
<a href="#simple-ipms-for-continuously-varying-environments" class="anchor"></a>Simple IPMs for continuously varying environments</h2>
<p>In some cases, it is not desirable to work with single estimates of a random variable, and we prefer to work with the distributions they come from. Quantifying uncertainty is a critical part of demography. Additionally, environmental variables like climate may be random with reasonably well known distributions. A stochastic simulation can incorporate information to help us understand the consequences.</p>
<p>Unfortunately, this also means that we can’t obtain a set of kernels without iterating the model at least once, because we have to sample from the parameter distributions at least once (well, technically, we can, but this is probably not the desired behavior). This is where the <code>*_stoch_param</code> methods come in handy. <code>*_stoch_param</code> methods are slightly less computationally efficient than their <code>*_stoch_kern*</code> counterparts because they must rebuild the iteration kernel for every single iteration. However, they are fantastic tools for exploring uncertainty and/or random variation.</p>
<p>Below is an example that demonstrates how to work with posterior distributions from Bayesian models. This far from the only use case for this type of model, but will hopefully demonstrate how to incorporate parameter distributions into an IPM. <code>ipmr</code> is careful to only evaluate each expression in <code><a href="../reference/define_star.html">define_env_state()</a></code> once per iteration, so we can safely work with multivariate distributions using very little additional code.</p>
<p>Equivalent code is demonstrated in the comments, but switches to a Bayesian model for growth and survival, specifically <a href="https://paul-buerkner.github.io/brms/"><code>brms</code></a>. The parameters for the growth and survival functions will be sampled from posterior distributions one time per iteration, and an example of a function to pass to <code><a href="../reference/define_star.html">define_env_state()</a></code> is included in the first chunk below.</p>
<p>There are a multitude of ways to incorporate uncertainty and other sources of continuous variation into regression models and IPMs, and that variety is beyond the scope of this vignette. The following resources are excellent introductions to both and themselves contain a multitude of further readings:</p>
<ol style="list-style-type: decimal">
<li><p><a href="https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#introduction">wiki for GLMMs</a></p></li>
<li><p><a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12405">Metcalf et al 2015</a>.</p></li>
</ol>
<div id="defining-initial-conditions" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-initial-conditions" class="anchor"></a>Defining initial conditions</h3>
<p>Stochastic simulations require specification of the initial conditions. <code>ipmr</code> aims to make this straightforward for you by providing two helpers - <code><a href="../reference/define_star.html">define_pop_state()</a></code> and <code><a href="../reference/define_star.html">define_env_state()</a></code>.</p>
<div id="define_pop_state" class="section level4">
<h4 class="hasAnchor">
<a href="#define_pop_state" class="anchor"></a><code>define_pop_state()</code>
</h4>
<p><code><a href="../reference/define_star.html">define_pop_state()</a></code> takes either</p>
<ol style="list-style-type: decimal">
<li>
<p>a named set of expressions that, when evaluated, generate a population vector</p>
<ul>
<li>example: <code>define_pop_state(n_dbh = runif(100)</code>) for a model with 100 meshpoints.</li>
</ul>
</li>
</ol>
<p><strong>or</strong></p>
<ol start="2" style="list-style-type: decimal">
<li>
<p>a named list of pre-generated population vectors in the <code>pop_vectors</code> argument. This format is useful for programming with population vectors that are computed elsewhere.</p>
<ul>
<li>example: <code><a href="../reference/define_star.html">define_pop_state(pop_vectors = list(n_dbh = init_dbh_vector))</a></code>, where <code>init_dbh_vector</code> is generated somewhere earlier in the script.</li>
</ul>
</li>
</ol>
<p>In <code><a href="../reference/define_star.html">define_pop_state()</a></code>, populations should be defined as <code>n_&lt;insertStateVariableHere&gt;</code>. If this function is used in the IPM definition code, then 2 additional helper variables are generated: <code>n_stateVariable_t</code> and <code>n_stateVariable_t_1</code>. These can be used to reference the population states in vital rate and/or kernel expressions. They must be referenced in the <code>...</code> of <code><a href="../reference/kernel-definitions.html">define_k()</a></code> as well, because otherwise, <code>ipmr</code> doesn’t know how to iterate the model.</p>
</div>
<div id="define_env_state" class="section level4">
<h4 class="hasAnchor">
<a href="#define_env_state" class="anchor"></a><code>define_env_state()</code>
</h4>
<p><code><a href="../reference/define_star.html">define_env_state()</a></code> takes a named set of expressions in the <code>...</code> and then a data list, much like how <code><a href="../reference/kernel-definitions.html">define_kernel()</a></code>/<code><a href="../reference/kernel-definitions.html">define_k()</a></code> take them. The values created need to be in a list that has names corresponding to the parameter names in the vital rate expressions. In this example, they are called <code>s_int</code>, <code>s_slope</code>, <code>g_int</code>, <code>g_slope</code>, and <code>g_sd</code>. The <code>data_list</code> in this section should contain any variables used in the function we define (in this example, <code>posterior_distribs</code>). we can reference them in the vital rate expressions in each kernel definition as if they were in the <code>data_list</code> of <code>define_kernel/define_k()</code>.</p>
</div>
</div>
<div id="vital-rate-models" class="section level3">
<h3 class="hasAnchor">
<a href="#vital-rate-models" class="anchor"></a>Vital rate models</h3>
<p>The first chunk below initializes the parameters and functions that the model uses. It takes the place of the usual vital rate model fitting process.</p>
<p>This example uses two Bayesian models for survival and growth and a single function to sample them to illustrate how to use continuously varying parameter distributions in <code>ipmr</code>. This only uses two models and one function to limit the the complexity of the example - there is no upper limit on the number of parameters or functions you can use in your own models.</p>
<p>The vital rate functions are described here:</p>
<ol style="list-style-type: decimal">
<li>
<p>survival (<code>s</code>): a Bayesian logistic regression.</p>
<ul>
<li>example model formula: <code>brm(survival ~ size_1, data = my_surv_data, family = bernoulli(), chains = 4,iter = 2000, warmup = 1000)</code>
</li>
</ul>
</li>
<li>
<p>growth (<code>g</code>): a Bayesian linear regression</p>
<ul>
<li>example model formula: <code>brm(size_2 ~ size_1, data = my_grow_data, family = gaussian(), chains = 4,iter = 2000, warmup = 1000)</code>
</li>
</ul>
</li>
<li>
<p>flower probability (<code>f_r</code>): A non-bayesian logistic regression.</p>
<ul>
<li>example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(repro ~ size_1, data = my_repro_data, family = binomial())</a></code>
</li>
</ul>
</li>
<li>
<p>seed production (<code>f_s</code>): a non-bayesian logistic regression.</p>
<ul>
<li>example model formula: <code><a href="https://rdrr.io/r/stats/glm.html">glm(flower_n ~ size_1, data = my_flower_data, family = poisson())</a></code>
</li>
</ul>
</li>
<li>
<p>recruit sizes (<code>f_d</code>): A normal distribution</p>
<ul>
<li>example code: mean (<code>f_d_mu</code>) <code><a href="https://rdrr.io/r/base/mean.html">mean(my_recruit_data$size_2, na.rm = TRUE)</a></code> and standard deviation (<code>f_d_sd</code>) <code><a href="https://rdrr.io/r/stats/sd.html">sd(my_recruit_data$size_2, na.rm = TRUE)</a></code>
</li>
</ul>
</li>
</ol>
<p>And the the parameter values are given here:</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="no">ipmr</span>)

<span class="co"># Define the fixed parameters in a list</span>

<span class="no">constant_params</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">f_r_int</span>   <span class="kw">=</span> <span class="fl">0.3</span>,
                        <span class="kw">f_r_slope</span> <span class="kw">=</span> <span class="fl">0.03</span>,
                        <span class="kw">f_s_int</span>   <span class="kw">=</span> <span class="fl">0.4</span>,
                        <span class="kw">f_s_slope</span> <span class="kw">=</span> <span class="fl">0.001</span>,
                        <span class="kw">f_d_mu</span>    <span class="kw">=</span> <span class="fl">1.1</span>,
                        <span class="kw">f_d_sd</span>    <span class="kw">=</span> <span class="fl">0.1</span>)

<span class="co"># Simulate some random parameters to define the multivariate distribution</span>
<span class="co"># to sample from. In user specified models, this might be replaced by</span>
<span class="co"># cbind(posterior_samples(my_surv_mod), posterior_samples(my_grow_mod)).</span>

<span class="no">posterior_distribution</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span>(
  <span class="kw">s_int</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">4000</span>, <span class="kw">mean</span> <span class="kw">=</span> -<span class="fl">10</span>, <span class="kw">sd</span> <span class="kw">=</span> <span class="fl">1</span>),
  <span class="kw">s_slope</span>   <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span>(<span class="fl">4000</span>, <span class="kw">shape</span> <span class="kw">=</span> <span class="fl">1</span>), <span class="co"># slope should be positive for this example</span>
  <span class="kw">g_int</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">4000</span>),
  <span class="kw">g_slope</span>   <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">4000</span>, <span class="fl">0.85</span>, <span class="fl">1.15</span>),
  <span class="kw">g_sd</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">4000</span>, <span class="fl">0.75</span>, <span class="fl">3</span>)
)

<span class="co"># set the names to the parameter names we want to use in the model. These </span>
<span class="co"># are already set in this example, but outputs from brms/rstan/lme4 may not be</span>
<span class="co"># as conveniently named. </span>

<span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="no">posterior_distribution</span>) <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(
  <span class="st">'s_int'</span>,
  <span class="st">'s_slope'</span>,
  <span class="st">'g_int'</span>,
  <span class="st">'g_slope'</span>,
  <span class="st">'g_sd'</span>
)

<span class="co"># We define a wrapper function that samples from a data frame containing the</span>
<span class="co"># joint posterior distribution of each parameter. In this case, all posterior</span>
<span class="co"># samples are weighted as equally probable for the sake of simplicity. One could</span>
<span class="co"># modify this to generate more realistic probabilities.</span>

<span class="no">posterior_sample</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">posterior_distrib</span>) {

  <span class="no">sample_pos</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">posterior_distrib</span>)[<span class="fl">1</span>], <span class="kw">by</span> <span class="kw">=</span> <span class="fl">1</span>)

  <span class="no">sample_ind</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="no">sample_pos</span>, <span class="kw">size</span> <span class="kw">=</span> <span class="fl">1</span>, <span class="kw">prob</span> <span class="kw">=</span> <span class="kw">NULL</span>)

  <span class="no">out</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span>(<span class="no">posterior_distrib</span>[<span class="no">sample_ind</span> , ])

  <span class="fu"><a href="https://rdrr.io/r/base/function.html">return</a></span>(<span class="no">out</span>)

}


<span class="co"># Again, we can define our own functions and pass them into calls to make_ipm. This</span>
<span class="co"># isn't strictly necessary, but can make the model code more readable/less error prone.</span>

<span class="no">inv_logit</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">int</span>, <span class="no">slope</span>, <span class="no">sv1</span>) {
  <span class="fl">1</span>/(<span class="fl">1</span> + <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(-(<span class="no">int</span> + <span class="no">slope</span> * <span class="no">sv1</span>)))
}</pre></body></html></div>
</div>
<div id="the-continuously-varying-ipm" class="section level3">
<h3 class="hasAnchor">
<a href="#the-continuously-varying-ipm" class="anchor"></a>The continuously varying IPM</h3>
<p>We now have parameter estimates. Time to build the IPM!</p>
<div class="sourceCode" id="cb14"><html><body><pre class="r"><span class="no">init_pop_vec</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="fl">100</span>)

<span class="no">param_resamp_model</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/init_ipm.html">init_ipm</a></span>(<span class="st">'simple_di_stoch_param'</span>) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>    <span class="kw">=</span> <span class="st">'P'</span>,
    <span class="kw">formula</span> <span class="kw">=</span> <span class="no">s</span> * <span class="no">g</span>,
    <span class="kw">family</span>  <span class="kw">=</span> <span class="st">'CC'</span>,

    <span class="co"># Parameters created by define_env_state() can be referenced by name just like</span>
    <span class="co"># any other parameter in the model.</span>

    <span class="kw">g_mu</span>      <span class="kw">=</span> <span class="no">g_int</span> + <span class="no">g_slope</span> * <span class="no">surf_area_1</span>,
    <span class="kw">s</span>         <span class="kw">=</span> <span class="fu">inv_logit</span>(<span class="no">s_int</span>, <span class="no">s_slope</span>, <span class="no">surf_area_1</span>),
    <span class="kw">g</span>         <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">surf_area_2</span>, <span class="no">g_mu</span>, <span class="no">g_sd</span>),
    <span class="kw">data_list</span> <span class="kw">=</span> <span class="no">constant_params</span>,
    <span class="kw">states</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),

    <span class="co"># In this case, we do not specify hier_effs as the kernels don't vary discretely,</span>
    <span class="co"># but in a continuous manner.</span>

    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"g"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_kernel</a></span>(
    <span class="kw">name</span>          <span class="kw">=</span> <span class="st">'F'</span>,
    <span class="kw">formula</span>       <span class="kw">=</span> <span class="no">f_r</span> * <span class="no">f_s</span> * <span class="no">f_d</span>,
    <span class="kw">family</span>        <span class="kw">=</span> <span class="st">'CC'</span>,
    <span class="kw">f_r</span>           <span class="kw">=</span> <span class="fu">inv_logit</span>(<span class="no">f_r_int</span>, <span class="no">f_r_slope</span>, <span class="no">surf_area_1</span>),
    <span class="kw">f_s</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="no">f_s_int</span> + <span class="no">f_s_slope</span> * <span class="no">surf_area_1</span>),
    <span class="kw">f_d</span>           <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span>(<span class="no">surf_area_2</span>, <span class="no">f_d_mu</span>, <span class="no">f_d_sd</span>),
    <span class="kw">data_list</span>     <span class="kw">=</span> <span class="no">constant_params</span>,
    <span class="kw">states</span>        <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    <span class="kw">has_hier_effs</span> <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>     <span class="kw">=</span> <span class="fl">TRUE</span>,
    <span class="kw">evict_fun</span>     <span class="kw">=</span> <span class="fu"><a href="../reference/eviction.html">truncated_distributions</a></span>(<span class="st">"norm"</span>, <span class="st">"f_d"</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/kernel-definitions.html">define_k</a></span>(
    <span class="kw">name</span> <span class="kw">=</span> <span class="st">'K'</span>,

    <span class="co"># Note that here, we specify both the form of the iteration kernel and</span>
    <span class="co"># the iteration procedure. The commented out form directly beneath uses</span>
    <span class="co"># right_mult(), a helper function for more complicated expressions. It is </span>
    <span class="co"># equivalent to the line above it.</span>

    <span class="kw">K</span>               <span class="kw">=</span> <span class="no">P</span> + <span class="no">F</span>,
    <span class="kw">n_surf_area_t_1</span> <span class="kw">=</span> <span class="no">K</span> <span class="kw">%*%</span> <span class="no">n_surf_area_t</span>,
    <span class="co"># n_surf_area_t_1 = right_mult(K, n_surf_area_t),</span>
    <span class="kw">family</span>          <span class="kw">=</span> <span class="st">'IPM'</span>,
    <span class="kw">data_list</span>       <span class="kw">=</span> <span class="no">constant_params</span>,
    <span class="kw">states</span>          <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'surf_area'</span>)),
    <span class="kw">has_hier_effs</span>   <span class="kw">=</span> <span class="fl">FALSE</span>,
    <span class="kw">evict_cor</span>          <span class="kw">=</span> <span class="fl">FALSE</span>
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_impl</a></span>(
    <span class="fu"><a href="../reference/define_star.html">make_impl_args_list</a></span>(
      <span class="kw">kernel_names</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"P"</span>, <span class="st">"F"</span>, <span class="st">"K"</span>),
      <span class="kw">int_rule</span>     <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'midpoint'</span>, <span class="fl">3</span>),
      <span class="kw">dom_start</span>    <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>,<span class="fl">3</span>),
      <span class="kw">dom_end</span>      <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="st">'surf_area'</span>, <span class="fl">3</span>)
    )
  ) <span class="kw">%&gt;%</span>
    <span class="fu"><a href="../reference/define_star.html">define_domains</a></span>(<span class="kw">surf_area</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">10</span>, <span class="fl">100</span>))</pre></body></html></div>
<p>The continuously varying parameters and the expressionss that generate them should be passed into <code><a href="../reference/define_star.html">define_env_state()</a></code>. <code><a href="../reference/make_ipm.html">make_ipm()</a></code> will ensure that these are evaluated only once per iteration of the model, so that we can safely work with joint distributions that generate multiple parameter estimates per draw.</p>
<p>The <code>...</code> part of <code><a href="../reference/define_star.html">define_env_state()</a></code> should be expressions that generate the variables we would like to reference. In this case <code>env_params</code> is a named list that contains <code>s_int</code>, <code>s_slope</code>, <code>g_int</code>, <code>g_slope</code>, and <code>g_sd</code>. The <code>s_int</code>, <code>s_slope</code>, etc are the names that will be generated by the IPM code, and so are the names that should be referenced in the kernels’ vital rate expressions, not <code>env_params</code>! we don’t need to remember that we called this particular object <code>env_params</code> when we write our vital rate expressions, but it does have to be named something for the IPM code to run.</p>
<p>The <code>data_list</code> contains the data frame we made that contains the posterior samples from our vital rate model. In this example, the growth and survival models weren’t actually fit together, so there’s no statistical reason to actually combine them, it’s just for simplicity.</p>
<p>The only requirement here is that the names</p>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="no">param_resamp_model</span> <span class="kw">&lt;-</span> <span class="no">param_resamp_model</span> <span class="kw">%&gt;%</span>

  <span class="fu"><a href="../reference/define_star.html">define_env_state</a></span>(
    <span class="kw">env_params</span> <span class="kw">=</span> <span class="fu">posterior_sample</span>(<span class="no">posterior_distrib</span>),
    <span class="kw">data_list</span>  <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">posterior_distrib</span> <span class="kw">=</span> <span class="no">posterior_distribution</span>)
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/define_star.html">define_pop_state</a></span>(
    <span class="kw">pop_vectors</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">n_surf_area_t</span> <span class="kw">=</span> <span class="no">init_pop_vec</span>
    ),
  ) <span class="kw">%&gt;%</span>
  <span class="fu"><a href="../reference/make_ipm.html">make_ipm</a></span>(<span class="kw">usr_funs</span>   <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">inv_logit</span>        <span class="kw">=</span> <span class="no">inv_logit</span>,
                             <span class="kw">posterior_sample</span> <span class="kw">=</span> <span class="no">posterior_sample</span>),
           <span class="kw">iterate</span>    <span class="kw">=</span> <span class="fl">TRUE</span>,
           <span class="kw">iterations</span> <span class="kw">=</span> <span class="fl">10</span>)

<span class="fu"><a href="../reference/lambda.html">lambda</a></span>(<span class="no">param_resamp_model</span>, <span class="kw">comp_method</span> <span class="kw">=</span> <span class="st">'pop_size'</span>, <span class="kw">type_lambda</span> <span class="kw">=</span> <span class="st">'all'</span>)

<span class="co"># If we want to see the actual draws that were used at each step of the </span>
<span class="co"># model iteration, we can access these using the output's $env_seq slot.</span>

<span class="no">param_resamp_model</span>$<span class="no">env_seq</span></pre></body></html></div>
</div>
</div>
<div id="general-ipms" class="section level2">
<h2 class="hasAnchor">
<a href="#general-ipms" class="anchor"></a>General IPMs</h2>
<p>An article on these is available on the <a href="https://levisc8.github.io/ipmr/articles/general-ipms.html">website</a> and from an R session:</p>
<div class="sourceCode" id="cb16"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/utils/vignette.html">vignette</a></span>(<span class="st">'General IPMs'</span>, <span class="st">'ipmr'</span>)</pre></body></html></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by <a href="https://github.com/levisc8">Sam Levin</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
