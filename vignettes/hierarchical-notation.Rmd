---
title: "Hierarchical Notation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Hierarchical Notation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette describes how to write formulas using `ipmr`'s notation for hierarchical models. It is meant to mirror the standard mathematical notation used to represent the models. The examples here will primarily use [lme4](https://github.com/lme4/lme4/) and [brms](https://github.com/paul-buerkner/brms) to illustrate how to go from vital rate models to functional forms that you can use in `ipmr`. You are of course free to use whatever model fitting software you like, but the number of different possibilities are far too great to cover in this vignette. 

The notation is meant to make implementing models more concise, as it allows you to avoid re-typing/copy+pasting the same kernel formats and just substituting, for example, plot name or transition year. It works by appending suffixes to kernels, vital rates, and parameters that can take multiple values (e.g. `P` becomes `P_yr`). We then add a named list where the name corresponds to the suffix and the entries correspond to the values it can take (`list(yr = 1:5)`), set `has_hier_effs = TRUE` and pass our list to `levels_hier_effs`. 

## Structure

1. [Quick start guide shows how to go from mathematical form to model formula to `ipmr` code.](#quick)

2. [Worked example with a simple, density independent, stochastic kernel re-sampled model.](#sim_di_s_k)

3. [Worked example with a general, density independent, stochastic parameter resampled model.](#complicated)

## Quick start guide {#quick}

Some quick translations between mathematical notation, R model syntax, and `ipmr` style notation. In the `ipmr` column, suffixes that are appended are highlighted in **bold**.

Suffix names are not restricted to the examples below. The only requirement is that the suffix not be named `"pop"`. This is an unfortunate side effect of the way `ipmr` handles population vectors internally - please use something like `"site"` or `"population"` instead.

```{r echo = FALSE}

tab_legend <- "Math Formula corresponds to the mathematical notation for the model. R Formula corresponds to how one could write the model using R's model formula syntax (think `lm`, `glm`, `lmer`). ipmr shows an equivalent way to write this model in kernel formula or vital rate expression. Model Number indicates which rows are grouped together, as some models have too many terms to cleanly fit on a line, or have multiple equivalent representations."

styles <- c("style='width:150%;'")

knitr::kable(
  data.frame(

    Math    = c("$\\mu_g^{yr} = \\alpha_g + \\alpha_g^{yr} * \\beta_g * z + e$",
                         "$z' \\sim Norm(\\mu_g^{yr}, \\sigma_g)$",
                "$Logit(\\mu_{s}^{plot,yr}) = \\alpha_s + \\alpha_{s}^{plot,yr} + \\beta * z$",
                "",
                "",
                "$log(\\mu_{f_{yr}}) = \\alpha_{f} + \\alpha_{f_{yr}} + (\\beta_f + \\beta_{f_{yr}}) * z$"),
    
    
    R = c("`size_2 ~ size_1 + (1 | year)`",
          "",
          "`surv ~ size_1 + (1 | year) + (1 | plot)`",
          "`surv ~ size_1 + (1 | year) + (1 | plot)`",
          "",
          "`fec ~ size_1 + (size_1 | year)`"),
    
    
    ipmr = c("mu_g_**yr** = g_int + g_int_**yr** + g_slope * z",
             "g = dnorm(z_2, mu_g_**yr**, sd_g)",
             "s_**pl**_**yr** = s_int + s_int_**pl**_**yr** + s_slope * z",
             "s_**pl**_**yr** = s_int + s_int_**pl** + s_int_**yr** + s_slope * z",
             "s = inv_logit(s_**pl**_**yr**)",
             "fec = exp(f_int + f_int_**yr** + (f_slope + f_slope_**yr**) * z)"),
    Model = c(1, 1, 2, 2, 2, 3)
  ),
  format    = "html",
  escape    = FALSE,
  col.names = c("Math Formula", "R Formula", "ipmr", "Model Number"),
  caption   = tab_legend,
  table.attr = styles
)


```


## Hierarchical models with a single random variable {#sim_di_s_k}

These models are pretty common in the IPM literature. They encompass cases where a single site has been sampled over many years, or a sample many sites across one transition. 

This example will use a hypothetical study that spans 5 transitions and has 6 consecutive censuses. The temporal variation will be denoted with a suffix/subscript appended to each term that it modifies ($x_{yr}$/`x_yr`). To limit complexity, let's pretend our exploratory analysis and model selection indicated the best overall models included random year-specifc intercepts for growth ($g_{yr}$) and survival ($s_{yr}$), but not probability of reproduction ($f_p$), recruit production ($f_r$), or the recruit size distribution ($f_d$). We will work with a simple model to start (i.e. 1 continuous state variable, no discrete states). This yields the following IPM ($z,z'$ represent size/height/weight at time $t$ and $t+1$, respectively):

1. $K_{yr}(z', z) = P_{yr}(z',z) + F(z',z)$

2. $P_{yr}(z', z) = s_{yr}(z) * g_{yr}(z',z)$

3. $F(z',z) = f_p(z) + f_r(z) + f_d(z')$

Note that only the $K$ and $P$ kernels get the $yr$ subscript appended to them - they are the only ones that our model selection process decided had substantial year to year variation. Thus, we can actually write the $F$ kernel the exact same way as we would in a simple IPM when we implement the model in `ipmr`.

The vital rate models could be written on paper as follows:

4. Growth

    - $\mu_g = (\alpha_g + \alpha_g^{yr})+ \beta_g * z + e$

    - $z' \sim Norm(\mu_g, \sigma_g)$
5. Survival

    - $logit(s) = (\alpha_s + \alpha_s^{yr}) + \beta_s * z + e$
    
6. Probability of reproducing

    - $logit(f_p) = \alpha_{f_p} + \beta_{f_p} * z$
    
7. Recruit production

    - $log(f_r) = \alpha_{f_r} + \beta_{f_r} * z$
    
8. Recruit size distribution

    - $f_d \sim Norm(\mu_{f_d}, \sigma_{f_d})$

and modelled in R as follows:

```{r eval = FALSE}

library(lme4)
library(ipmr)

grow_mod <- lmer(size_2 ~ size_1 + (1 | year), data = grow_data)

surv_mod <- glmer(surv ~ size_1 + (1 | year), data = surv_data, family = binomial)

repr_mod <- glm(repr ~ size_1, data = repr_data, family = binomial)

recr_mod <- glm(recr ~ size_1, data = recr_data, family = poisson)

rcsz_mu  <- mean(rcsz_data$size_2)
rcsz_sd  <- sd(rcsz_data$size_2)

```

We could then extract the fixed coefficients with the `fixef` method and the conditional modes of the random effects via the `ranef` method: 

```{r eval = FALSE}

beta_gs     <- fixef(grow_mod)

alpha_g_yrs <- ranef(grow_mod)

beta_ss     <- fixef(surv_mod)

alpha_s_yrs <- ranef(surv_mod)


``` 

The non-mixed models can use the `coef` method to extract a vector of coefficients:

```{r eval = FALSE}

repr_coef   <- coef(repr_mod)

recr_coef   <- coef(recr_mod)

```

The next step is to transform these values into something `ipmr` can use. This must always be a **named list** where the names of the list components are the names used in the vital expressions or kernel formula. Transforming the $\beta$s is easier - the output from fixef is always a named vector, so we just use `as.list()` and change the names to whatever we want to use. We then bundle it into one big list with all the fixed coefficients.

```{r eval = FALSE}

g_list <- as.list(beta_gs)
names(g_list) <- c("alpha_g", "beta_g")

s_list <- as.list(beta_ss)
names(s_list) <- c("alpha_s", "beta_s")

f_p_list <- as.list(recr_coef)
names(f_p_list ) <- c("alpha_f_p", "beta_f_p")

f_r_list <- as.list(repr_coef)
names(f_r_list) <- c("alpha_f_r", "beta_f_r")

f_d_list <- list(mu_f_d = rcsz_mu, sigma_f_d = rcsz_sd)

all_fixed_params <- c(g_list, s_list, f_p_list, f_r_list, f_d_list)

```

For the random effects, we probably need to do some a bit more processing, though this really depends on which modelling framework you use and the format of the outputs. For `lme4`, it looks like this:

```{r eval = FALSE}

g_alpha_list <- as.list(unlist(alpha_g_yrs))
names(g_alpha_list) <- paste("alpha_g_", 2001:2006, sep = "")

s_alpha_list <- as.list(unlist(alpha_s_yrs))
names(s_alpha_list) <- paste("alpha_s_", 2001:2006, sep = "")

```

First, we strip away all of `lme4`-related attributes with `unlist()`, then convert it to the flat list format that we need. Next, we set the names Now, we can combine it with our `all_fixed_params` list and we have all of the parameters we need for the kernel functions:

```{r eval = FALSE}

all_params <- c(all_fixed_params, g_alpha_list, s_alpha_list)

```

 
```{r made up parameters for testing chunk below, echo = FALSE, message = FALSE, warning = FALSE}

library(ipmr)

all_fixed_params <- list(
  alpha_g   = 0.2,
  beta_g    = 1.01,
  sigma_g   = 0.2,
  alpha_s   = -0.1,
  beta_s    = 0.3,
  alpha_f_p = -1,
  beta_f_p  = 0.7,
  alpha_f_r = 0.2,
  beta_f_r  = 0.2,
  mu_f_d    = 0.4,
  sigma_f_d = 0.1
)

g_alpha_list <- as.list(rnorm(6)) %>%
  setNames(
    paste('alpha_g_', 2001:2006, sep = "")
  )
s_alpha_list <- as.list(rnorm(6)) %>%
  setNames(
    paste('alpha_s_', 2001:2006, sep = "")
  )

all_params <- c(all_fixed_params, g_alpha_list, s_alpha_list)

```
We are now ready to begin implementing the kernels! This model will be a simple, density independent, stochastic kernel-resampled model (`"simple_di_stoch_kern"` class). The parts where the hierarchical syntax is used are highlighted by comments in the code block:


```{r eval = FALSE}

ex_ipm <- init_ipm("simple_di_stoch_kern") %>%
  define_kernel(
    
    # _yr is appended as a suffix with an underscore. Notice how the formula
    # from 2 is translated into the formula argument and the kernel name
    
    name             = "P_yr",
    family           = "CC",
    formula          = s_yr * g_yr,
    
    # We also modify each parameter name with a suffix as well.
    # Here, I've split out the linear predictor and the inverse logit
    # transformation into separate steps to avoid over cluttering
    
    s_lin_p          = alpha_s + alpha_s_yr + beta_s * z_1,
    s_yr             = 1 / (1 + exp(- s_lin_p)),
    
    # We do the same with growth as we did with survival and the P_yr formula
    
    g_yr             = dnorm(z_2, mu_g_yr, sigma_g),
    mu_g_yr          = alpha_g + alpha_g_yr + beta_g * z_1,
    
    data_list        = all_params,
    states           = list(c("z")),
    
    # We signal that the kernel has hierarchical effects
    
    has_hier_effs    = TRUE,
    
    # And provide the values that each suffix can take as a named list. 
    # The name(s) in this list MUST match the suffix used in the expressions.
    
    levels_hier_effs = list(yr = 2001:2006),
    evict_cor        = TRUE,
    evict_fun        = truncated_distributions("norm", "g_yr")
  ) %>%
  
  # This kernel doesn't get anything special because there are no
  # time-varying parameter values.
  
  define_kernel(
    name          = "F",
    family        = "CC",
    formula       = f_p * f_r * f_d,
    f_p_lin_p     = alpha_f_p + beta_f_p * z_1,
    f_p           = 1 / (1 + exp( -f_p_lin_p)),
    f_r           = exp(alpha_f_r + beta_f_r * z_1),
    f_d           = dnorm(z_2, mu_f_d, sigma_f_d),
    data_list     = all_params,
    states        = list(c("z")),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    
    # name is modified to indicate that the K's will vary from year to year
    
    name             = "K_yr",
    family           = "IPM",
    
    # the formulas are modified to indicate that they will also
    # vary from year to year
    
    K_yr             = P_yr + F,
    n_z_t_1          = K_yr %*% n_z_t,
    states           = list(c("z")),
    has_hier_effs    = TRUE,
    levels_hier_effs = list(yr = 2001:2006),
    evict_cor        = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P_yr", "F", "K_yr"),
      int_rule     = rep("midpoint", 3),
      dom_start    = rep("z", 3),
      dom_end      = rep("z", 3)
    )
  ) %>%
  define_domains(
    z = c(0.1, 10, 50)
  ) %>%
  define_pop_state(
    n_z = runif(50)
  ) %>%
  make_ipm(
    iterate    = TRUE,
    iterations = 100,
    kernel_seq = sample(2001:2006, size = 100, replace = TRUE),
    normalize_pop_size = TRUE
  )

```


## Hierarchical models with discretely and continuously varying parameters {#complicated}

Sometimes, models will have discretely and continuously varying components as functions of different variables. For example, a study could consider multiple sites (discrete component) and temporal fluctations in environment at each site (continuous component). We'll use a hypothetical study that models demography across multiple sites as a function of size and inter-annual climate variability. 

To illustrate the full flexibility of the syntax, we'll use a general model of a perennial plant species. Its seeds can either enter a seed bank or recruit immediately, producing recruits at the next time step. There is a single continuous state variable $z$/`z` that describes the time invariant component of plant demography, and a set of random environmental covariates $\theta$ that modify survival ($s_{site}$/`s_site`), growth ($g_{site}$/`g_site`), probability of reproduction ($f_{{p}_{site}}$/`f_p_site`), and seed production ($f_{{r}_{site}}$/`f_r_site`) at each time. We'll pretend that data from the recruit size distribution was pooled across sites so that the seed bank-related terms are unchanged by space and time.

The seed bank will be age structured and its parameters will be time invariant. Seeds in the first year can either survive ($s_{{sb}_1}$/`s_sb1`) and recruit ($r_{{sb}_1}$), or survive and become two year old seeds. Two year old seeds can either survive ($s_{{sb}_2}$/`s_sb2`) and recruit ($r_{{sb}_2}$/`r_sb2`) or die.  

The full model looks like this:

1. $n(z, t + 1) = \int_L^U [P^{site}(z', z,\theta) + r_i * F^{site}(z',z, \theta)]n(z, t)\mathrm{dz} + \int_L^Us_{{sb}_1} * r_{{sb}_1} * f_d(z')n(sb_1, t)\mathrm{dz} + \int_L^Us_{{sb}_2} * r_{{sb}_2} * f_d(z')n(sb_2, t)\mathrm{dz}$

2. $n(sb_1, t + 1) = \int_L^U(1-r_i) * F^{site}(z',z, \theta)n(z, t)\mathrm{dz}$

3. $n(sb_2, t + 1) = s_{{sb}_1} * (1-r_{{sb}_1})$

The sub kernels are: 

4. $P^{site}(z',z) = s^{site}(z, \theta) * g^{site}(z',z, \theta)$

5. $F^{site}(z',z, \theta) = f_{{p}}^{site}(z, \theta) * f_{r}^{site}(z, \theta) * f_d(z')$

And the size/climate dependent vital rate functions:

6. $logit(s^{site}) = \alpha_{s}^{site} + \beta_s^{site} * z + \theta_s$

7. $g^{site} \sim Norm(\mu_g^{site}, \sigma_g^{site})$

8. $\mu_g^{site} = \alpha_g^{site} + \beta_g^{site} * z + \theta_g$

9. $logit(f_{p}^{site}) = \alpha_{f_p}^{site} + \beta_{f_p}^{site} * z + \theta_{f_p}$

10. $log(f_{r}^{site}) = \alpha_{f_r}^{site} + \beta_{f_r}^{site} * z + \theta_{f_r}$

11. $f_d \sim Norm(\mu_{f_d}, \sigma_{f_d})$

Finally, $\theta$'s are drawn from independent normal distributions for each vital rate. Is this biologically reasonable? Probably not - correlations between vital rates are usually pretty important. But we've made up a plant species, we can make this work too.

12. $\theta_i \sim Norm(0, \sigma_i)$

Note that in this example, the random climate variables ($\theta_x$) are simply modifying the intercept. One could easily incorporate terms that modify slopes by adjusting the functional forms and adding/subtracting parameters as needed.

### Simulating parameters

We have to simulate some parameters for the example code to work. Ideally, model fitting using actual data would fill the space that this is taking up.

We'll use 6 sites for the discrete portion of our variables.

```{r eval = FALSE}

library(ipmr)

# Set up the sites

sites <- LETTERS[1:6]

# We'll add the g sigmas later - we don't want all of the other
# vital rates to have sigmas though!

pars  <- c("alpha", "beta")
vrs   <- c("s", "g", "f_p", "f_r")

vr_df <- expand.grid(pars = pars, vrs = vrs, sites = sites)

vr_nms <- paste(vr_df$pars, vr_df$vrs, vr_df$sites, sep = "_")

# site level parameter vector

site_pars <- numeric(length(vr_nms))

names(site_pars) <- vr_nms

for(i in seq_along(sites)) {
  
  start <- i * 8 - 7
  end   <- i * 8
  
  # s vars
  
  site_pars[start]       <- rnorm(1, mean = -5, sd = 1)
  site_pars[(start + 1)] <- runif(1, min =  1, max = 4)
  
  # g vars
  
  site_pars[(start + 2)] <- rnorm(1, mean = 0, sd = 0.5)
  site_pars[(start + 3)] <- runif(1, 0.85, 1.15)
  
  # f_p vars
  
  site_pars[(start + 4)] <- rnorm(1, mean = -2, sd = 0.5)
  site_pars[(start + 5)] <- runif(1, 1, 3)
  
  # f_r vars
  
  site_pars[(end - 1)] <- rgamma(1, shape = 1)
  site_pars[(end)]     <- runif(1, 0.001, 0.1)
  
}

g_sigmas <- runif(6, 0.3, 0.9)

names(g_sigmas) <- paste("sigma_g_", sites, sep = "")

site_pars <- as.list(c(site_pars, g_sigmas))

# Now, simulate the site- and time-invariant parameters for the model

fixed_pars <- list(
  r_i       = 0.6,
  r_sb1     = 0.2,
  r_sb2     = 0.3,
  s_sb1     = 0.4,
  s_sb2     = 0.1,
  mu_f_d    = 0.7,
  sigma_f_d = 0.2
)

all_pars <- c(fixed_pars, site_pars)

```

Additionally, we need to write a function that samples from the $\theta$ distributions and creates variables with the right names. This function has no parameters - it just pulls values from independent normal distributions. We could modify this to include, for example, temperature and precipitation data, or grazing intensities.

```{r eval = FALSE}

theta_fun <- function() {
  
  out <- list(
    theta_s = rnorm(1, sd = 1)
    theta_g = rnorm(1, sd = 1)
    theta_f_p = rnorm(1, sd = 0.2)
    theta_f_r = rnorm(1, sd = 2)
  )
  
  return(out)
}

```

### Implementing the model

We've written out our model - now we can implement it! We'll use the general, density independent, stochastic parameter resampled machinery for this.


```{r eval = FALSE}

# Implement the model....


```




