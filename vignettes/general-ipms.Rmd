---
title: "General IPMs"
author: "Sam Levin"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette: 
    toc: yes
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{general-ipms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Simple IPMs vs General IPMs

General IPMs are distinguished from simple ones in that they incorporate multiple state variables and/or include transitions between continuous and discrete states. A more specific defintion is provided in Ellner, Childs & Rees, Chapter 6 (2016). 

`ipmr` handles general IPMs fairly differently from `IPMpack` in that it requires the population state to be defined initially and will compute all quantities via iteration. For almost everything, `ipmr` skips building a mega-matrix (though `left_ev()` methods for general IPMs do require it). If the mega-matrix approach is preferable for some reason, the function `format_mega_matrix` can assist with constructing one. An example of how to do that is shown at the end of this vignette.

## A general, density independent, deterministic IPM

We'll start with the least complicated of the general IPMs and build progressively from there. If you've already covered the [Intro to ipmr](https://levisc8.github.io/ipmr/articles/ipmr-introduction.html), then most of this will look pretty familiar. There are three new bits:

1. We are required to `define_pop_state()` before calling `make_ipm()`. 

2. Each kernel that has an integration requires that `d_statevariable` get appended to the kernel `formula`. This is equivalent to the "dz" in $\int_L^U K(z',z) n(z,t) \mathrm{dz}$. `ipmr` automatically generates this variable internally, so there is no need to define it in the `data_list`. We skipped this step in the simple IPMs because it gets appended internally. Unfortunately, it is decidedly less easy to infer the correct state variable to `d_z` with for general IPMs where there may be many continuous and/or discrete states. 

3. We don't necessarily define a formula for $K(ht',ht)$ as we did in the simple IPMs. This is due to the point above about using iteration based methods for computing. Instead, we define how the kernels manipulate different population states at time $t$ to produce new states at time $t+1$.

This example will use a single discrete stage (seed bank, abbreviated `b`) and a single continuous state (height, abbreviated `ht`). Reproduction is time-lagged so all seeds must enter the seed bank (so `stay_discrete` = 0). They can either germinate in the next year, or they can die. Thus, the full model takes the following form:

1. $n(ht', t + 1) = \int_L^U P(ht', ht) n(ht,t)d\mathrm{ht} + b(t) * \int_L^U leave\_discrete(ht') \mathrm{dht'}$  

2. $b(t + 1) = go\_discrete(z) + stay\_discrete$

Below is the code to implement this model.

```{r}

library(ipmr)

# Set up the initial population conditions and parameters

set.seed(2312)

init_pop_vec   <- runif(500)
init_seed_bank <- 20

data_list <- list(
  g_int     = 5.781,
  g_slope   = 0.988,
  g_sd      = 20.55699,
  s_int     = -0.352,
  s_slope   = 0.122,
  s_slope_2 = -0.000213,
  f_r_int   = -11.46,
  f_r_slope = 0.0835,
  f_s_int   = 2.6204,
  f_s_slope = 0.01256,
  f_d_mu    = 5.6655,
  f_d_sd    = 2.0734,
  e_p       = 0.15,
  g_i       = 0.5067
)

# The lower and upper bounds for the continuous state variable and the number
# of meshpoints for the midpoint rule integration.

L <- 1.02
U <- 624
n <- 500

# Initialize the state list and add some helper functions. The survival function
# in this model is a quadratic function.

states <- list(c('ht', 'sb'))

inv_logit <- function(int, slope, sv) {
  1/(1 + exp(-(int + slope * sv)))
}

inv_logit_2 <- function(int, slope, slope_2, sv) {
  1/(1 + exp(-(int + slope * sv + slope_2 * sv ^ 2)))
}

general_ipm <- init_ipm("general_di_det") %>%
  define_kernel(
    name          = "P",
    
    # We add d_ht to formula to make sure integration is handled correctly.
    # This variable is generated internally by make_ipm(), so we don't need
    # to do anything else.
    
    formula       = s_g_mult(s, g) * d_ht,
    
    # The family argument tells ipmr what kind of transition this kernel describes.
    # it can be "CC" for continuous -> continuous, "DC" for discrete -> continuous
    # "CD" for continuous -> discrete, or "DD" for discrete -> discrete.
    
    family        = "CC",
    
    # The rest of the arguments are exactly the same as in the simple models
    
    g             = dnorm(ht_2, g_mu, g_sd),
    g_mu          = g_int + g_slope * ht_1,
    s             = inv_logit_2(s_int, s_slope, s_slope_2, ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict         = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'g')
  ) %>%
  define_kernel(
    name          = "go_discrete",
    formula       = f_r * f_s * g_i,
    family        = 'CD',
    f_r           = inv_logit(f_r_int, f_r_slope, ht_1),
    f_s           = exp(f_s_int + f_s_slope * ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_kernel(
    name    = 'stay_discrete',
    
    # In this case, seeds in the seed bank either germinate or die, but they 
    # do not remain for multipe time steps. This can be adjusted as needed.
    
    formula = 0,
    family  = "DD",
    states  = states,
    evict = FALSE
  ) %>%
  define_kernel(
    name          = 'leave_discrete',
    formula       = e_p * f_d * d_ht,
    f_d           = dnorm(ht_2, f_d_mu, f_d_sd),
    family        = 'DC',
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict         = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'f_d')
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    
    # We don't really define a mega-K as we do with simple models, but rather
    # describe how the state at t is modified by the sub-kernels to produce
    # the state at t + 1. 
    
    n_b_t_1       = stay_discrete %*% n_b_t  + go_discrete %*% n_ht_t,
    n_ht_t_1      = leave_discrete %*% n_b_t + P %*% n_ht_t,
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P", "go_discrete", "stay_discrete", "leave_discrete", "K"),
      int_rule     = c(rep("midpoint", 5)),
      dom_start    = c('ht', "ht", NA_character_, NA_character_, "ht"),
      dom_end      = c('ht', NA_character_, NA_character_, 'ht', 'ht')
    )
  ) %>%
  define_domains(
    ht = c(L, U, n)
  ) %>%
  define_pop_state(
    pop_vectors = list(
      n_ht = init_pop_vec,
      n_b  = init_seed_bank
    )
  ) %>%
  make_ipm(iterations = 100,
           usr_funs = list(inv_logit   = inv_logit,
                           inv_logit_2 = inv_logit_2))


# lambda is a generic function to compute per-capita growth rates. It has a number
# of different options which are explored in the "Generics" vignette (still to be
# written!).

lambda(general_ipm)[100]

# If we are worried about whether or not the model converged to stable
# dynamics, we can call lambda with type_lambda = 'all' and examine the final
# iterations to make sure it has. The snippet below prints lambda from the 
# the last 10 iterations of the model

lambdas <- lambda(general_ipm, type_lambda = 'all')

lambda_ind <- seq((length(lambdas) - 10), length(lambdas), by = 1)

last_10 <- lambdas[lambda_ind]

# If it's converged, then this should return TRUE

isTRUE(
  all.equal(
    range(last_10)[1], range(last_10)[2]
  )
)



```

## General hierarchical models



## General models with continuously varying environments



## Code to construct your own mega-matrices


