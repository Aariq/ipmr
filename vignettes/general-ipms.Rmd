---
title: "General IPMs"
author: "Sam Levin"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette: 
    toc: yes
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{General IPMs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Simple IPMs vs General IPMs

General IPMs are distinguished from simple ones in that they incorporate multiple state variables and/or include transitions between continuous and discrete states. A more specific defintion is provided in Ellner, Childs & Rees, Chapter 6 (2016). 

`ipmr` handles general IPMs fairly differently from `IPMpack` in that it requires the population state to be defined initially and will compute most quantities via iteration. For almost everything, `ipmr` skips building a mega-matrix (though `left_ev()` methods for general IPMs do require it). If the mega-matrix approach is preferable for some reason, the function `format_mega_matrix` is available to assist with constructing one. An example of how to do that is shown at the end of this vignette.

## A general, density independent, deterministic IPM

We'll start with the least complicated of the general IPMs and build progressively from there. If you've already covered the [Intro to ipmr](https://levisc8.github.io/ipmr/articles/ipmr-introduction.html), then most of this will look pretty familiar. There are three new bits:

1. We are required to `define_pop_state()` before calling `make_ipm()`. 

2. Each kernel that has an integration requires that `d_statevariable` get appended to the kernel `formula`. This is equivalent to the "dz" in $\int_L^U K(z',z) n(z,t) \mathrm{dz}$. `ipmr` automatically generates this variable internally, so there is no need to define it in the `data_list`. We skipped this step in the simple IPMs because it gets appended internally. Unfortunately, it is decidedly less easy to infer the correct state variable to `d_z` with for general IPMs where there may be many continuous and/or discrete states. 

3. We don't necessarily define a formula for $K(z',z)$ as we did in the simple IPMs. This is due to the point above about using iteration based methods for computing. Instead, we define how the kernels manipulate different population states at time $t$ to produce new states at time $t+1$.

This example will use a single discrete stage (seed bank, abbreviated `b`) and a single continuous state (height, abbreviated `ht`). Reproduction is time-lagged so all seeds must enter the seed bank . They can either germinate in the next year, or they can die (so `stay_discrete` = 0). Thus, the full model takes the following form:

1. $n(z', t + 1) = \int_L^U P(z', z) n(z,t)d\mathrm{z} + b(t) * \int_L^U leave\_discrete(z') \mathrm{dz'}$  

2. $b(t + 1) = go\_discrete(z) + stay\_discrete$

3. $P(z',z) = s * g$

4. $go\_discrete(z) = f_s * f_r * g_i$

5. $leave\_discrete(z') = e_p * f_d(z')$

6. $stay\_discrete = 0$

The vital rates functions and example code to fit them are:

1. survival (`s`): A logistic regression

    - Example code: `glm(surv ~ ht_1, data = my_surv_data, family = binomial())`

2. growth (`g`): A linear regression

    - example code: `lm(ht_2 ~ ht_1, data = grow_data)`
    
3. flowering probability (`f_r`): A logistic regression

    - example code: `glm(repro ~ ht_1, data = my_repro_data, family = binomial())`
    
4. seed production (`f_s`): A Poisson regression

    - example code: `glm(seeds ~ ht_1, data = my_seed_data, family = poisson())`
    
5. Recruit size distribution (`f_d`): A normal distribution with mean `f_d_mu` and standard deviation `f_d_sd`.

    - example code: `f_d_mu <- mean(my_recr_data$ht_2, na.rm = TRUE)` and `f_d_sd <- sd(my_rer_data$ht_2, na.rm = TRUE)`.
    
6. germination (`g_i`) and establishment (`e_p`) are constants

    - example code: `g_i <- mean(my_germ_data, na.rm = TRUE)` and `e_p <- mean(my_est_data, na.rm = TRUE)`

Below is the code to implement this model. First, we define our our parameters in a list.

```{r eval = FALSE}

library(ipmr)

# Set up the initial population conditions and parameters

data_list <- list(
  g_int     = 5.781,
  g_slope   = 0.988,
  g_sd      = 20.55699,
  s_int     = -0.352,
  s_slope   = 0.122,
  s_slope_2 = -0.000213,
  f_r_int   = -11.46,
  f_r_slope = 0.0835,
  f_s_int   = 2.6204,
  f_s_slope = 0.01256,
  f_d_mu    = 5.6655,
  f_d_sd    = 2.0734,
  e_p       = 0.15,
  g_i       = 0.5067
)


```

Next, we set up the upper (`U`) and lower (`L`) bounds for integration, define the number of meshpoints for integration (`n`). We also define initial population vectors for both `b` and `ht`, set up our `states` list, and a couple functions to pass into the model.

```{r eval = FALSE}
# The lower and upper bounds for the continuous state variable and the number
# of meshpoints for the midpoint rule integration.

L <- 1.02
U <- 624
n <- 500

set.seed(2312)

init_pop_vec   <- runif(500)
init_seed_bank <- 20

# Initialize the state list and add some helper functions. The survival function
# in this model is a quadratic function.

states <- list(c('ht', 'sb'))

inv_logit <- function(int, slope, sv) {
  1/(1 + exp(-(int + slope * sv)))
}

inv_logit_2 <- function(int, slope, slope_2, sv) {
  1/(1 + exp(-(int + slope * sv + slope_2 * sv ^ 2)))
}
```

Now, we're ready to begin making the IPM kernels

```{r eval = FALSE}

general_ipm <- init_ipm("general_di_det") %>%
  define_kernel(
    name          = "P",
    
    # We add d_ht to formula to make sure integration is handled correctly.
    # This variable is generated internally by make_ipm(), so we don't need
    # to do anything else.
    
    formula       = s_g_mult(s, g) * d_ht,
    
    # The family argument tells ipmr what kind of transition this kernel describes.
    # it can be "CC" for continuous -> continuous, "DC" for discrete -> continuous
    # "CD" for continuous -> discrete, or "DD" for discrete -> discrete.
    
    family        = "CC",
    
    # The rest of the arguments are exactly the same as in the simple models
    
    g             = dnorm(ht_2, g_mu, g_sd),
    g_mu          = g_int + g_slope * ht_1,
    s             = inv_logit_2(s_int, s_slope, s_slope_2, ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'g')
  ) %>%
  define_kernel(
    name          = "go_discrete",
    formula       = f_r * f_s * g_i,
    
    # Note that now, family = "CD" becuase it denotes a continuous -> discrete transition
    
    family        = 'CD',
    f_r           = inv_logit(f_r_int, f_r_slope, ht_1),
    f_s           = exp(f_s_int + f_s_slope * ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_kernel(
    name    = 'stay_discrete',
    
    # In this case, seeds in the seed bank either germinate or die, but they 
    # do not remain for multipe time steps. This can be adjusted as needed.
    
    formula = 0,
    
    # Note that now, family = "DD" becuase it denotes a discrete -> discrete transition
    
    family  = "DD",
    states  = states,
    evict_cor = FALSE
  ) %>%
  define_kernel(
    
    # Here, the family changes to "DC" because it is the discrete -> continuous 
    # transition
    
    name          = 'leave_discrete',
    
    # We append d_ht here as well, becuase we need to integrate over the 
    # the recruit size distribution.
    
    formula       = e_p * f_d * d_ht,
    f_d           = dnorm(ht_2, f_d_mu, f_d_sd),
    family        = 'DC',
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'f_d')
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    
    # We don't really define a mega-K as we do with simple models, but rather
    # describe how the state at t is modified by the sub-kernels to produce
    # the state at t + 1. 
    
    n_b_t_1       = stay_discrete %*% n_b_t  + go_discrete %*% n_ht_t,
    n_ht_t_1      = leave_discrete %*% n_b_t + P %*% n_ht_t,
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P", "go_discrete", "stay_discrete", "leave_discrete", "K"),
      int_rule     = c(rep("midpoint", 5)),
      dom_start    = c('ht', "ht", NA_character_, NA_character_, "ht"),
      dom_end      = c('ht', NA_character_, NA_character_, 'ht', 'ht')
    )
  ) %>%
  define_domains(
    
    # We can pass the variables we created above into define_domains
    
    ht = c(L, U, n)
  ) %>%
  define_pop_state(
    
    # We can also pass them into define_pop_state
    
    pop_vectors = list(
      n_ht = init_pop_vec,
      n_b  = init_seed_bank
    )
  ) %>%
  # make_ipm() has iterate = TRUE by default for general IPMs.
  make_ipm(iterations = 100,
           usr_funs = list(inv_logit   = inv_logit,
                           inv_logit_2 = inv_logit_2))


# lambda is a generic function to compute per-capita growth rates. It has a number
# of different options which are explored in the "Generics" vignette (still to be
# written!).

lambda(general_ipm, comp_method = 'pop_size')[100]

# If we are worried about whether or not the model converged to stable
# dynamics, we can use the exported utility is_conv_to_asymptotic. The default
# tolerance for convergence is 1e-10, but can be changed with the 'tol' argument.

is_conv_to_asymptotic(general_ipm, tol = 1e-10)


```

## General models for discretely varying environments

Discretely varying parameters can be used to construct general IPMs with little additional effort. These are typically the result of fitting a set of fixed effects vital rate models that include both continuous predictors for size/state and categorical variables like treatment or maturation state. They can also result from mixed effects models, for example, working with conditional modes for a random intercept corresponding to year or site.

If you've already read the Intro to `ipmr` article and the example above, then there aren't any new concepts to introduce here. We just need to combine the hierarchical notation with the key points listed above (add `d_z`, `define_pop_state()`, and forget about mega-matrices). Below is an example showing how all of these come together.

## General models with continuously varying environments


## Code to construct your own mega-matrices

Iteration is all fine and good, and can be used to get most quantities. Issues arise when we need to, say, transpose a model (e.g. to compute the left eigenvector of the full discretized model). `ipmr` doesn't define a strict order in which to define expressions in `define_k()`, providing flexibility to define these however you see fit. The cost is that, internally, `ipmr` has no idea where things should go when transposing the model. This is where `format_mega_matrix()` comes in.

`format_mega_matrix` takes an IPM object and a vector of symbols (for interactive use) or a character version of the expression (for programming) showing where each sub-kernel should go. It works in **ROW MAJOR order**. This example will use the model from the general deterministic example at the top of the article.

First, re-run the model to create the IPM object (if you haven't already).

```{r eval = FALSE}

data_list <- list(
  g_int     = 5.781,
  g_slope   = 0.988,
  g_sd      = 20.55699,
  s_int     = -0.352,
  s_slope   = 0.122,
  s_slope_2 = -0.000213,
  f_r_int   = -11.46,
  f_r_slope = 0.0835,
  f_s_int   = 2.6204,
  f_s_slope = 0.01256,
  f_d_mu    = 5.6655,
  f_d_sd    = 2.0734,
  e_p       = 0.15,
  g_i       = 0.5067
)


L <- 1.02
U <- 624
n <- 500

set.seed(2312)

init_pop_vec   <- runif(500)
init_seed_bank <- 20

# Initialize the state list and add some helper functions. The survival function
# in this model is a quadratic function.

states <- list(c('ht', 'sb'))

inv_logit <- function(int, slope, sv) {
  1/(1 + exp(-(int + slope * sv)))
}

inv_logit_2 <- function(int, slope, slope_2, sv) {
  1/(1 + exp(-(int + slope * sv + slope_2 * sv ^ 2)))
}

general_ipm <- init_ipm("general_di_det") %>%
  define_kernel(
    name          = "P",
    formula       = s_g_mult(s, g) * d_ht,
    family        = "CC",
    g             = dnorm(ht_2, g_mu, g_sd),
    g_mu          = g_int + g_slope * ht_1,
    s             = inv_logit_2(s_int, s_slope, s_slope_2, ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'g')
  ) %>%
  define_kernel(
    name          = "go_discrete",
    formula       = f_r * f_s * g_i,
    family        = 'CD',
    f_r           = inv_logit(f_r_int, f_r_slope, ht_1),
    f_s           = exp(f_s_int + f_s_slope * ht_1),
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_kernel(
    name      = 'stay_discrete',
    formula   = 0,
    family    = "DD",  
    states    = states,
    evict_cor = FALSE
  ) %>%
  define_kernel(
    name          = 'leave_discrete',
    formula       = e_p * f_d * d_ht,
    f_d           = dnorm(ht_2, f_d_mu, f_d_sd),
    family        = 'DC',
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions('norm',
                                            'f_d')
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    n_b_t_1       = stay_discrete %*% n_b_t  + go_discrete %*% n_ht_t,
    n_ht_t_1      = leave_discrete %*% n_b_t + P %*% n_ht_t,
    data_list     = data_list,
    states        = states,
    has_hier_effs = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P", "go_discrete", "stay_discrete", "leave_discrete", "K"),
      int_rule     = c(rep("midpoint", 5)),
      dom_start    = c('ht', "ht", NA_character_, NA_character_, "ht"),
      dom_end      = c('ht', NA_character_, NA_character_, 'ht', 'ht')
    )
  ) %>%
  define_domains(
    ht = c(L, U, n)
  ) %>%
  define_pop_state(
    pop_vectors = list(
      n_ht = init_pop_vec,
      n_b  = init_seed_bank
    )
  ) %>%
  make_ipm(iterations = 100,
           usr_funs = list(inv_logit   = inv_logit,
                           inv_logit_2 = inv_logit_2))
```

Now, we specify which kernel belongs where in row major order, using a call to `c()`.

```{r eval = FALSE}

mega_mat <- format_mega_matrix(ipm = general_ipm,
                               mega_mat = c(
                                 stay_discrete, go_discrete,
                                 leave_discrete, P
                               ))

# These values should be almost identical, so this should ~0

Re(eigen(mega_mat)$values[1]) - lambda(general_ipm)[100]


```

Say you wanted to program with this function. Passing bare expression is difficult programatically, and how to do that is not really within the scope of this vignette (though if you're interested in learning how, [this](https://dplyr.tidyverse.org/articles/programming.html) is a good start). `format_mega_matrix` also accepts text strings in the same format as above. 

```{r eval = FALSE}

# Get the names of each sub_kernel
sub_k_nms     <- names(general_ipm$sub_kernels)

mega_mat_text <- paste('c(', sub_k_nms[3], ', ', sub_k_nms[2], ', ',
                       sub_k_nms[4], ', ', sub_k_nms[1], ')' , sep = "")

mega_mat_2 <- format_mega_matrix(general_ipm,
                                 mega_mat_text)

# Should be TRUE
identical(mega_mat, mega_mat_2)

```


