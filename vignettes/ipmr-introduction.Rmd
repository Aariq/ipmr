---
title: "Introduction to ipmr"
author: "Sam Levin"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette: 
    toc: yes
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview
  
`ipmr` is a package for implementing integral projection models of varying degrees of complexity. It uses mathematical-ish expressions to build up the iteration kernels from smaller pieces, as well as helpers to ensure that models are implemented correctly. Finally, it provides machinery for stochastic simulations. basic analyses, and model diagnostics. More complicated analysis functions are being implemented in the [irage package](https://github.com/levisc8/irage).
  
**This package does not help with fitting regression models to demographic data!** This is a distinct enough problem that it should not be in the purview of this package - and there are much better tools out there already that can do a far better job helping you with that than I can. Some of the best are `lme4`, `brms`, `mgcv`, and `nlme`. `IPMpack` handles the regression modelling and IPM construction, though be forewarned, there are certain types of models that you simply cannot construct with it! 
  
## Types of models in `ipmr`
  
The first step of defining a model in `ipmr` is to initialize the model using `init_ipm()`. This function takes a single argument: `model_class`. The `model_class` defines the basic infrastructure that will be available for subsequent analyses and helps make sure the kernels are correctly implemented from the underlying vital rates. `model_class` should be a character string with at least 3 (but possibly 4) entries separated by underscores (`_`). Below, the are the possible entries for each position.

- Position 1: `"simple"`/`"general"`

    + A.  **simple**: This describes an IPM with a single continuous state variable and no discrete stages. 

    + B.  **general**: This describes and IPM with either more than one continuous state variable, one or more discrete stages, or both of the above. Basically, anything other than an IPM with a single continuous state variable.

- Position 2: `"di"`/`"dd"`

    + A. **di**: This is used to denote a density-independent IPM.

    + B. **dd**: This is used to denote a density-dependent IPM.

- Position 3: `"det"`/`"stoch"`

    + A. **det**: This is used to denote a deterministic IPM. If this is used in the third position of `model_class`, there should not be a fourth entry.

    + B. **stoch**: This is used to denote a stochastic IPM. If this is used in the third position of `model_class`, there should always be a fourth entry. The two possibilities for the fourth are described next.

- Position 4: `"kern"`/`"param"`

    + A. **kern**: This describes an IPM with discretely varying parameters such that their values are known before the model is specified. This is usually the case with models that estimate random year/site effects and for which defining a multivariate joint distribution to sample parameters from is not desirable/needed. These models can be a bit more computationally efficient than the `param` alternative because all kernels can be constructed before the iteration procedure begins, as opposed to requiring reconstruction for every single iteration. 

    + B. **param**: This describes an IPM with parameters that are re-sampled from some distribution at each iteration of the model (usually a multivariate joint distribution). This can be a multivariate normal defined by covarying slopes and intercepts, or posterior distribution from a Bayesian model. All that is required is that the parameters for the distribution are specified and that the function that generates the parameters at each iteration returns named lists that correspond to the parameter names in the model. Jump down to the `"simple_di_stoch_param"` example for some inspiration in writing those.

With the type of model selected, the `model_class` becomes a string and the call to `init_ipm` is composed like so: `init_ipm(model_class = "position1_position_2_position3_position4")`. 

The rest of this vignette will deal with simple, density independent IPMs. If you already know that you need a general IPM (e.g. an IPM with discrete stages, or multiple continuous state variables), hop over [here](https://levisc8.github.io/ipmr/articles/general-ipms.html) for an introduction to these.

## Specifying a simple deterministic IPM without density dependence

This is the simplest model that `ipmr` works with. It is an IPM with a single continuous state variable, no density dependent functions, and parameters that define a single iteration kernel (as opposed to many iteration kernels). We'll walk through the steps required to implement such an IPM before getting into more complex models. If you already know that you have multiple continuous state variables and/or some discrete states, you can skip this part and head over to the [General IPMs page](https://levisc8.github.io/ipmr/articles/general-ipms.html) and get started there.

The vital rate functions and code that might be used to generate models corresponding to them are below. 

1. Survival (`s`): a generalized linear model w/ a logit link.

    - Example model formula: `glm(surv ~ size_1, data = my_surv_data, family = binomial())`

2. Growth (`g`): a linear model with a Normal error distribution.

    - Example model formula: `lm(size_2 ~ size_1, data = my_grow_data)`

3. Pr(flowering) (`f_r`): a generalized linear model w/ a logit link.

    - Example model formula: `glm(flower ~ size_1, data = my_repro_data, family = binomial())`

4. Seed production (`f_s`): a generalized linear model w/ log link.

    - Example model formula: `glm(seeds ~ size_1, data = my_flower_data, family = poisson())`

5. Recruit size distribution (`f_d`): a normal distribution w parameters `mu_fd` (mean) and `sd_fd` (standard deviation).

    - Example code: `mu_fd = mean(my_recr_data$size_2, na.rm = TRUE)` and `sd_fd = sd(my_recr_data$size_2, na.rm = TRUE)`


### Defining kernels

The next step is to define the actual kernels comprising the IPM. These are defined individually with calls to `define_kernel()`. 

``` {r eval = FALSE}

my_ipm <- init_ipm('simple_di_det')

my_ipm <- define_kernel(
  proto_ipm = my_ipm,
  name      = "P",
  
  # The formula describes how the vital rates generate the kernel
  
  formula   = s * g,
  
  # The family describes the type of transition that kernel produces. See below.
  
  family    = "CC",
  
  # Perform the inverse logit transformation to get the probability of survival
  
  s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
  
  # Growth has two terms - the mean and the standard deviation. We model the mean 
  # as a function of size. The standard deviation is constant.
  
  g         = dnorm(dbh_2, g_mu, g_sd),
  g_mu      = g_int + g_slope * dbh_1,
  
  data_list = list(
    s_int     = 0.2,   # coef(my_surv_mod)[1]
    s_slope   = 0.5,   # coef(my_surv_mod)[2]
    g_int     = 0.1,   # coef(my_grow_mod)[1]
    g_slope   = 1.033, # coef(my_grow_mod)[2]
    g_sd      = 2.2    # sd(resid(my_grow_mod))
  ),
  
  # states should be a list of the state variables that the kernel operates on
  
  states        = list(c('dbh')),
  has_hier_effs = FALSE,
  evict_cor     = TRUE,
  evict_fun     = truncated_distributions("norm", "g")
) 

```

This function takes the kernel `name`, the mathematical `formula` for the kernel, and expressions for the vital rates that comprise it (`s`, `g`, `g_mu`).

The `family` argument refers to the type of transition that the kernel describes and has 5 options: 

1. "CC" - a continuous -> continuous transition

2. "CD" - a continuous -> discrete transition

3. "DC" - a discrete -> continuous transition

4. "DD" - a discrete -> discrete transition

5. "IPM" - This is reserved for the `define_k()` function introduced below.

These aren't important for `simple_*` IPMs, as all transitions are from a continuous state to a continuous state, but they are required for `general_*` IPMs to build properly. As such, they are required to be specified for *all* kernels. 

In addition, the `data_list` argument holds the constant parameters (e.g. regression coefficient estimates). 

The `states` argument refers to the state variables in use. `ipmr` internally appends an `_1` and `_2` to the names in `states`, and creates variables for them that are the meshpoints for integration. These correspond to time *t* and *t+1*, and can be used in vital rate expressions to indicate which state at which time is being acted upon. 

`has_hier_effs` is a logical indicating whether or not the model contains hierarchical effects. In this example, the model is a simple, deterministic one and so this is set to `FALSE`. However, `*_stoch_kern` kernels will almost always need this to be set to `TRUE`, and `*_stoch_param` models can also use them. See the next example for a demonstration of that syntax (there will also be a whole vignette at some point, just not there yet).

`evict_cor` refers to whether or not to correct for eviction in the kernel. If this is set to `TRUE`, then you must supply a function specifying which expressions need to be corrected. `ipmr` provides `truncated_distributions` for now, though others will eventually be implemented as well. Subsequent additions are mainly to accomadate models in PADRINO, and I suggest sticking to `truncated_distributions` for user-defined models in almost all cases.

Finally, `ipmr` is meant to be pipe-friendly, so all functions prefixed with `define_*` take a `proto_ipm` as their first argument and always return a `proto_ipm`, meaning operations can be chained together with the `%>%` operator. Note that this function is included in `ipmr`, so there is no need to load any other packages to access it (e.g. `dplyr` or `magrittr`). The first chunk below is equivalent to the chunk above.


``` {r eval = FALSE}

# the %>% takes the result of the first operation and passes it as the first
# argument to the second function.

my_ipm <- init_ipm('simple_di_det') %>% 
  define_kernel(
    name      = "P",
    formula   = s_g_mult(s, g),
    family    = "CC",
    s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
    g         = dnorm(dbh_2, g_mu, g_sd),
    g_mu      = g_int + g_slope * dbh_1,
    
    data_list = list(
      s_int     = 0.2,
      s_slope   = 0.5,
      g_int     = 0.1,
      g_slope   = 1.033,
      g_sd      = 2.2
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) 

my_ipm <- define_kernel(
  proto_ipm = my_ipm,
  name      = "F",
  formula   = f_r * f_s * f_d,
  family    = "CC",
  
  # Again, we use the inverse logit transformation to compute pr(flowering)
  f_r       = 1/(1 + exp(-(f_r_int + f_r_slope * dbh_1))),
  
  # We exponentiate this because of the log link in our seed production model
  f_s       = exp(f_s_int + f_s_slope * dbh_1),
  
  # In this case, both the mean and standard deviation are constants
  f_d       = dnorm(dbh_2, f_d_mu, f_d_sd),
  data_list = list(
    f_r_int   = 0.5,   # coef(my_flower_mod)[1]
    f_r_slope = 0.1,   # coef(my_flower_mod)[2]
    f_s_int   = 1.2,   # coef(my_seed_mod)[1]
    f_s_slope = 0.03,  # coef(my_seed_mod)[2]
    f_d_mu    = 1.2,   # mean(my_recr_data$size_2, na.rm = TRUE)
    f_d_sd    = 0.7    # sd(my_recr_data$size_2, na.rm = TRUE)
  ),
  states        = list(c('dbh')),
  has_hier_effs = FALSE,
  evict_cor     = TRUE,
  evict_fun     = truncated_distributions("norm", "f_d")
)

```

The `F` kernel has the same form as the `P` kernel. We are now ready to define the `K` kernel, sometimes referred to as the iteration kernel.

### Defining an iteration kernel

These kernels are treated slightly differently in `ipmr`. They are defined with their own function, `define_k()`. It has fewer arguments than `define_kernel`. 

The rest of the model definition sequence in this example will use the `%>%` operator. *It is not a requirement* - you can assign a value to `my_ipm` at each step and the model will be identical. Choose which ever process is more comfortable for you!

``` {r eval = FALSE}

my_ipm <- init_ipm('simple_di_det') %>%
  define_kernel(
    name      = "P",
    formula   = s_g_mult(s, g),
    family    = "CC",
    s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
    g         = dnorm(dbh_2, g_mu, g_sd),
    g_mu      = g_int + g_slope * dbh_1,
    
    data_list = list(
      s_int     = 0.2,
      s_slope   = 0.5,
      g_int     = 0.1,
      g_slope   = 1.033,
      g_sd      = 2.2
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) %>% 
  define_kernel(
    name      = "F",
    formula   = f_r * f_s * f_d,
    family    = "CC",
    f_r       = 1/(1 + exp(-(f_r_int + f_r_slope * dbh_1))),
    f_s       = exp(f_s_int + f_s_slope * dbh_1),
    f_d       = dnorm(dbh_2, f_d_mu, f_d_sd),
    data_list = list(
      f_r_int   = 0.5,
      f_r_slope = 0.1,
      f_s_int   = 1.2,
      f_s_slope = 0.03,
      f_d_mu    = 1.2,
      f_d_sd    = 0.7
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    K             = P + F,           # define_k uses ... instead of formula = P + F
    data_list     = list(),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = FALSE
  ) 

```

The `name` argument of `define_k` should always be one of `K`, `k`, or `K_suffix`, where `suffix` corresponds to a hierarchical effect (more on those in the discretely varying environments section). The `...` take over the role that `formula` took in the previous kernels. This is to facilitate passing multiple expressions for the iteration kernel when defining more complex models (i.e. how the population state changes with time or an age x size model). In this example, the left hand side of the expression should match the `name` because we aren't actually iterating this kernel with a population vector. Note that there are no additional parameters that need to be passed to complete the construction of the kernel, so `data_list` can be empty. It never hurts to pass the same `data_list` containing all of the parameters to each call to `define_k()`/`define_kernel()` though - if the parameter aren't used in a given kernel's definition, they are simply ignored. Finally, we specify `evict_cor = FALSE` in the `K` because we've already corrected for it in the previous kernel definitions.

### Defining the implementation arguments (`impl_args`)

Next, we need to define how the kernels are implemented numerically. This is where we define the integration rule `int_rule`, the domain the kernels begin on `dom_start`, and the domain that they finish on `dom_end`. This is done with the `define_impl()` function. It takes a named list where names correspond to the kernels, and each entry is itself a list of length 3 containing slots `int_rule`, `dom_start`, and `dom_end`. Because this is a bit specific, there is a helper function that can be called within `define_impl` or called before initializing the IPM to make sure everything is formatted correctly - `make_ipml_args_list()`.

The first argument to the `make_ipml_args_list()` function is `kernel_names`. This is a character vector with kernel names for which the implementation arguments are being supplied. 

Next, `int_rule` is a character vector, and currently `'midpoint'` is the only option that is implemented. `'trapezoid'` and `'g-l'` (Gauss-Legendre) are on the to-do list. Additional rules may be added if there is more demand for certain ones (e.g. cumulative density functions like in `IPMpack`). 

`dom_start` and `dom_end` are always the same in `simple_*` IPMs. In `general_*` ones, they may be different, or, if describing a transition involving a discrete state, they may be `NA`. For all non-`NA` `dom_*`'s, they are one of the variables in the `states` list. `dom_start`'s have `_1` and `dom_end`'s have `_2`  appended to them internally, so they may be referenced by vital rate functions without explicitly creating a variable for them.

Elements of each vector in each argument in `make_impl_args_list()` are matched by position. Thus, if you specify `"K"` as the first entry in `kernel_names`, then the first entries of `int_rule`, `dom_start`, and `dom_end` should all correspond to the `K` kernel. If you specify `"P"` as the second entry, the second entries in `int_rule`, `dom_start`, and `dom_end` should be the rules that correspond to the `P` kernel, and so on.

It is important to note that `make_impl_args_list` *does not return a `proto_ipm`*. Thus, it must either be called before beginning the model definition, or inside of `define_impl`! 

```{r eval = FALSE}

# Alternative one - call make_impl_args_list() before beginning the IPM creation pipe

impl_args <- make_impl_args_list(
  kernel_names = c("K", "P", "F"),
  int_rule     = rep("midpoint", 3),
  dom_start    = rep("dbh", 3),
  dom_end      = rep("dbh", 3)
)

my_ipm <- init_ipm('simple_di_det') %>%
  define_kernel(
    name      = "P",
    formula   = s_g_mult(s, g),
    family    = "CC",
    s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
    g         = dnorm(dbh_2, g_mu, g_sd),
    g_mu      = g_int + g_slope * dbh_1,
    
    data_list = list(
      s_int     = 0.2,
      s_slope   = 0.5,
      g_int     = 0.1,
      g_slope   = 1.033,
      g_sd      = 2.2
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor        = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) %>% 
  define_kernel(
    name      = "F",
    formula   = f_r * f_s * f_d,
    family    = "CC",
    f_r       = 1/(1 + exp(-(f_r_int + f_r_slope * dbh_1))),
    f_s       = exp(f_s_int + f_s_slope * dbh_1),
    f_d       = dnorm(dbh_2, f_d_mu, f_d_sd),
    data_list = list(
      f_r_int   = 0.5,
      f_r_slope = 0.1,
      f_s_int   = 1.2,
      f_s_slope = 0.03,
      f_d_mu    = 1.2,
      f_d_sd    = 0.7
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    K             = P + F,
    data_list     = list(),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = FALSE
  )  %>%
  # Alternative 2, put the call to make_impl_args_list() inside of define_impl(). 
  define_impl(
    make_impl_args_list(
      kernel_names = c("K", "P", "F"),
      int_rule     = rep("midpoint", 3),
      dom_start    = rep("dbh", 3),
      dom_end      = rep("dbh",3)
    )
  )

```

### Defining domains for state variables

The final essential step in creating an IPM with `ipmr` is to define the domain of each state variable in the `states` list. This is done with the `define_domains()` function. When the `int_rule` is `"midpoint"`, this takes a named set of vectors that have 3 entries each. The name corresponds to the `state` it is describing, the first entry is the lower bound, the second the upper bound, and the third is the number of meshpoints.

Note that for other `int_rule`s, the vectors associated with each domain will look different. However, those are not yet implemented and so beyond the scope of this vignette for now.

```{r eval = FALSE}

# Alternative one - call make_impl_args_list() before beginning the IPM creation pipe

impl_args <- make_impl_args_list(
  kernel_names = c("K", "P", "F"),
  int_rule     = rep("midpoint", 3),
  dom_start    = rep("dbh", 3),
  dom_end      = rep("dbh", 3)
)

my_ipm <- init_ipm('simple_di_det') %>%
  define_kernel(
    name      = "P",
    formula   = s_g_mult(s, g),
    family    = "CC",
    s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
    g         = dnorm(dbh_2, g_mu, g_sd),
    g_mu      = g_int + g_slope * dbh_1,
    
    data_list = list(
      s_int     = 0.2,
      s_slope   = 0.5,
      g_int     = 0.1,
      g_slope   = 1.033,
      g_sd      = 2.2
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) %>% 
  define_kernel(
    name      = "F",
    formula   = f_r * f_s * f_d,
    family    = "CC",
    f_r       = 1/(1 + exp(-(f_r_int + f_r_slope * dbh_1))),
    f_s       = exp(f_s_int + f_s_slope * dbh_1),
    f_d       = dnorm(dbh_2, f_d_mu, f_d_sd),
    data_list = list(
      f_r_int   = 0.5,
      f_r_slope = 0.1,
      f_s_int   = 1.2,
      f_s_slope = 0.03,
      f_d_mu    = 1.2,
      f_d_sd    = 0.7
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    K             = P + F,
    data_list     = list(),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor        = FALSE
  )  %>%
  # Alternative 2, put the call to make_impl_args_list() inside of define_impl(). 
  define_impl(
    make_impl_args_list(
      kernel_names = c("K", "P", "F"),
      int_rule     = rep("midpoint", 3),
      dom_start    = rep("dbh", 3),
      dom_end      = rep("dbh",3)
    )
  ) %>%
  define_domains(
    dbh = c(        # the name of the state variable
      1,            # the lower bound for the domain
      30,           # the upper bound for the domain
      200           # the number of mesh points to use for integration
    )    
  )

```

## Implement the IPM

The minimal set of information to generate a single deterministic kernel is now wrapped up in our `proto_ipm` and it is time to `make_ipm()`! `make_ipm()` is a generic function and will work with any combination of `model_class`es that are listed as "**Completed and ready**" [here](https://levisc8.github.io/ipmr). 

```{r eval = FALSE}

my_ipm <- init_ipm('simple_di_det') %>%
  define_kernel(
    name      = "P",
    formula   = s_g_mult(s, g),
    family    = "CC",
    
    s         = 1/(1 + exp(-(s_int + s_slope * dbh_1))),
    g         = dnorm(dbh_2, g_mu, g_sd),
    g_mu      = g_int + g_slope * dbh_1,
    
    data_list = list(
      s_int     = 0.2,
      s_slope   = 0.5,
      g_int     = 0.1,
      g_slope   = 1.033,
      g_sd      = 2.2
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) %>% 
  define_kernel(
    name      = "F",
    formula   = f_r * f_s * f_d,
    family    = "CC",
    f_r       = 1/(1 + exp(-(f_r_int + f_r_slope * dbh_1))),
    f_s       = exp(f_s_int + f_s_slope * dbh_1),
    f_d       = dnorm(dbh_2, f_d_mu, f_d_sd),
    data_list = list(
      f_r_int   = 0.5,
      f_r_slope = 0.1,
      f_s_int   = 1.2,
      f_s_slope = 0.03,
      f_d_mu    = 1.2,
      f_d_sd    = 0.7
    ),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor        = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name          = "K",
    family        = "IPM",
    K             = P + F,
    data_list     = list(),
    states        = list(c('dbh')),
    has_hier_effs = FALSE,
    evict_cor        = FALSE
  )  %>%
  # Alternative 2, put the call to make_impl_args_list() inside of define_impl(). 
  define_impl(
    make_impl_args_list(
      kernel_names = c("K", "P", "F"),
      int_rule     = rep("midpoint", 3),
      dom_start    = rep("dbh", 3),
      dom_end      = rep("dbh",3)
    )
  ) %>%
  define_domains(
    dbh = c(1, 30, 200)
  ) %>% 
  make_ipm()

lambda_ipmr <- lambda(my_ipm, 
                      comp_method = 'eigen')
repro_value <- left_ev(my_ipm)
stable_dist <- right_ev(my_ipm)

```

In this example, there are no additional arguments that need to be passed to `make_ipm()` - the `proto_ipm` has all of the information needed to generate a deterministic iteration kernel. All of the `make_ipm()` methods return a list with a length of 6 with entries: 

- `iterators` contains iteration kernels, or `K`s.

- `sub_kernels` contains, in this example, `P` and `F`.

- `env_list` is empty, but setting `return_all = TRUE` in `make_ipm()` returns the evaluation environments for each kernel and sub-kernel. These are used by subsequent analysis methods and so are important for internal usage, but are probably of limited use to most users. 

- `env_seq` contains either an integer vector with the sequence of indices used to select kernels from the `iterators` during a stochastic simulation (`*_stoch_kern`), or a matrix of parameter estimates from each iteration of the stochastic simulation (`*_kern_param`). Not relevant for `*_det` methods with a single iteration kernel and so  contains either as sequence of 1s or `NA`s

- `pop_state` contains a list of matrices for each item defined in `define_pop_state()`. In this case, we never defined the initial population state, so it will be empty. When `define_pop_state()` is used with `iterate = TRUE`, the rows of each matrix correspond to the population state and columns are time steps.

- `proto_ipm` contains the `proto_ipm` object used to generate the model. This is useful for rebuilding the model with a different set of `impl_args` or parameters to see how that changes your results.

`lambda`, `left_ev`, and `right_ev` are generic functions corresponding to the dominant eigenvalue, dominant left eigenvector, and dominant right eigenvector respectively. `lambda` is available for all classes of IPMs, while `left/right_ev` is available for all deterministic IPMs. Stochastic equivalents of the latter will be implemented eventually. 

## Defining more complicated models

In the example above, we created a model with a single, deterministic kernel defined by a single state variable. Next, we'll go through an example showing how to build kernels that are constructed from discretely varying parameter estimates.

### Defining a simple IPM in a discretely varying environment

`ipmr` uses a syntax that closely mirrors the mathematical notation of these models to successively build up more complicated expressions without requiring that much extra code as compared to the example above. The first type of model will be a stochastic, kernel-resampled simulation (`"simple_di_stoch_kern"`). 

The vital rate models are as follows:

1. survival (`s_yr`): a logistic regression with a random year intercept (`s_r_yr`). 

    - Example model formula: `glmer(surv ~ size_1 + (1 | yr), data = my_surv_data, family = binomial()))`

2. growth (`g_yr`): A linear regression random year intercept (`g_r_yr`).

    - Example model formula: `lmer(size_2 ~ size_1 + (1 | yr), data = my_grow_data, family = gaussian()))`

3. pr(flowering) (`p_r`): A logistic regression. This has no random year effect.

    - Example model formula: `glm(flower ~ size_1 , data = my_surv_data, family = binomial()))`

4. seed production (`f_s_yr`): A poisson regression with a random year intercept (`f_s_r_yr`)

    - Example model formula: `glmer(seed_num ~ size_1 + (1 | yr), data = my_surv_data, family = poisson()))`
    
5. recruit size distribution (`f_d`): A normal distribution with two constant parameters, the mean (`mu_fd`) and standard deviation (`sd_fd`).

The vital rates here are not conditional on each other as they come from separate models. For models where parameters come from a joint distribution (e.g. regressions with multiple responses, Bayesian multi-level models), `*_stoch_param` methods are usually more appropriate.

We will use the `purrr` package to make the first bit of code a bit more concise. This chunk takes the place of fitting regression models to actual data, so the code that replaces this chunk will look a little different (and probably involve the use of `coef(some_vital_rate_model`)).


```{r eval = FALSE}
library(purrr)

# Define some fixed parameters

fixed_list <- list(
  s_int     = 1.03,   # fixef(my_surv_mod)[1] - uses fixef because we now have a model with random effects
  s_slope   = 2.2,    # fixef(my_surv_mod)[2]
  g_int     = 3.7,    # fixef(my_grow_mod)[1]
  g_slope   = 0.92,   # fixef(my_grow_mod)[2]
  sd_g      = 0.9,    # sd(resid(my_grow_mod))
  f_r_int   = 0.09,   # coef(my_repro_mod)[1] - uses coef because there are no random effects in this model
  f_r_slope = 0.05,   # coef(my_repro_mod)[2]
  f_s_int   = 0.1,    # fixef(my_flower_mod)[1]
  f_s_slope = 0.005,  # fixef(my_flower_mod)[2]
  mu_fd     = 9,      # mean(my_recr_data$size_2, na.rm = TRUE)
  sd_fd     = 2       # sd(my_recr_data$size_2, na.rm = TRUE)
)

``` 

We've defined a `fixed_list` that holds all of the fixed parameters in our model. Next, we'll make up some random year specific intercepts, and add those to the `fixed_list`, naming it `all_params_list`. You don't necessarily need to rename anything, this is just for disambiguation.

```{r eval = FALSE}
# Now, simulate some random intercepts for growth (g_), survival (s_), 
# and offspring production (f_s_). This part is for the purpose of the example.

# First, we create vector of values corresponding to 

g_r_int   <- rnorm(5, 0, 0.3) # t(ranef(my_grow_mod)) for an lme4 output
s_r_int   <- rnorm(5, 0, 0.7) # t(ranef(my_surv_mod)) for an lme4 output
f_s_r_int <- rnorm(5, 0, 0.2) # t(ranef(my_flower_mod)) for an lme4 output

nms <- paste("r_", 1:5, sep = "")

names(g_r_int)   <- paste('g_', nms, sep = "")
names(s_r_int)   <- paste('s_', nms, sep = "")
names(f_s_r_int) <- paste('f_s_', nms, sep = "")

# Each set of parameters is converted to a named list. The names should match
# the variables referenced in each define_kernel()/define_k() call.

g_params   <- as.list(g_r_int)
s_params   <- as.list(s_r_int)
f_s_params <- as.list(f_s_r_int)

# purrr::splice combines each separate list into one without creating any 
# additional depth to it. This keeps things a bit tidier.

all_params_list <- purrr::splice(fixed_list, g_params, s_params, f_s_params)

```

We've now created a list where each entry is named and contains a single parameter value. This is now ready for use in `define_kernel()`

### Defining custom functions to pass to the building process

We now have some parameter values. In the next step, we'll compose some helper functions to make the vital rate expressions inside of `define_kernel()` a bit more concise and expressive. These are passed in a list to the `usr_funs` argument of `make_ipm()`.

```{r eval = FALSE}

inv_logit <- function(sv, int, slope) {
  return(
    1/(1 + exp(-(int + slope * sv)))
  )
}

# same as above, but handles the extra term from the random effect we simulated.

inv_logit_r <- function(sv, int, slope, r_eff) {
  return(
    1/(1 + exp(-(int + slope * sv + r_eff)))
  )
}

pois_r <- function(sv, int, slope, r_eff) {
  return(
    exp(
      int + slope * sv + r_eff
    )
  )
}

my_funs <- list(inv_logit   = inv_logit,
                inv_logit_r = inv_logit_r,
                pois_r      = pois_r)
```

The only requirement for these functions is that they contain valid R code, and their return types are either numeric or integer.

### Initializing the IPM

With the functions and parameter values defined, we are now ready to begin composing the model. Each expression's syntax will look a little different from before, because we are appending a suffix corresponding to the hierarchical component of the model to each parameter/vital rate/kernel that is affected by it. In this case, we're pretending it is a year effect, denoted `_yr`, but almost any suffix will work. This can be a character or integer vector, and the list can have as many entries as required by the model (e.g. `yr` for years *and* `pl` for plots. The suffix would then become `_yr_pl`). The calls to `define_kernel` and `define_k` now have `has_hier_effs = TRUE`, and `levels_hier_effs = list(yr = 1:5)`. Otherwise, the code should look quite familiar.

**NOTE:** Because of the way `ipmr` handles population vectors internally, **the only suffix that isn't allowed is `_pop`**. This is unfortunate, but can be worked around. Please use `_site` or `_popul` or something instead. Sorry!

```{r eval = FALSE}

my_ipm <- init_ipm('simple_di_stoch_kern') %>%
  define_kernel(
    name             = 'P_yr',               # P because P_yr
    formula          = s_g_mult(s_yr, g_yr), # g and s become g_yr and s_yr, respectively
    family           = "CC",
    
    # Note the usage of the inv_logit_r, which we defined in the block above.
    # it is passed to make_ipm() 
    
    s_yr             = inv_logit_r(ht_1, s_int, s_slope, s_r_yr), 
    g_yr             = dnorm(ht_2, mean = mu_g_yr, sd = sd_g),
    mu_g_yr          = g_int + g_slope * ht_1 + g_r_yr,
    
    # all_params_list contains the named parameters g_r_1, g_r_2, s_r_1, s_r_2, etc.
    # This is the only level where the user is required to fully expand the name
    # X hier_level combinations. 
    
    data_list        = all_params_list,
    states           = list(c('ht')),
    has_hier_effs    = TRUE,
    levels_hier_effs = list(yr = 1:5),
    evict_cor        = TRUE,
    
    # reference to g_yr in evict_fun is also updated
    
    evict_fun        = truncated_distributions("norm", "g_yr")
    
  ) %>%
  define_kernel(
    name             = "F_yr",             # Update the names as we did for the P kernel
    formula          = f_r * f_s_yr * f_d,
    family           = "CC",
    f_r              = inv_logit(ht_1, f_r_int, f_r_slope),
    f_s_yr           = pois_r(ht_1, f_s_int, f_s_slope, f_s_r_yr),
    f_d              = dnorm(ht_2, mean = mu_fd, sd = sd_fd),
    data_list        = all_params_list,
    states           = list(c('ht')),
    has_hier_effs    = TRUE,
    levels_hier_effs = list(yr = 1:5),
    evict_cor        = TRUE,
    evict_fun        = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name             = 'K_yr',
    K_yr             = P_yr + F_yr,
    family           = "IPM",
    data_list        = list(),
    states           = list(c("ht")),
    has_hier_effs    = TRUE,
    levels_hier_effs = list(yr = 1:5),
    evict_cor        = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("K_yr", "P_yr", "F_yr"),
      int_rule     = rep("midpoint", 3),
      dom_start    = rep("ht", 3),
      dom_end      = rep("ht", 3)
    )
  ) %>%
  define_domains(ht = c(0.2, 40, 100)) %>%
  make_ipm(usr_funs = my_funs,
           iterate  = FALSE)

```

`ipmr` automatically substitutes 1, 2, 3, 4, and 5 for each occurence of `yr` in the vital rate expressions. Thus, `P_yr` is expanded to `P_1`, `P_2`, `P_3`, `P_4`, `P_5`, `s_yr` to `s_1`, `s_2`, `s_3`, `s_4`, and `s_5`. `s_r_yr` is converted to `s_r_1`, `s_r_2`,  etc. This is why we needed to make sure the names in `all_params_list` had the actual numbers appended to them. 

Syntax aside, the only real difference between the IPM definition in the first example and this one is that we've passed custom functions to the call to `make_ipm()`, and altered our vital rate expressions to use them instead of the pure math for each variable transformation. On the other hand, the contents of the output *will* look a little different.

- The `iterators` slot of `my_ipm` now contains 5 K kernels - one for each year of data.

- The `sub_kernels` slot of `my_ipm` now contains 5 P and 5 F kernels (10 total) - again, one for each year of data.

- All other slots will look the same as in the previous `simple_di_det` example.

To run an actual simulation for, say, 100 time steps, we can remove the existing `K` using the helper `remove_k()`, add a new one with `define_k()`, and reimplement the model. This requires defining an expression that relates the population state at `t+1` to the kernel and population state at `t` (done in `define_k`), defining an initial population state (done in `define_pop_state`), and running `make_ipm(iterate = TRUE, iterations = 100)`.

```{r eval = FALSE}

my_iterated_ipm <- my_ipm$proto_ipm %>%
  remove_k() %>%                        # remove the existing K and define a new one
  define_k(
    name             = "K_yr",
    K_yr             = P_yr + F_yr,
    n_ht_t_1         = K_yr %*% n_ht_t,
    family           = 'IPM',
    data_list        = list(),
    states           = list(c('ht')),
    has_hier_effs    = TRUE,
    levels_hier_effs = list(yr = 1:5),
    evict_cor        = FALSE
  ) %>%
  
  # This time arond, we don't need to define impl_args for every kernel, just 
  # the new K. We can also skip defining the domains, those are already done
  # too.
  
  define_impl(
    make_impl_args_list(
      kernel_names = c("K_yr"),
      int_rule     = c('midpoint'),
      dom_start    = c("ht"),
      dom_end      = c("ht")
    )
  ) %>%
  
  # Initialize the population vector. This can take any expression. Note that
  # the population state has an n_ prefixed to it to indicate that it is
  # describing the population distribution function. ipmr will automatically
  # create variables n_ht_t and n_ht_t_1 when constructing the IPM. We can
  # use the kernel_seq argument to pass a pre-specified sequence of kernels
  # into the function, and retrieve it later using my_iterated_ipm$env_seq.
  
  define_pop_state(n_ht = runif(100)) %>%      
  make_ipm(usr_funs   = my_funs,
           kernel_seq = sample(1:5, 100, replace = TRUE),
           iterate    = TRUE,
           iterations = 100)
  
# lambda(comp_method = 'pop_size', type = 'all') will compute the population 
# growth rate for every time step as the sum(n_ht_t_1) / sum(n_ht_t).

det_lambdas <- lambda(my_iterated_ipm, comp_method = 'pop_size', type = 'all')

# lambda(comp_method = 'pop_size', type = 'stochastic') computes
# the mean of the log'd values computed by type = 'all' (Caswell 2001, p 396).

stoch_lambda <- lambda(my_iterated_ipm, comp_method = 'pop_size', type = 'stochastic')


```

100 iterations is probably not enough to estimate stochastic growth rates ($\lambda_s$), but the computations can take some time with a lot of iterations, and is probably not practical for demonstration purposes. 

## Simple IPMs for continuously varying environments 

In some cases, it is not desirable to work with single estimates of a random variable, and we prefer to work with the distributions they come from. Quantifying uncertainty is a critical part of demography. Additionally, environmental variables like climate may be random with reasonably well known distributions. A stochastic simulation can incorporate information to help us understand the consequences. 

Unfortunately, this also means that we can't obtain a set of kernels without iterating the model at least once, because we have to sample from the parameter distributions at least once (well, technically, we can, but this is probably not the desired behavior). This is where the `*_stoch_param` methods come in handy. `*_stoch_param` methods are slightly less computationally efficient than their `*_stoch_kern*` counterparts because they must rebuild the iteration kernel for every single iteration. However, they are fantastic tools for propagating uncertainty in parameter estimates throughout the model. 

Below is an example that demonstrates how to work with posterior distributions from Bayesian models. `ipmr` is careful to only evaluate each function in `define_env_state()` once per iteration, so you can use multivariate joint distributions correctly.

Equivalent code is demonstrated in the comments, but switches to a Bayesian model for growth and survival, specifically [`brms`](https://paul-buerkner.github.io/brms/). The parameters for the growth and survival functions will be sampled from posterior distributions one time per iteration, and an example of a function to pass to `define_env_state()` is included in the first chunk below. 

There are a multitude of ways to incorporate parameter uncertainty and/or continuous environmental variation, and that variety is beyond the scope of this vignette. If the example below is not as helpful as you'd hoped, then my suggestion would be to start reading on GLMMs [here](https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#introduction) and continue reading on their applications to IPMs [here](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12405). After that, hopefully the example below will make more sense.

### Defining initial conditions

Stochastic simulations require specification of the initial conditions. `ipmr` aims to make this straightforward for you by providing two helpers - `define_pop_state()` and `define_env_state()`. 

#### `define_pop_state()`

`define_pop_state()` takes either 

1. a named set of expressions that, when evaluated, generate a population vector 

    - example: `define_pop_state(n_dbh = runif(100)`) for a model with 100 meshpoints.

**or**

2. a named list of pre-generated population vectors in the `pop_vectors` argument 

    - example: `define_pop_state(pop_vectors = list(n_dbh = init_dbh_vector))`, where `init_dbh_vector` is generated somewhere earlier in the script.

In `define_pop_state()`, populations should be defined as `n_<insertStateVariableHere>`. If this function is used in the IPM definition code, then 2 additional helper variables are generated: `n_stateVariable_t` and `n_stateVariable_t_1`. These can be used to reference the population states in vital rate and/or kernel expressions. They must be referenced in the `...` of `define_k()` as well, because otherwise, `ipmr` doesn't know how to iterate the model.

#### `define_env_state()`

`define_env_state()` takes a named set of expressions in the `...` and then a data list, much like how `define_kernel()`/`define_k()` take them. The values created need to be in a list that has names corresponding to the parameter names in the vital rate expressions. In this example, they are called `s_int`, `s_slope`, `g_int`, `g_slope`, and `g_sd`. The `data_list` in  for this section should contain any variables used in the function you define (in this example, `posterior_distribs`). You can reference them in the vital rate expressions in each kernel definition as if they were in the `data_list` of `define_kernel/define_k()`. 

### The model

The first chunk below initializes the parameters, population vector, and functions that the model uses. It takes the place of the usual vital rate model fitting process. The vital rate functions and models for this example are as follows:

1. survival (`s`): a Bayesian logistic regression. 

    - example model formula: `brm(survival ~ size_1, data = my_surv_data, family = bernoulli(), chains = 4,iter = 2000, warmup = 1000)`
    
2. growth (`g`): a Bayesian linear regression

    - example model formula: `brm(size_2 ~ size_1, data = my_grow_data, family = gaussian(), chains = 4,iter = 2000, warmup = 1000)`
    
3. flower probability (`f_r`): A non-bayesian logistic regression.

    - example model formula: `glm(repro ~ size_1, data = my_repro_data, family = binomial())`
    
4. seed production (`f_s`): a non-bayesian logistic regression.

    - example model formula: `glm(flower_n ~ size_1, data = my_flower_data, family = poisson())`
    
5. recruit sizes (`f_d`): A normal distribution

    - example code: mean (`f_d_mu`) `mean(my_recruit_data$size_2, na.rm = TRUE)` and standard deviation (`f_d_sd`) `sd(my_recruit_data$size_2, na.rm = TRUE)`
    
    
```{r eval = FALSE}

library(ipmr)

# Define the fixed parameters in a list

data_list <- list(f_r_int   = 0.3,
                  f_r_slope = 0.03,
                  f_s_int   = 0.4,
                  f_s_slope = 0.001,
                  f_d_mu    = 1.1,
                  f_d_sd    = 0.1)

# Simulate some random parameters to define the multivariate distribution
# to sample from. In user specified models, this might be replaced by
# cbind(posterior_samples(my_surv_mod), posterior_samples(my_grow_mod)).

posterior_distribution <- data.frame(
  s_int     = rnorm(4000, mean = -10, sd = 1),
  s_slope   = rgamma(4000, shape = 1), # slope should be positive for this example
  g_int     = rnorm(4000),
  g_slope   = runif(4000, 0.85, 1.15),
  g_sd      = runif(4000, 0.75, 3)
)

# set the names to the parameter names you want to use in the model. These 
# are already set in this example, but outputs from brms/rstan/lme4 may not be
# as conveniently named. 

names(posterior_distribution) <- c(
  's_int',
  's_slope',
  'g_int',
  'g_slope',
  'g_sd'
)

# Specify an initial population vector. This can also be done in the call to
# define_pop_state

init_pop_vec <- runif(100)

# We define a wrapper function that samples from a data frame containing the
# joint posterior distribution of each parameter. In this case, all posterior
# samples are weighted as equally probable for the sake of simplicity. 

posterior_sample <- function(posterior_distrib) {
  
  sample_pos <- seq(1, dim(posterior_distrib)[1])
  sample_ind <- sample(sample_pos, size = 1, prob = NULL)
  
  out <- as.list(posterior_distrib[sample_ind , ])
  
  return(out)
  
}


# Again, we can define our own functions and pass them into calls to make_ipm. This
# isn't strictly necessary, but can make the model code more readable/less error prone.

inv_logit <- function(int, slope, sv1) {
  1/(1 + exp(-(int + slope * sv1)))
}


```

We now have parameter estimates. Time to build the IPM!


```{r eval = FALSE}

param_resamp_model <- init_ipm('simple_di_stoch_param') %>%
  define_kernel(
    name    = 'P',
    formula = s * g,
    family  = 'CC',
    
    # Parameters created by define_env_state() can be referenced by name just like
    # any other parameter in the model.
    
    g_mu      = g_int + g_slope * surf_area_1,
    s         = inv_logit(s_int, s_slope, surf_area_1),
    g         = dnorm(surf_area_2, g_mu, g_sd),
    data_list = data_list,
    states    = list(c('surf_area')),
    
    # In this case, we do not specify hier_effs as the kernels don't vary discretely,
    # but in a continuous manner.
    
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "g")
  ) %>%
  define_kernel(
    name          = 'F',
    formula       = f_r * f_s * f_d,
    family        = 'CC',
    f_r           = inv_logit(f_r_int, f_r_slope, surf_area_1),
    f_s           = exp(f_s_int + f_s_slope * surf_area_1),
    f_d           = dnorm(surf_area_2, f_d_mu, f_d_sd),
    data_list     = data_list,
    states        = list(c('surf_area')),
    has_hier_effs = FALSE,
    evict_cor     = TRUE,
    evict_fun     = truncated_distributions("norm", "f_d")
  ) %>%
  define_k(
    name = 'K',
    
    # Note that here, we specify both the form of the iteration kernel and
    # the iteration procedure. The commented out form directly beneath uses
    # right_mult(), a helper function for more complicated expressions. It is 
    # equivalent to the line above it.
    
    K               = P + F,
    n_surf_area_t_1 = K %*% n_surf_area_t,
    # n_surf_area_t_1 = right_mult(K, n_surf_area_t),
    family          = 'IPM',
    data_list       = data_list,
    states          = list(c('surf_area')),
    has_hier_effs   = FALSE,
    evict_cor          = FALSE
  ) %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P", "F", "K"),
      int_rule     = rep('midpoint', 3),
      dom_start    = rep('surf_area',3),
      dom_end      = rep('surf_area', 3)
    )
  ) %>%
  define_domains(surf_area = c(0, 10, 100)) %>%
  define_env_state(
    env_params = posterior_sample(posterior_distrib),
    data_list = list(
      posterior_distrib = posterior_distribution
    )
  ) %>%
  define_pop_state(
    pop_vectors = list(
      n_surf_area_t = init_pop_vec
    ),
  ) %>%
  make_ipm(usr_funs   = list(inv_logit        = inv_logit,
                             posterior_sample = posterior_sample),
           iterate    = TRUE,
           iterations = 10)

```


## General IPMs

An article on these is available on the [website](https://levisc8.github.io/ipmr/articles/general-ipms.html) and from an R session:

```{r eval = FALSE}

vignette('General IPMs', 'ipmr')

```

