---
title: "Age-Size IPMs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Age-Size IPMs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
In some cases, we may wish to cross-classify individuals by age and size. This is a special case of the general IPM, and these models need to be implemented slightly differently. The syntax for implementing them is largely the same as for non-age classified hierarchical IPMs, but includes keywords to reference ages algebraically instead of explicitly inserting values (which could be quite repetitive). These words are `minus`, `plus`, and `max_age`. The `max_age` keyword is provided to help define models that include a "grey-beard" class (e.g. no specific maximum age, just really old).

The rest of this vignette assumes you are familiar with the hierarchical notation that `ipmr` uses. If you haven't already covered this, it would be best to read at least the [intro](https://levisc8.github.io/ipmr/articles/ipmr-introduction.html) before continuing.

## Example - Soay sheep 
  
Below is an example of a deterministic age-size IPM using Soay sheep from St. Kilda. It directly reproduces the model found in Ellner, Rees & Childs (2016), chapter 6.2. The code that implements that version can be found [here](https://github.com/ipmbook/first-edition/tree/master/Rcode/c6). This example will skip the IBM simulation and model fitting and just focus on the new syntax.
  
First, we set up our parameter list and define a couple functions to help out. The `f_fun` is used to wrap `formula` argument in `"F_age"` kernel so that we can concisely express that age-0 individuals do not reproduce.

```{r eval = FALSE}

library(ipmr)

param_list <- list(
  surv_int = -17, 
  surv_z = 6.68,
  surv_a = -0.334, 
  grow_int = 1.27, 
  grow_z = 0.612, 
  grow_a = -0.00724,
  grow_sd = 0.0787,
  repr_int = -7.88, 
  repr_z = 3.11,
  repr_a = -0.078, 
  recr_int = 1.11, 
  recr_a = 0.184, 
  rcsz_int = 0.362,
  rcsz_z = 0.709, 
  rcsz_sd = 0.159
)


inv_logit <- function(x) {

  return( 1 / (1 + exp(-x)) )
}

f_fun <- function(age, s_age, pb_age, pr_age, recr) {

  if(age == 0) return(0)

  s_age * pb_age * pr_age * recr * 0.5

}


```

Next, we begin to initialize our kernels. Note that `init_ipm` now has a second argument - `has_age`. This is a logical and denotes that we are specifying a model with individuals cross-classified by both age and size. The model class is `"general_di_det"` because age-size models are always general IPMs, and we are only working on a deterministic version of this model for now. 

```{r eval = FALSE}

age_size_ipm <- init_ipm("general_di_det", has_age = TRUE) %>%
  define_kernel(
    name          = "P_age",
    family        = "CC",
    formula       = s_age * g_age * d_wt,
    s_age         = inv_logit(surv_int + surv_z * wt_1 + surv_a * age),
    g_age         = dnorm(wt_2, mu_g_age, grow_sd),
    mu_g_age      = grow_int + grow_z * wt_1 + grow_a * age,
    data_list     = param_list,
    states        = list(c("wt")),
    has_hier_effs = FALSE,
    levels_ages   = list(age = c(0:20), max_age = 21),
    evict_cor     = FALSE
  )

```

Note that the kernel name and vital rates all have `"_age"` appended to them, much like we would when defining a hierarchical model. The primary difference in defining this kernel vs any other hierarchical model is that we now specify `has_hier_effs = FALSE`, and pass a list to `levels_ages`. `levels_ages` takes a list with at least one, but possibly two components:

1. `age`: This is the age range for the model. 

2. Optionally, `max_age`: This is used to denote that while individuals may get older in reality, this value will be the highest that we model. In effect, it creates "very old, but not quite dead", or "greybeard" group.

Next, we continue defining the models as we did before.

```{r eval = FALSE}

age_size_ipm <- init_ipm("general_di_det", has_age = TRUE) %>%
  define_kernel(
    name          = "P_age",
    family        = "CC",
    formula       = s_age * g_age * d_wt,
    s_age         = inv_logit(surv_int + surv_z * wt_1 + surv_a * age),
    g_age         = dnorm(wt_2, mu_g_age, grow_sd),
    mu_g_age      = grow_int + grow_z * wt_1 + grow_a * age,
    data_list     = param_list,
    states        = list(c("wt")),
    has_hier_effs = FALSE,
    levels_ages   = list(age = c(0:20), max_age = 21),
    evict_cor     = FALSE
  ) %>%
  define_kernel(
    name          = "F_age",
    family        = "CC",
    formula       = f_fun(age, s_age, pb_age, pr_age, recr) * d_wt,
    s_age         = inv_logit(surv_int + surv_z * wt_1 + surv_a * age),
    pb_age        = inv_logit(repr_int + repr_z * wt_1 + repr_a * age),
    pr_age        = inv_logit(recr_int + recr_a * age),
    recr          = dnorm(wt_2, rcsz_mu, rcsz_sd),
    rcsz_mu       = rcsz_int + rcsz_z * wt_1,
    data_list     = param_list,
    states        = list(c("wt")),
    has_hier_effs = FALSE,
    levels_ages   = list(age = c(0:20), max_age = 21),
    evict_cor     = FALSE
  )

```

The `"F_age"` kernel has a custom function in the `formula` slot that allows us to always set fecundity for age-0 individuals to 0. Everything else probably looks familiar.


Our call to `define_impl()` will look a little different. This is because we have to make sure that our `P_age` kernels produce `wt_age` individuals, whereas our `F_age` kernels must produce `wt_0` individuals (i.e. only age-0 lambs). We do this using the `state_start` and `state_end` arguments.

```{r eval = FALSE}

age_size_ipm <- age_size_ipm %>%
  define_impl(
    make_impl_args_list(
      kernel_names = c("P_age", "F_age"),
      int_rule     = rep("midpoint", 2),
      state_start    = c("wt_age", "wt_age"),
      state_end      = c("wt_age", "wt_0")
    )
  ) 

```

All of the steps that come after this are the same for age-size models as they are for other model types. We 

1. `define_domains()`

2. `define_pop_state()`

3. Optionally, `define_env_state()` (though not here because it's a deterministic model)

4. `make_ipm()`

```{r eval = FALSE}

age_size_ipm <- age_size_ipm %>%
  define_domains(
    wt = c(1.6, 3.7, 100)
  ) %>%
  define_pop_state(
    n_wt_age = runif(100)
  ) %>%
  make_ipm(
    usr_funs = list(inv_logit = inv_logit,
                    f_fun     = f_fun),
    iterate  = TRUE,
    iterations = 100
  )

lam <- lambda(age_size_ipm)
lam

```

