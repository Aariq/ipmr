# Internal linear algebra stuff

# ev helper functions -------------

#' @noRd
# We need the total pop size to standardize our vectors, but we don't really
# know the proper order in which to combine them to create a single output.
# thus, we keep them in a list with entries corresponding to states, and
# use Reduce to compute the total size. The final output will be the list
# of states standardized by this total population size.

.extract_conv_ev_general <- function(pop_state) {

  final_it <- dim(pop_state[[1]])[2]

  temp     <- lapply(pop_state,
                     function(x, final_it) {

                       x[ , final_it]

                     },
                     final_it = final_it)

  pop_std <- Reduce('sum', unlist(temp), init = 0)

  out     <- lapply(temp,
                    function(x, pop_std) x / pop_std,
                    pop_std = pop_std)

  return(out)
}

#' @noRd

.get_pop_nm_simple <- function(ipm) {

  pop_nm <- ipm$proto_ipm$state_var %>%
    unlist() %>%
    unique() %>%
    .[1]

  return(pop_nm)
}

#' @noRd

.make_mega_mat <- function(mega_mat, sub_kernels) {

  # Extract names of sub_kernels. We shouldn't need mega-mat after this
  # because call_args() returns the mega_mat call's arguments in order!

  sub_mats    <- rlang::call_args(mega_mat)

  sub_mat_nms <- Filter(Negate(function(x) x == 0 ), sub_mats)

  if(!all(as.character(unlist(sub_mat_nms)) %in% names(sub_kernels))) {

    stop("names in 'mega_mat' are not all present in 'ipm$sub_kernels'")

  } else if( (sqrt(length(sub_mats)) %% 1L) != 0L) {

    stop('mega_mat is not square!')

  }

  # Next, we need to work out the dimensions of each row + column so that any 0s
  # can be appropriately duplicated. If there aren't any 0s in 'mega_mat', then
  # just skip straight to the creation step.

  zero_test <- vapply(sub_mats,
                      function(x) x == 0,
                      logical(1L))

  if(any(zero_test)) {

    # This actually just creates calls to rep(0, times = dim_1 * dim_2)
    # and makes sure those calls are substituted in for the actual 0s.
    # These get evaluated in .make_mega_mat_impl in the next step.

    sub_mats <- .fill_0s(sub_mats, sub_kernels)

  }

  # *_impl = implementation. This actually generates the full kernel

  out <- .make_mega_mat_impl(sub_mats, sub_kernels)

  return(out)

}

#' @noRd

.make_mega_mat_impl <- function(sub_mats, sub_kernels) {

  # Get number of blocks and then bind

  block_dim <- sqrt(length(sub_mats))

  kern_env  <- rlang::env(!!! sub_kernels)

  sub_mats  <- lapply(sub_mats,
                      function(sub_kern, eval_env) {
                        rlang::eval_tidy(sub_kern, env = eval_env)
                      },
                      eval_env = kern_env)

  # now, we just need to generate an index to subset the sub_mats for
  # generating each row of the block matrix

  blocks <- vector('list', length = block_dim)

  for(i in seq_len(block_dim)) {

    if(i == 1) {
      block_ind <- seq(1, block_dim, by = 1)
    } else {
      block_ind <- block_ind + block_dim
    }

    blocks[[i]] <- do.call(cbind, sub_mats[block_ind])

  }

  out <- do.call(rbind, blocks)

  return(out)
}

#' @noRd

.fill_0s <- function(sub_mats, sub_kernels) {

  # Create a character matrix that contains the dimensions of each
  # block in the mega-matrix

  kern_dims <- lapply(sub_kernels,
                      function(x) {
                        temp <- dim(x)
                        out <- paste(temp, collapse = ', ')
                      })

  mega_block_dim <- sqrt(length(sub_mats))
  dim_env        <- rlang::env()

  rlang::env_bind(!!! kern_dims,
                  .env = dim_env)

  dim_mat        <- lapply(sub_mats,
                           function(x, env_) rlang::eval_tidy(x, env = env_),
                           env_ = dim_env) %>%
    unlist() %>%
    matrix(ncol = mega_block_dim,
           nrow = mega_block_dim,
           byrow = TRUE)

  # Now, loop over and determine the required dimensions for each 0 entry

  it          <- 1
  zero_nm_ind <- 1

  for(ro in seq_len(mega_block_dim)) {

    for(co in seq_len(mega_block_dim)) {

      if(dim_mat[ro, co] == "0") {

        ro_dim <- vapply(dim_mat[ro, ],
                         function(x) {
                           strsplit(x, ', ')[[1]][1]
                         },
                         character(1L)) %>%
          as.integer() %>%
          max(na.rm = TRUE) # Need to remove the NAs generated by entries of 0!

        co_dim <- vapply(dim_mat[ , co],
                         function(x) {
                           strsplit(x, ', ')[[1]][2]
                         },
                         character(1L)) %>%
          as.integer() %>%
          max(na.rm = TRUE)

        # Generate an expression and insert it into sub_mats. These get
        # evaluated and c/rbinded in the next stage
        zero_call <- paste('matrix(rep(0, times = ',
                           ro_dim * co_dim,
                           '), nrow = ',
                           ro_dim,
                           ', ncol = ',
                           co_dim,
                           ')', sep = "") %>%
          rlang::parse_expr()

        sub_mats[[it]]      <- zero_call
        names(sub_mats)[it] <- paste('zero_', zero_nm_ind, sep = "")
        zero_nm_ind         <- zero_nm_ind + 1
      } else {

        names(sub_mats)[it] <- as.character(sub_mats[[it]])

      }
      it <- it + 1

    }   # columns
  }     # end rows


  return(sub_mats)

}

#' @noRd
# Evaluates the pop_vec

.make_mega_vec <- function(pop_vec, pop_state) {

  names(pop_state) <- gsub('pop_state_', "", names(pop_state))

  # if {...} else {...} to handle the case in right_ev where it is working
  # just with a list of vectors. In general, most instances should be a list
  # of matrices. This just helps generalize a bit more.

  temp_pop_state   <- lapply(pop_state,
                             function(x) {
                               if(is.matrix(x)) {
                                 x[ , 1]
                               } else {
                                 x
                               }
                             })

  vec_env          <- rlang::env(!!! temp_pop_state)

  pop_vec          <- rlang::quo_set_env(pop_vec, env = vec_env)

  out              <- rlang::eval_tidy(pop_vec, env = vec_env)

  return(out)

}

.mega_vec_to_list <- function(mega_vec, pop_holder, init_pop_state) {

  # Get the number of cells for each state variable in the mega_vec,
  # and conver that to the

  n_rows        <- lapply(init_pop_state,
                          function(x) dim(x)[1])

  names(n_rows) <- gsub('pop_state_', '', names(n_rows))

  order_ind     <- rlang::eval_tidy(mega_vec, data = n_rows)

  # Convert the call arguments to characters so we can use them
  # to name the output list

  mega_vec_nm   <- rlang::call_args(mega_vec) %>%
    vapply(as.character, character(1L))

  out <- list()


  # Generate indices for subsetting and set up the new names for the output

  for(i in seq_along(order_ind)) {

    pop_holder_len <- order_ind[i]

    nm             <- paste(mega_vec_nm[i], 'v', sep = '_')

    if(i == 1) {

      # The first sequences always start from 1

      pop_holder_ind <- seq(1, pop_holder_len, by = 1)

    } else {

      # Anything afterwards is index by the sum of the prior
      # indices + 1, so that we start grabbing values from where the
      # previous one left off

      pop_holder_start <- sum(order_ind[(1:(i - 1))]) + 1

      pop_holder_end   <- pop_holder_start + order_ind[i] - 1

      pop_holder_ind   <- seq(pop_holder_start,
                              pop_holder_end,
                              by = 1)
    }

    temp_pop <- rlang::list2(!! nm := pop_holder[pop_holder_ind])

    out      <- purrr::splice(out, temp_pop)
  }

  return(out)

}


# Lambda helpers----------
#' @noRd
# vec = numeric vector

.geom_mean <- function(vec) {
  n   <- length(vec)

  out <- prod(vec)

  return(out ^ (1/n))
}

#' @noRd

.lambda_pop_size <- function(x, all_lambdas = TRUE) {

  pops  <- x$pop_state
  n_its <- dim(pops[[1]])[2]
  temp  <- numeric(n_its - 1)

  for(i in seq(2, n_its, 1)) {

    tot_pop_size_t <- lapply(pops, function(x, it) {
      sum(x[ ,it])
    },
    it = (i - 1)) %>%
      unlist() %>%
      sum()

    tot_pop_size_t_1 <- lapply(pops, function(x, it) {
      sum(x[ ,it])
    },
    it = i) %>%
      unlist() %>%
      sum()

    temp[(i - 1)] <- tot_pop_size_t_1 / tot_pop_size_t

  }

  if(!all_lambdas) {
    return(temp[length(temp)])
  } else {
    return(temp)
  }

}

.lambda_eigen <- function(x) {

  eigs <- .det_lambda(x)

  return(eigs)


}

#' @noRd
# x = an object from make_ipm()

.det_lambda <- function(x) {

  return(
    vapply(x$iterators,
           function(y) Re(eigen(y)$values[1]),
           numeric(1L))
  )

}

#' @noRd

is_square <- function(x) {

  dim(x)[1] == dim(x)[2]

}

#' @noRd
# Checks for convergence to asymptotic dynamics. Supports either
# eigenvalues or pop_state entries. For eigenvalues, looks at a vector,
# for pop_state entries, two possibilities:
#
# SIMPLE_*_ipm: pop_state is a list holding a single matrix. this function
# is called with ipm$pop_state[[1]], and the matrix is passed to code in first
# if()
#
# GENERAL_*_ipm: pop_state is a list with multiple matrices. this function is
# called on ipm$pop_state, and the list is passed to the code in the second if()

is_conv_to_asymptotic <- function(x, tol = 1e-10) {

  if(is.matrix(x) && dim(x)[1] > 1) {

    # Standardize columns first
    x <- apply(x, 2, FUN = function(y) y / sum(y))

    n_col     <- end_ind <- dim(x)[2]
    start_ind <- n_col - 1

    start_val <- x[ , start_ind]
    end_val   <- x[ , end_ind]

  } else if(is.list(x)) {

    # General

    n_col     <- end_ind <- dim(x[[1]])[2]
    start_ind <- n_col - 1

    start_col <- lapply(x,
                        function(y, ind) matrix(y[ , ind], ncol = 1),
                        ind = start_ind) %>%
      do.call("rbind", args = .)

    start_val <- start_col / sum(start_col)

    end_col   <- lapply(x,
                        function(y, ind) matrix(y[ , ind], ncol = 1),
                        ind = end_ind) %>%
      do.call("rbind", args = .)

    end_val <- end_col / sum(end_col)

  } else if(is.vector(x)) {

    n_col     <- end_ind <- length(x)
    start_ind <- n_col - 1

    start_val <- x[start_ind]
    end_val   <- x[end_ind]

  }

  return(
    isTRUE(
      all.equal(
        start_val, end_val, tolerance = tol
      )
    )
  )

}
