---
title: "ipmr: Flexibly implement Integral Projection Models in R"
output:  
  word_document:
    toc: no
fig_caption: yes
---

Sam C. Levin $^{\ast1,2,3}$, Aldo Compagnoni $^{1,2,3}$, Roberto Salguero-Gomez $^3$, Dylan Z. Childs $^4$, Sanne Evers $^{1,2}$, Tiffany M. Knight $^{1,2,5}$

$^1$Institute of Biology, Martin Luther University Halle-Wittenberg, Am Kirchtor 1, 06108 Halle (Saale), Germany

$^2$German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig, Deutscher Platz 5e, 04103 Leipzig, Germany

$^3$Oxford Zoology

$^4$Sheffield

$^5$UFZ



$^*$Corresponding Author:

Sam C Levin

Deutscherplatz 5e, 04103 Leipzig, Germany

email: <levisc8@gmail.com>



Target journal: Methods in Ecology and Evolution, submission type: Application. Word limit: 3000



[Formatting guidelines](https://besjournals.onlinelibrary.wiley.com/hub/journal/2041210X/author-guidelines) (in case you care)



# **Abstract**

1. Integral projection models have become an important tool for studying the demography of populations structured by one or more continuous state variables. They are used to investigate everything from single species conservation and management to understanding evolutionary stable strategies. To date, there has only been one serious effort to implement these in _R_. It has been useful, but suffers from constraints imposed by the high level of abstraction and combining the parameterization and model implementation into a single step. 

2. We create a lower level framework that relies on a combination of S3 object-oriented programming, quasi-quotation, and a small number of generic functions to generate model objects. The syntax is meant to mirror the mathematical notation of the models, and provides a clear translation between the underlying math and the numerical implementaiton of the model.

3. Our framework allows users to generate simple and/or general, deterministic and/or stochastic, density independent integral projection models. It provides some additional basic analysis methods, as well as visualization tools.

4. This framework is far more flexible than existing packages for integral projection models. The common data structure it uses to generate them also presents opportunities to enhance reproducibility in the field, and represent them in concise, text format databases in ways that could not have been done previously. 

```{r echo = FALSE, message = FALSE, warning=FALSE}

library(dplyr)
library(purrr)
library(ggplot2)

ipm_pubs <- read.csv('../../data-raw/padr-pubs-feb-2020.csv',
                     stringsAsFactors = FALSE)

ipm_id <- pmap_chr(.l = data.frame(a = ipm_pubs$Authors,
                                   b = ipm_pubs$Journal, 
                                   c = ipm_pubs$Year),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

ipm_pubs <- cbind(ipm_pubs, ipm_id)
ipm_pubs$Year <- as.integer(ipm_pubs$Year)

pub_tot  <- length(unique(ipm_id))

spec_tot <- length(unique(ipm_pubs$Species))

cdb_fetch <- function(cdb) {
  # get url or path
  if (tolower(cdb) == 'comadre') {
    path <- url('https://compadre-db.org/Data/ComadreDownload')
  } else if (tolower(cdb) == 'compadre') {
    path <- url('https://compadre-db.org/Data/CompadreDownload')
  } else {
    path <- path.expand(cdb)
  }
  
  # fetch and load
  env <- new.env()
  x <- load(path, env)[1]
  dbFetch <- env[[x]]

  # Deal with differences between s4 and s3 versions of database

  if(inherits(dbFetch, 'list')) {
    dbFetch <- dbFetch[[1]]
  } else if(inherits(dbFetch, "CompadreDB")) {
    dbFetch <- dbFetch@data
  } else {
    stop("Cannot recognize class of currently fetched com(p)adre object",
         call. = FALSE)
  }


  return(dbFetch)

}

cpd <- cdb_fetch('compadre')

mpm_id<- pmap_chr(.l = data.frame(a = cpd$Authors,
                                  b = cpd$Journal, 
                                  c = cpd$YearPublication),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

cpd <- cbind(cpd, mpm_id)

cpd$YearPublication <- as.integer(cpd$YearPublication)

cpd_tot_pubs <- cpd %>% 
  filter(!duplicated(mpm_id)) %>% 
  group_by(YearPublication) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(YearPublication) %>%
  filter(!is.na(YearPublication))

cpd_tot_pubs <- mutate(cpd_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Compadre MPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))

pdr_tot_pubs <- ipm_pubs %>%
  filter(!duplicated(ipm_id)) %>%
  group_by(Year) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(Year)
  
pdr_tot_pubs <- mutate(pdr_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Padrino IPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))  %>%
  filter(!is.na(Year))

all_pubs <- rbind(pdr_tot_pubs, cpd_tot_pubs)
all_pubs$Year <- as.integer(all_pubs$Year)

```


# **Introduction**

Integral projection models (IPMs) are an important tool for demographers studying structured populations in discrete time. Since their introduction Easterling, Ellner & Dixon's (2000) paper, there have been over `r pub_tot` publications for using IPMs to address a variety of questions ranging from invasive species population dynamics (e.g. Crandall & Knight 2017) to evolutionary stable strategies to endangered species conservation (Childs et al. 2011, Coulson 2012). In plants alone, there are currently at least `r spec_tot` plant species for which an IPM exists (a buttload of citations, Padrino DB, Levin et al. unpublished). Their main power lies in the fact that they allow for continuously distributed state variables to describe vital rates and population structure, as opposed to historically favored methods that relied on the sometimes arbitrary delineation of classes (e.g. matrix population models, Caswell 2001).

IPMs are flexible models that use individual level longitudinal data to determine the functional forms of state-fate relationships. They are built using regression models of vital rates on a state variable that is related to individual fitness in some way (e.g. diameter at breast height for trees, body mass in animals). Regression analysis has been a standard tool for ecologists for quite some time now, and the field is mature enough to accomodate many different types of data (e.g. Wood 2011, Bates et al. 2015). Parameter estimation for regression models is usually more efficient than estimating individual matrix transition parameters because there are usually fewer parameters to estimate with the same amount of data. This facilitates analysis of population dynamics for threatened or endangered species in a way that matrix models historically have not done (Ramula et al. 2009, but see Louthan & Doak 2018 for further discussion). This flexibility has lead to a rapid increase in their appearance in the literature (Figure 1). This rise in popularity also spurred the creation of software tools and guides that assisted in their implementation and analysis (Metcalf et al. XXXX, Merow et al. 2015 (or 2014?)). These range from _R_ scripts with detailed annotations to a complete R package that, until recently, was hosted on CRAN.

```{r figure 1, echo = FALSE, fig.height = 6, fig.width = 8, message = FALSE, warning = FALSE}

library(gridExtra)
library(grid)

run_sum_plot <- ggplot(all_pubs,
       aes(x = Year,
           y = `Cumulative Publications`)) + 
  geom_line(aes(color = Database),
            size = 1.25) +
  theme_bw() +
  scale_color_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 600, label = "A", size = 10) +
  theme(legend.position = "none")

ann_pubs <- ggplot(all_pubs,
                   aes(x = Year)) +
  geom_col(aes(y = `Number per Year`,
               fill = Database)) +
  theme_bw() +
  scale_fill_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 50, label = "B", size = 10) +
  theme(legend.position = "bottom")

grid.arrange(run_sum_plot, ann_pubs)

```


To date, there has been only one serious effort to implement an R package to assist with integral projection modeling: `IPMpack` (Metcalf et al. XXXX). `IPMpack` was a major leap forward in allowing users to go from raw data to a set of iteration kernels with just a few lines of code. Indeed, a number of the authors of this paper have used it to great effect on their own data, as well as in teaching IPMs to students and mentees. `ipmr` extends the work of `IPMpack` in a number of ways. First, `ipmr` is explictly designed to work with more types of IPMs, and can handle models with individuals classified by a mixture of any number of continuously and discretely distributed state variables. Furthermore, it introduces specific classes and methods to deal with both discretely and continuously varying stochastic environments. Finally, the decoupling of the parameterization (i.e. regression model fitting) and implementation steps (i.e. kernel construction) of model building also allows users to specify models of any functional form. This is not possible in `IPMpack` without a detailed understanding of the package's internal structure.
    
First, we define the general IPM and some associated terms, then introduce the package and show how our alternative implementation of IPMs extends the work done with `IPMpack`. We then discuss additional opportunities this framework provides.

# Defining an IPM and terminology

Before describing `ipmr` in greater detail, we first need to define the various components of the model and some terminology. An IPM is comprised of, at a minimum, one or more continuous state variable(s) (states) and their associated domains (the range of values the state variable can take), and vital rate functions (state-fate relationships). The latter are typically regression models (e.g. logistic regression for survival), but can be discrete parameters as well (e.g. a seed germination probability). These are then combined to form a continuous kernels (EQ 1). An IPM also requires a trait distribution function to describe the population state. This is analogous to the population vector in a matrix projection model. Analytical solutions to IPM equations are often not tractable. A numerical integration rule can be applied to the kernel functions and the population distribution functions to discretize them into a large matrix and vector, analogous to the projection matrix in a matrix projection model. Matrix multiplication of the discretized kernel and the population state vector project the population to the next time step, a process we refer to as model iteration. 

1. $n(z', t+1) = \int_L^UK(z',z)n(z,t)\mathrm{dz}$

2. $K(z',z) = P(z',z) + F(z',z) + C(z',z)$

Here, $z'$ and $z$ represent individual states at time $t+1$ and time $t$, respectively. $L$ and $U$ define lower and upper boundaries of the domain for $z$. The $n(z',t+1)$ and $n(z,t)$ functions describe the relative frequency of individuals for each value of $z$. $P(z',z)$, $F(z',z)$, and $C(z',z)$ are sub-kernels representing growth conditional on survival for existing individuals, sexual reproduction, and asexual reproduction, respectively. These are combined to form $K(z',z)$ (EQ 2), the projection kernel. $P$, $F$, and $C$ may be comprised of one or more functions whose forms are given by regression models fit to individual level longitudinal data, discrete parameters (e.g. seed survival that is not linked to parental state), or a mixture of the two. We refer to these different scales (regressions/parameters, sub-kernels, and projection kernels) as levels of the model hierarchy. 

Before continuing, we must also distinguish between simple and general IPMs. A simple model is any IPM that makes use of one, and only one, continuous state variable, and models no additional structure in the population. A general model has one or more continuous state variables, and/or discrete states. Examples of discrete state variables are number of seeds in a seed bank, or number of insect eggs laid that are not yet hatched. A more comprehensive defintion is given by Ellner & Rees (2006) and Ellner, Rees & Childs (2016). 

# Design and usage

`ipmr` is designed to mimic the mathematical notation of the IPM. The package is powered by the `rlang` implementation of quasi-quotation (Henry & Wickham 2019). On the user side, it works by building up expressions that reference each other at higher and higher levels in the model hierarchy. `ipmr` is relatively dependency-free, requiring only `rlang`, `purrr`, and `magrittr` (in addition to a few of the packages included in the base R distribution e.g. `graphics`, `utils`). The model definition functions (`define_kernel`, `define_k`) can handle any valid R code in the expressions that are passed to it, so user-specified functions, in addition to ones included in other packages can all be used in vital rate and kernel expressions (for example, `predict.*` methods for complicated vital rate models). Additionally, there are helper functions define the initial state of the system, and optionally, how it changes over the course of a simulation. These are `define_impl` (defines each kernel's numerical implementation), `define_domains` (defines the range of the domain for each state variable in the model),  `define_pop_state` (optionally defines the initial population state), `define_env_state` (optionally defines additional environmental variables and functions to sample them). Figure 2 shows a generic IPM workflow from collecting the raw data to biological inference, highlighting the stages at which `ipmr` is useful.

```{r figure 2, fig.cap = "Example workflow chart. Could probably use some spiffing up.", echo = FALSE, dpi = 450, fig.height = 8, fig.width = 8}

library(png)

fig <- readPNG("../Figures/ex_worflow.png")

fig_grob <- rasterGrob(fig, interpolate = TRUE)

plt <- qplot(1:10, 1:10, geom = "blank") +
  annotation_custom(fig_grob,
                    xmin = -Inf,
                    xmax = Inf,
                    ymin = -Inf,
                    ymax = Inf) +
  theme_void()

print(plt)


```

## *Case study 1 - General IPM in a temporally fluctuating environment*

Interest in modeling demography with temporally or spatially varying vital rates is growing (some citations). Shifts in climate regimes can be explicitly incorporated into vital rate models as fixed effects, and multiple sites and/or years may be necessary to capture these relationships (some more citations). Thus, mixed vital rate models with multiple fixed and random effects are becoming more common in the IPM literature. Unfortunately, there is still no computational framework that can convert these regression objects into IPMs in a consistent way. 

`ipmr` can implement these models, and usually only requires 1 or 2 user-specified functions to do so. Implementing by hand typically requires at least 1 user-defined function per vital rate, plus any additional ones that need to be defined to generate implementation rules (e.g. meshpoints), kernels, and the model iteration procedure itself. 

All functions can handle models where some vital rates are modeled hierarchically and others are not (e.g. plant vital rates are time-varying, but seed bank parameters are not). A special syntax is implemented so that users can simply append a suffix to variables and supply the levels that suffix can take to `define_kernel`. All expressions are expanded so that there is one for every level or combination of levels of the grouping effects. This mirrors the mathematical notation of models. For example, a survival-growth kernel constructed from mixed effects models for survival and growth could be written: $P(z', z, yr) = s(z, yr) * g(z', z, yr)$. This can be written in `ipmr` as `P_yr = s_yr * g_yr`. Provided that all levels of the grouping effect are supplied in the kernel definition, the expressions will all be expanded, and separate kernel will be constructed for every year. Table 1 shows the translation between the mathematical form of the model, and the `ipmr` version of the kernel and vital rate expressions.

```{r echo = FALSE}

tab_legend <- "Table 1: Translations between mathematical notation of the regression models, and ipmr syntax to implement them. Math Formula corresponds to the mathematical notation for the model.  'ipmr' shows an equivalent way to write this model in kernel formula or vital rate expression."


knitr::kable(
  data.frame(

    Math    = c("$\\mu_g^{yr} = \\alpha_g + \\alpha_g^{yr} * \\beta_g * z$",
                         "$z' \\sim Norm(\\mu_g^{yr}, \\sigma_g)$",
                "$Logit(\\mu_{s}^{plot,yr}) = \\alpha_s + \\alpha_{s}^{plot,yr} + \\beta * z$",
                "",
                "",
                "$log(\\mu_f^{yr}) = \\alpha_{f} + \\alpha_f^{yr} + (\\beta_f + \\beta_f^{yr}) * z$"),

    
    ipmr = c("mu_g_**yr** = g_int + g_int_**yr** + g_slope * z",
             "g = dnorm(z_2, mu_g_**yr**, sd_g)",
             "s_**pl**_**yr** = s_int + s_int_**pl**_**yr** + s_slope * z",
             "s_**pl**_**yr** = s_int + s_int_**pl** + s_int_**yr** + s_slope * z",
             "s = inv_logit(s_**pl**_**yr**)",
             "fec = exp(f_int + f_int_**yr** + (f_slope + f_slope_**yr**) * z)")
  ),
  format    = "simple",
  escape    = FALSE,
  col.names = c("Math Formula", "ipmr"),
  caption   = tab_legend
)

```

Here, we use a data set from Compagnoni et al. (2016) and show that implementing such a model with `ipmr` requires considerably less knowledge of function writing, and generates results for stochastic models  on standard hardware in reasonable amounts of time. We demonstrate the new notation as well, and show how it considerably reduces code duplication and/or the need for user-specified `for` loops. We also use this case study to demonstrate how one could potentially construct a database of IPMs that doesn't need to store any of the raw data used to create them. Code for this case study is available in the Supplementary Materials.

## *Case study 2 - Age x size models*

Age and size structured models represent a special case of the general IPM. To date, there aren't many in the literature, largely due to the fact that datasets for which ages are known and states continuously measured aren't necessarily ubiquitous (BUT SOMEONE PLEASE CORRECT THIS IF I'M WRONG). On the other hand, vital rates for many species are known to  vary with age (Jones et al. 2014, additional citations). Thus, the field of structured demography will benefit from having tools that can readily implement these models as longer term, age structured data sets become available in databases like _popler_ (Compagnoni et al 2019, ADD BioTIME??).

`ipmr` handles age structure with an additional S3 class that is appended to the model class to denote age structure. There isn't much additional code needed to specify the kernels because the hierarchical syntax introduced above works *almost* identically for age structured models. For this case study, we implement the age and size structured model for Soay sheep introduced in Ellner, Rees & Childs (2016). Re-implementing the model requires only 1 user specified function to handle the case of 0 reproduction for newborns. The implementation in from the code in the book requires 10 user-specified functions, and an `IPMpack` version is not available for comparison because that package cannot handle this type of model at all. `ipmr` runs a bit slower than the example published by Ellner, Rees & Childs, even when code to retain the complete population time series is included in the hand-coded example. It is worth noting that we haven't attempted any optimization for speed yet, and so the timings should come down in the not so distant future as we work on that. Code for the case study is available in the Supplementary Materials.

# **Discusion of additional applications**

We show above that `ipmr` can handle a far larger variety of model implementations than existing software. The common data structure used to represent the model, the `proto_ipm`, provides a concise standard for representing models in future publications' supplementary materials and could go a long way to enhancing reproducibility in a field not known for making data open access. Additionally, `ipmr` provides a small number of generic functions for implementing a broad array of IPMs. This enables to users to focus on the math and biology underlying their system of interest, rather than implementation details like eviction and integration meshes. 

Perhaps more importantly though, the flexibility of `ipmr` raises some intriguing possibilities for the future of structured demography. Recent work has highlighted the power of syntheses that harness many structured population models (Adler et al. 2013, Salguero-Gomez et al. 2016, Bennett et al. 2020, Compagnoni et al. 2020, more if needed). Despite the wide variety of models that are currently published in the IPM literature, `ipmr`'s functional approach is able to reproduce nearly all of them without requiring any raw data at all. To demonstrate this, we implemented a bare-bones version of a database that stored the functional forms as text strings, and parameter values in a multi-table format. We used this, rather than coding the actual functional forms in an R script, to reproduce the stochastic model in Case Study 1. Extending this format to include many more models could serve as an IPM version of the popular COMPADRE and COMADRE matrix population model databases (Salgo 2015 + 2016). Furthermore, if `ipmr` becomes widely adopted, then the process of incorporating a model into such a database would be as simple as authors just including their `proto_ipm`s in electronic supplementary materials (as a `.rda/.rds` file). This would enable full model reproducibility without requiring researchers to release raw data that they may otherwise want to embargo for future use. 

# **Limitations**

Currently, `ipmr` can only handle density independent models. Density dependent IPMs are not especially common in the literature at the moment, though that may change as increasingly large data sets become available (e.g. Adler et al. 2010, Ellner et al. XXXX). Time-lagged models are also not yet implemented. Both of these are currently slated for development, and should be available in the next year or so. Additionally, while `ipmr` does handle the implementation step of IPMs and some very basic analyses (e.g. per-capita growth rates, left and right eigenvectors), this is rarely the end of the analysis for researchers. We are developing a separate package to interface with `ipmr` to handle a range of more complicated analyses like life table response experiments and analysis of transient dynamics.

# Conclusion

We implement a framework for building integral projection models in _R_, and show that it is far more flexible than existing options. We demonstrate that, in addition to implementing user-specified models, this framework could serve as an engine to reproduce published models without requiring any raw data used to implement them. This would allow for far more comprehensive syntheses of published work than what is currently possible. Finally, we discuss the limitations of the package, and our plans to address them in future package versions. 

# **Citation list**

1. Bates et al 2015: Fitting mixed effects models using lme4

2. Wood 2011: Fast stable restricted maximum likelihood and marginal likelihood estimates of semiparametric genearlized linear models. 

3. IPMpack paper Metcalf et al.

4. Ellner, Rees & Childs 2016

5. Easterling, Ellner & Dixon 2000

6. Caswell 2001

7. Ramula, Rees & Buckley 2009: Integral projection models perform better for small demographic data sets than matrix population models: a case study of two perennial herbs

8. Compagnoni et al 2020 (hopefully). Plant review, uses ipmr and PADRINO to rebuild selected kernels for re-analysis.

9. PADRINO

10. Salgo 2016 Compadre + Comadre (find that paper)

11. Henry & Wickham 2016, rlang

12. Bogdan et al. (in prep) iceplant in Israel

13. Bennett et al. 2020 pollen_lim ~ demography paper (hopeful!)

14. Adler et al. 2013 elas ~ traits

15. Jones et al. 2014 Diversity of aging across the tree of life

16. Louthan & Doak 2018 regression dilution

17. Ellner & Rees 2006 IPMs for species w/ complex demography. Am Nat

18. Childs et al. Ecol Lett 2011

19. Coulson 2012 Oikos
 
20. Crandall & Knight 2017 J. Appl Ecol.


```{r echo = FALSE}

tab_legend <- "Table 1: Examples of translations between mathematical notation, R's formula notation, and ipmr's notation. ipmr's syntax includes the ability to recognize and expand random effects denoted with `_effectName` suffixes appended to each variable they modify (rows 3-end). The suffixes are highlighted in bold in the ipmr column."

knitr::kable(
  data.frame(

    Math    = c("$\\mu = \\alpha + \\beta_g * z$",
                "$z' \\sim Norm(\\mu, \\sigma)$",
                "$Logit(\\mu_{s}^{plot,yr}) = \\alpha_s + \\alpha_{s}^{plot,yr} + \\beta * z$",
                "$log(\\mu_f^{yr}) = \\alpha_{f} + \\alpha_f^{yr} + (\\beta_f + \\beta_f^{yr}) * z$",
                "$P_{yr} = s(z) * G(z',z)$"),
    
    
    R = c("`size_2 ~ size_1 + (1 | year), family = gaussian()`",
          "g = dnorm(z_2, mu_g, sd_g)",
          "`surv ~ size_1 + (1 | year) + (1 | plot), family = binomial()`",
          "`fec ~ size_1 + (size_1 | year), family = poisson()`",
          "`P_yr = outer(z, z, surv_grow_fun, surv_grow_pars = surv_grow_pars)`"),
    
    
    ipmr = c("mu_g = g_int + g_int + g_slope * z",
             "g = dnorm(z_2, mu_g, sd_g)",
             "s_**pl**_**yr** = s_int + s_int_**pl**_**yr** + s_slope * z",
             "fec = exp(f_int + f_int_**yr** + (f_slope + f_slope_**yr**) * z)",
             "P_yr = s_yr * g_yr")
  ),
  escape    = FALSE,
  col.names = c("Math Formula", "R Formula", "ipmr"),
  caption   = tab_legend
)
