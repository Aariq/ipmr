---
title: "ipmr: Flexibly implement Integral Projection Models in R"
output:  
  word_document:
    toc: no
fig_caption: yes
---

Sam C. Levin $^{\ast1,2,3}$, Aldo Compagnoni $^{1,2,3}$, Roberto Salguero-Gomez $^3$, Dylan Z. Childs $^4$, Sanne Evers $^{1,2}$, Tiffany M. Knight $^{1,2,5}$

$^1$Institute of Biology, Martin Luther University Halle-Wittenberg, Am Kirchtor 1, 06108 Halle (Saale), Germany

$^2$German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig, Deutscher Platz 5e, 04103 Leipzig, Germany

$^3$Oxford Zoology

$^4$Sheffield

$^5$UFZ



$^*$Corresponding Author:

Sam C Levin

Deutscherplatz 5e, 04103 Leipzig, Germany

email: <levisc8@gmail.com>



Target journal: Methods in Ecology and Evolution, submission type: Application. Word limit: 3000



[Formatting guidelines](https://besjournals.onlinelibrary.wiley.com/hub/journal/2041210X/author-guidelines) (in case you care)



# **Abstract**

1. Integral projection models have become the tool of choice for studying the demography of populations structured by one or more continuous state variables. They are used to investigate everything from single species conservation and management to understanding evolutionary stable strategies. To date, there has only been one serious effort to implement these in _R_. It has been useful, but suffers from constraints imposed by the high level of abstraction in the implementation and the rigors of the S4 OOP framework. 

2. We create a lower level framework that relies on a combination of S3 OOP, quasi-quotation, and a small number of generic functions to generate model objects. The syntax is meant to mirror the mathematical notation of the models, and provides a clear translation between the underlying math and the numerical implementaiton of the model.

3. Our framework allows users to generate simple and/or general, deterministic and/or stochastic, density independent integral projection models. It provides some additional basic analysis methods, as well as visualization tools.

4. This framework is far more flexible than existing packages for integral projection models. The common data structure it uses to generate them also presents opportunities to enhance reproducibility in the field, and represent them in data bases in ways that could not have been done previously. 

```{r echo = FALSE, message = FALSE, warning=FALSE}

library(dplyr)
library(purrr)
library(ggplot2)

ipm_pubs <- read.csv('../data-raw/padr-pubs-feb-2020.csv',
                     stringsAsFactors = FALSE)

ipm_id <- pmap_chr(.l = data.frame(a = ipm_pubs$Authors,
                                   b = ipm_pubs$Journal, 
                                   c = ipm_pubs$Year),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

ipm_pubs <- cbind(ipm_pubs, ipm_id)
ipm_pubs$Year <- as.integer(ipm_pubs$Year)

pub_tot  <- length(unique(ipm_id))

spec_tot <- length(unique(ipm_pubs$Species))

cdb_fetch <- function(cdb) {
  # get url or path
  if (tolower(cdb) == 'comadre') {
    path <- url('https://compadre-db.org/Data/ComadreDownload')
  } else if (tolower(cdb) == 'compadre') {
    path <- url('https://compadre-db.org/Data/CompadreDownload')
  } else {
    path <- path.expand(cdb)
  }
  
  # fetch and load
  env <- new.env()
  x <- load(path, env)[1]
  dbFetch <- env[[x]]

  # Deal with differences between s4 and s3 versions of database

  if(inherits(dbFetch, 'list')) {
    dbFetch <- dbFetch[[1]]
  } else if(inherits(dbFetch, "CompadreDB")) {
    dbFetch <- dbFetch@data
  } else {
    stop("Cannot recognize class of currently fetched com(p)adre object",
         call. = FALSE)
  }


  return(dbFetch)

}

cpd <- cdb_fetch('compadre')

mpm_id<- pmap_chr(.l = data.frame(a = cpd$Authors,
                                  b = cpd$Journal, 
                                  c = cpd$YearPublication),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

cpd <- cbind(cpd, mpm_id)

cpd$YearPublication <- as.integer(cpd$YearPublication)

cpd_tot_pubs <- cpd %>% 
  filter(!duplicated(mpm_id)) %>% 
  group_by(YearPublication) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(YearPublication) %>%
  filter(!is.na(YearPublication))

cpd_tot_pubs <- mutate(cpd_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Compadre MPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))

pdr_tot_pubs <- ipm_pubs %>%
  filter(!duplicated(ipm_id)) %>%
  group_by(Year) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(Year)
  
pdr_tot_pubs <- mutate(pdr_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Padrino IPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))  %>%
  filter(!is.na(Year))

all_pubs <- rbind(pdr_tot_pubs, cpd_tot_pubs)
all_pubs$Year <- as.integer(all_pubs$Year)

```



# **Introduction**

Integral projection models (IPMs) have become one of the tools of choice for demographers studying structured populations in discrete time. Since their introduction Easterling, Ellner & Dixon's (2000) paper, there have been over `r pub_tot` publications for using IPMs to address a variety of questions ranging from invasive species population dynamics to evolutionary stable strategies to endangered species conservation. In plants alone, there are currently at least `r spec_tot` plant species for which an IPM exists (a buttload of citations, Padrino DB, Levin et al. unpublished). Their main power lies in the fact that they allow for continuously distributed state variables to describe vital rates and population structure, as opposed to historically favored methods that relied on the sometimes arbitrary delineation of classes (e.g. matrix population models, Caswell 2001).

IPMs are flexible models that rely on raw data to drive the functional forms of the underlying vital rates. They are built using regression models of vital rates on a state variable that is related to individual fitness in some way (e.g. dbh for trees, body mass in animals). Regression analysis has been a standard tool for ecologists for quite some time now, and the field is mature enough to accomodate many different types of data (e.g. Wood 2011, Bates et al. 2015). Regression model parameters are usually easier to estimate than matrix parameters when data sets are small, facilitating analysis of population dynamics for threatened or endangered species in a way that matrix models cannot (Ramula et al. 2009, but see Louthan & Doak 2018 for further discussion). This flexibility has lead to an exponential increase in their appearance in the literature (Figure 1). This rise in popularity also spurred the creation of software tools and guides that assisted in their implementation and analysis (Metcalf et al. XXXX, Merow et al. 2015 (or 2014?)). These range from _R_ scripts with detailed annotations to a complete R package that, until recently, was hosted on CRAN.

```{r figure 1, echo = FALSE, fig.height = 6, fig.width = 8, message = FALSE, warning = FALSE}

library(gridExtra)
library(grid)

run_sum_plot <- ggplot(all_pubs,
       aes(x = Year,
           y = `Cumulative Publications`)) + 
  geom_line(aes(color = Database),
            size = 1.25) +
  theme_bw() +
  scale_color_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 600, label = "A", size = 10) +
  theme(legend.position = "none")

ann_pubs <- ggplot(all_pubs,
                   aes(x = Year)) +
  geom_col(aes(y = `Number per Year`,
               fill = Database)) +
  theme_bw() +
  scale_fill_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 50, label = "B", size = 10) +
  theme(legend.position = "bottom")

grid.arrange(run_sum_plot, ann_pubs)

```


To date, there has been only one serious effort to implement an R package to assist with integral projection modeling: `IPMpack` (Metcalf et al. XXXX). `IPMpack` was a major leap forward in allowing users to go from raw data to a set of iteration kernels with just a few lines of code. Indeed, a number of the authors of this paper have used it to great effect on their own data, as well as in teaching IPMs to students and mentees. Unfortunately, `IPMpack` is not a fully generalized set of tools, and there are certain types of models that it struggles or outright fails to implement (e.g. age x size models, continuously varying stochastic environments). While it does provide tools for assessing goodness of fit for various vital rate models, there are only two options for assessing their affects on model construction. Even then, these are restricted to a very small subset of existing regression model types (i.e. no mixed effects at all, and only families built into the `stats` and `nlme` packages for _R_). A user can work around this if they have a detailed knowledge of not only the S4 class system in general, but also how it functions internally in `IPMpack`. This is a lot of additional cognitive overhead, and largely brought on by an attempt to abstract over two topics that can be exceptionally complicated: 1. regression models and 2. object oriented programming in _R_. We therefore believe that a new, less abstracted framework is a major opportunity for progress in the field of structured population modelling.
    
`ipmr` is a lower-level framework that uses mathematical and/or _R_ expressions to generate iteration kernels and population trait distributions. Importantly, it does not try to abstract away the actual vital rate model fitting process - we feel that step is a substantially different question and it is best left to the user. Removal of this layer of abstraction provides an additional benefit - users are free to specify vital rate models of *any* functional form, with any package(s) they desire. Another key difference is that it defines model objects in the S3 system, rather than the S4 system. This provides considerably more flexibility on both the input and output side of the model building process. 

The package is powered by the `rlang` implementation of quasi-quotation (Henry & Wickham 2019). On the user side, it works by building up expressions that reference each other at higher and higher levels in the model hierarchy. `ipmr` is relatively dependency-free, requiring only `rlang`, `purrr`, and `magrittr` (in addition to a few of the packages included in the base R distribution e.g. `graphics`, `utils`). The model definition functions (`define_kernel`, `define_k`, and additional helpers) can handle any valid R code in the expressions that are passed to it, so user-specified functions, in addition to ones included in other packages can all be used in vital rate and kernel expressions (e.g. `predict.*` methods for vital rate models). Additionally, there are helper functions define the initial state of the system, and optionally, how it changes over the course of a simulation. These are `define_impl` (defines each kernel's numerical implementation), `define_domains` (defines the range of the domain for each state variable in the model),  `define_pop_state` (optionally defines the initial population state), `define_env_state` (optionally defines additional environmental variables and functions to sample them). Figure 2 shows a generic IPM workflow from collecting the raw data to biological inference, highlighting the stages at which `ipmr` is useful.

```{r figure 2, fig.cap = "Example workflow chart. Could probably use some spiffing up.", echo = FALSE, dpi = 450, fig.height = 8, fig.width = 8}

library(png)

fig <- readPNG("Figures/ex_worflow.png")

fig_grob <- rasterGrob(fig, interpolate = TRUE)

plt <- qplot(1:10, 1:10, geom = "blank") +
  annotation_custom(fig_grob,
                    xmin = -Inf,
                    xmax = Inf,
                    ymin = -Inf,
                    ymax = Inf) +
  theme_void()

print(plt)


```

## *Case study 1 - General IPM in a temporally fluctuating environment*

Interest in modeling demography with temporally or spatially varying vital rates is growing (some citations). Shifts in climate regimes can be explicitly incorporated into vital rate models as fixed effects, and multiple sites and/or years may be necessary to capture these relationships (some more citations). Thus, mixed vital rate models with multiple fixed and random effects are becoming more common in the IPM literature. Unfortunately, there is still no computational framework that can convert these regression objects into IPMs in a consistent way. 

`ipmr` can implement these models, and usually only requires 1 or 2 user-specified functions to do so. Implementing by hand typically requires at least 1 user-defined function per vital rate, plus any additional ones that need to be defined to generate implementation rules (e.g. meshpoints), kernels, and the model iteration procedure itself. 

All functions can handle models where some vital rates are modeled hierarchically and others are not (e.g. plant vital rates are time-varying, but seed bank parameters are not). A special syntax is implemented so that users can simply append a suffix to variables and supply the levels that suffix can take to `define_kernel`. All expressions are expanded so that there is one for every level or combination of levels of the grouping effects. This mirrors the mathematical notation of models. Fore example, a survival-growth kernel constructed from mixed effects models for survival and growth could be written: $P(z', z, yr) = s(z, yr) * g(z', z, yr)$. This can be written in `ipmr` as `P_yr = s_yr * g_yr`. Provided that all levels of the grouping effect are supplied in the kernel definition, the expressions will all be expanded, and separate kernel will be constructed for every year. The syntax is extensively documented in the vignettes and on the package's website.

Here, we use a data set from Compagnoni et al. (2016) and show that implementing such a model with `ipmr` requires considerably less knowledge of function writing, and generates results for stochastic models  on standard hardware in reasonable amounts of time. We demonstrate the new notation as well, and show how it considerably reduces code duplication and/or the need for user-specified `for` loops. We also use this case study to demonstrate how one could potentially construct a database of IPMs that doesn't need to store any of the raw data used to create them. Code for this case study is available in the Supplementary Materials.

## *Case study 2 - Age x size models*

Age and size structured models represent a special case of the general IPM. To date, there aren't many in the literature, largely due to the fact that datasets for which ages are known and states continuously measured aren't necessarily ubiquitous (BUT SOMEONE PLEASE CORRECT THIS IF I'M WRONG). On the other hand, vital rates for many species are known to  vary with age (Jones et al. 2014, additional citations). Thus, the field of structured demography will benefit from having tools that can readily implement these models as longer term, age structured data sets become available in databases like _popler_ (Compagnoni et al 2019, ADD BioTIME??).

`ipmr` handles age structure with an additional S3 class that is appended to the model class to denote age structure. There isn't much additional code needed to specify the kernels because the hierarchical syntax introduced above works *almost* identically for age structured models. For this case study, we implement the age and size structured model for Soay sheep introduced in Ellner, Rees & Childs (2016). Re-implementing the model requires only 1 user specified function to handle the case of 0 reproduction for newborns. The implementation in from the code in the book requires 10 user-specified functions, and an `IPMpack` version is not available for comparison because that package cannot handle this type of model at all. `ipmr` runs a bit slower than the example published by Ellner, Rees & Childs, even when code to retain the complete population time series is included in the hand-coded example. It is worth noting that we haven't attempted any optimization for speed yet, and so the timings should come down in the not so distant future as we work on that. Code for the case study is available in the Supplementary Materials.

# **Discusion of additional applications**

We show above that `ipmr` can handle a far larger variety of model implementations than existing software. The common data structure used to represent the model, the `proto_ipm`, provides a concise standard for representing models in future publications' supplementary materials and could go a long way to enhancing reproducibility in a field not known for making data open access. Additionally, `ipmr` provides a small number of generic functions for implementing a broad array of IPMs. This enables to users to focus on the math and biology underlying their system of interest, rather than implementation details like eviction and integration meshes. 

Perhaps more importantly though, the flexibility of `ipmr` raises some intriguing possibilities for the future of structured demography. Recent work has highlighted the power of syntheses that harness many structured population models (Adler et al. 2013, Salguero-Gomez et al. 2016, Bennett et al. 2020, Compagnoni et al. 2020, more if needed). Despite the wide variety of models that are currently published in the IPM literature, `ipmr`'s functional approach is able to reproduce nearly all of them without requiring any raw data at all. To demonstrate this, we implemented a bare-bones version of a database that stored the functional forms as text strings, and parameter values in a multi-table format. We used this, rather than coding the actual functional forms in an R script, to reproduce the stochastic model in Case Study 1. Extending this format to include many more models could serve as an IPM version of the popular COMPADRE and COMADRE matrix population model databases (Salgo 2015 + 2016). Furthermore, if `ipmr` becomes widely adopted, then the process of incorporating a model into such a database would be as simple as authors just including their `proto_ipm`s in electronic supplementary materials (as a `.rda/.rds` file). This would enable full model reproducibility without requiring researchers to release raw data that they may otherwise want to embargo for future use. 

# **Limitations**

Currently, `ipmr` can only handle density independent models. Density dependent IPMs are not especially common in the literature at the moment, though that may change as increasingly large data sets become available (e.g. Adler et al. 2010, Ellner et al. XXXX). Time-lagged models are also not yet implemented. Both of these are currently slated for development, and should be available in the next year or so. Additionally, while `ipmr` does handle the implementation step of IPMs and some very basic analyses (e.g. per-capita growth rates, left and right eigenvectors), this is rarely the end of the analysis for researchers. We are developing a separate package to interface with `ipmr` to handle a range of more complicated analyses like life table response experiments and analysis of transient dynamics.

# Conclusion

We implement a framework for building integral projection models in _R_, and show that it is far more flexible than existing options. We demonstrate that, in addition to implementing user-specified models, this framework could serve as an engine to reproduce published models without requiring any raw data used to implement them. This would allow for far more comprehensive syntheses of published work than what is currently possible. Finally, we discuss the limitations of the package, and our plans to address them in future package versions. 

# **Citation list**

1. Bates et al 2015: Fitting mixed effects models using lme4

2. Wood 2011: Fast stable restricted maximum likelihood and marginal likelihood estimates of semiparametric genearlized linear models. 

3. IPMpack paper Metcalf et al.

4. Ellner, Rees & Childs 2016

5. Easterling, Ellner & Dixon 2000

6. Caswell 2001

7. Ramula, Rees & Buckley 2009: Integral projection models perform better for small demographic data sets than matrix population models: a case study of two perennial herbs

8. Compagnoni et al 2020 (hopefully). Plant review, uses ipmr and PADRINO to rebuild selected kernels for re-analysis.

9. PADRINO

10. Salgo 2016 Compadre + Comadre (find that paper)

11. Henry & Wickham 2016, rlang

12. Bogdan et al. (in prep) iceplant in Israel

13. Bennett et al. 2020 pollen_lim ~ demography paper (hopeful!)

14. Adler et al. 2013 elas ~ traits

15. Jones et al. 2014 Diversity of aging across the tree of life

16. Louthan & Doak 2018 regression dilution

