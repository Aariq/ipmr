---
title: "ipmr: Flexibly implement Integral Projection Models in R"
output:  
  word_document:
    toc: no
fig_caption: yes
author: |
  | Sam C. Levin ^[Corresponding author: levisc8@gmail.com] $^1$^,^$^2$,
  | Aldo Compagnoni $^1$^,^$^2$, Roberto Salguero-Gomez $^3$, Dylan Z. Childs $^4$,
  | Tiffany M. Knight $^1$^,^$^2$^,^$^5$
  | $^1$MLU Dept of Biologie, $^2$iDiv, $^3$Oxford Zoology, $^4$Sheffield, $^5$UFZ
---



```{r echo = FALSE, message = FALSE, warning=FALSE}

library(dplyr)
library(purrr)
library(ggplot2)

ipm_pubs <- read.csv('../data-raw/padr-pubs-feb-2020.csv',
                     stringsAsFactors = FALSE)

ipm_id <- pmap_chr(.l = data.frame(a = ipm_pubs$Authors,
                                   b = ipm_pubs$Journal, 
                                   c = ipm_pubs$Year),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

ipm_pubs <- cbind(ipm_pubs, ipm_id)
ipm_pubs$Year <- as.integer(ipm_pubs$Year)

pub_tot  <- length(unique(ipm_id))

spec_tot <- length(unique(ipm_pubs$Species))

cdb_fetch <- function(cdb) {
  # get url or path
  if (tolower(cdb) == 'comadre') {
    path <- url('https://compadre-db.org/Data/ComadreDownload')
  } else if (tolower(cdb) == 'compadre') {
    path <- url('https://compadre-db.org/Data/CompadreDownload')
  } else {
    path <- path.expand(cdb)
  }
  
  # fetch and load
  env <- new.env()
  x <- load(path, env)[1]
  dbFetch <- env[[x]]

  # Deal with differences between s4 and s3 versions of database

  if(inherits(dbFetch, 'list')) {
    dbFetch <- dbFetch[[1]]
  } else if(inherits(dbFetch, "CompadreDB")) {
    dbFetch <- dbFetch@data
  } else {
    stop("Cannot recognize class of currently fetched com(p)adre object",
         call. = FALSE)
  }


  return(dbFetch)

}

cpd <- cdb_fetch('compadre')

mpm_id<- pmap_chr(.l = data.frame(a = cpd$Authors,
                                  b = cpd$Journal, 
                                  c = cpd$YearPublication),
               .f = function(a, b, c) paste(a, b, c, sep = "_")) 

cpd <- cbind(cpd, mpm_id)

cpd$YearPublication <- as.integer(cpd$YearPublication)

cpd_tot_pubs <- cpd %>% 
  filter(!duplicated(mpm_id)) %>% 
  group_by(YearPublication) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(YearPublication) %>%
  filter(!is.na(YearPublication))

cpd_tot_pubs <- mutate(cpd_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Compadre MPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))

pdr_tot_pubs <- ipm_pubs %>%
  filter(!duplicated(ipm_id)) %>%
  group_by(Year) %>%
  summarise(n_tot = n()) %>%
  ungroup() %>%
  arrange(Year)
  
pdr_tot_pubs <- mutate(pdr_tot_pubs, run_sum = cumsum(n_tot),
                       Database = "Padrino IPM Database") %>%
  setNames(c(
    "Year",
    "Number per Year",
    "Cumulative Publications",
    "Database"
  ))  %>%
  filter(!is.na(Year))

all_pubs <- rbind(pdr_tot_pubs, cpd_tot_pubs)
all_pubs$Year <- as.integer(all_pubs$Year)

```

## Intro

Integral projection models (IPMs) have become one of the tools of choice for demographers studying structured populations in discrete time. Since their introduction Easterling, Ellner & Dixon's (2000) paper, there have been over `r pub_tot` publications for using IPMs to address a variety of questions ranging from invasive species population dynamics to evolutionary stable strategies to endangered species conservation. In plants alone, there are currently at least `r spec_tot` plant species for which an IPM exists (a buttload of citations, Padrino DB, Levin et al. unpublished). Their main power lies in the fact that they allow for continuously distributed state variables to describe vital rates and population structure, as opposed to historically favored methods that relied on the sometimes arbitrary delineation of classes (e.g. matrix population models, Caswell 2001).

IPMs are flexible models that rely on raw data to drive the functional forms of the underlying vital rates. They are built using regression models of vital rates on a state variable that is related to individual fitness in some way (e.g. dbh for trees, body mass in animals). Regression analysis has been a standard tool for ecologists for quite some time now, and the field is mature enough to accomodate many different types of data (e.g. Wood 2011, Bates et al. 2015). Regression model parameters are usually easier to estimate than matrix parameters when data sets are small, facilitating analysis of population dynamics for threatened or endangered species in a way that matrix models cannot (Ramula et al. 2009, but see Louthan & Doak 2018 for further discussion). This flexibility has lead to an exponential increase in their appearance in the literature (Figure 1). This rise in popularity also spurred the creation of software tools and guides that assisted in their implementation and analysis (Metcalf et al. XXXX, Merow et al. 2015 (or 2014?)). These range from _R_ scripts with detailed annotations to a complete R package that, until recently, was hosted on CRAN.

```{r figure 1, echo = FALSE, fig.height = 6, fig.width = 8, message = FALSE, warning = FALSE}

library(gridExtra)
library(grid)

run_sum_plot <- ggplot(all_pubs,
       aes(x = Year,
           y = `Cumulative Publications`)) + 
  geom_line(aes(color = Database),
            size = 1.25) +
  theme_bw() +
  scale_color_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 600, label = "A", size = 10) +
  theme(legend.position = "none")

ann_pubs <- ggplot(all_pubs,
                   aes(x = Year)) +
  geom_col(aes(y = `Number per Year`,
               fill = Database)) +
  theme_bw() +
  scale_fill_manual(breaks = c("Compadre MPM Database",
                                "Padrino IPM Database"),
                     values = viridis::inferno(2, 
                                               begin = 0,
                                               end = 0.5,
                                               direction = -1)) + 
  annotate("text", x = 1965, y = 50, label = "B", size = 10) +
  theme(legend.position = "bottom")

grid.arrange(run_sum_plot, ann_pubs)

```


To date, there has been only one serious effort to implement an R package to assist with integral projection modeling: `IPMpack` (Metcalf et al. XXXX). `IPMpack` was a major leap forward in allowing users to go from raw data to a set of iteration kernels with just a few lines of code. Indeed, a number of the authors of this paper have used it to great effect on their own data, as well as in teaching IPMs to students and mentees. Unfortunately, `IPMpack` is not a fully generalized set of tools, and there are certain types of models that it struggles or outright fails to implement (e.g. age x size models, continuously varying stochastic environments). While it does provide tools for assessing goodness of fit for various vital rate models, there are only two options for assessing their affects on model construction. Even then, these are restricted to a very small subset of existing regression model types (i.e. no mixed effects at all, and only families built into the `stats` package for _R_). A user can work around this if they have a detailed knowledge of not only the S4 class system in general, but also how it functions internally in `IPMpack`. This is a lot of additional cognitive overhead, and largely brought on by an attempt to abstract over two topics that can be exceptionally complicated for most users (1. regression models and 2. object oriented programming in _R_). We therefore believe that a new, less abstracted framework presents an opportunity for progress.
    
`ipmr` is a lower-level framework that uses mathematical and/or _R_ expressions to generate iteration kernels. Importantly, it does not try to abstract away the actual vital rate model fitting process - we feel that step is a substantially different field and it is best left to the user. Removal of this layer of abstraction provides an additional benefit - users are free to specify vital rate models of *any* functional form, with any package they desire. Another key difference is that it defines model objects in the S3 system, rather than the S4 system as in `IPMpack`. This provides considerably more flexibility in both the input and output side of the model building process. 

The package is largely powered by `rlang` (Henry & Wickham 2019) and works by building up expressions that reference each other at higher and higher levels in the model hierarchy. `ipmr` is relatively dependency-free, requiring only `rlang`, `purrr`, and `magrittr` (in addition to a few of the packages included in the base R distribution e.g. `graphics`, `utils`). The model definition functions (`define_kernel`, `define_k`, and additional helpers) can handle any valid R code in the expressions that are passed to it, so user-specified functions, in addition to ones included in other packages can all be used in vital rate and kernel expressions (e.g. `predict.*` methods). Figure 2 shows a generic IPM workflow from collecting the raw data to biological inference, highlighting the stages at which `ipmr` is useful.

```{r figure 2, fig.cap = "Example workflow chart. Definitely need revision!", echo = FALSE}

library(png)

fig <- readPNG("Figures/ex_worflow.png")

fig_grob <- rasterGrob(fig, interpolate = TRUE)

plt <- qplot(1:10, 1:10, geom = "blank") +
  annotation_custom(fig_grob,
                    xmin = -Inf,
                    xmax = Inf,
                    ymin = -Inf,
                    ymax = Inf) +
  theme_void()

print(plt)


```

## Workflow 

The first step in defining a model is to create a `proto_ipm`. The `proto_ipm` data structure underpins all of `ipmr`'s functionality. It is a data frame containing all the information necessary to implement each sub-kernel, as well as the information needed to the full model. It specifies the functions, domains, and parameters for every kernel in the model as a single row, and places no limit on the number of kernels, functions, or parameters that can be included. In addition to the `proto_ipm` class, each type of model in `ipmr` has its own class as well. This class system is then used to implement a generic function, `make_ipm`, minimizing the number of functions a user needs to learn in addition to providing class-specific options to fully customize the building process.

### Case study 1 - Simple IPM

*Iceplant example dataset* **OR** *reproduce something from `IPMpack`*

### Case study 2 - A hierarchical model in a continuously varying environment

*Hierarchical syntax vignette example* **OR** *age x size* IPM


## Discusion of additional applications

We show above that `ipmr` can handle a far larger variety of model implementations than existing software. Perhaps more importantly though, the flexibility of `ipmr` raises some intriguing possibilities for the future of structured demography. Recent work has highlighted the power of syntheses that harness many structured population models (Salguero-Gomez et al. 2016, Bennett et al. 2020, Compagnoni et al. 2020). Despite the wide variety of models that are currently published in the IPM literature, `ipmr`'s functional approach is able to reproduce nearly all of them without requiring any raw data at all. Thus, a database that stores the functional forms as text strings and regression parameters is within reach and could serve as an IPM analogue for the popular COMPADRE and COMADRE matrix population model databases (Salgo 2015 + 2016). Furthermore, if `ipmr` becomes widely adopted, then the process of incorporating a model into such a database would entail authors simply including their `proto_ipm`'s in electronic supplementary materials. This would enable full model reproducibility without requiring researchers to release raw data that they may otherwise want to embargo for future use. 

## Limitations

Currently, `ipmr` can only handle density independent models. Density dependent IPMs are not especially common in the literature at the moment, though that may change as increasingly large data sets become available (e.g. Adler et al. 2010). These are currently slated for development. Additionally, while `ipmr` does handle the implementation step of IPMs, this is rarely the end of the analysis for researchers. We are developing a separate package to interface with `ipmr` to handle a range of more complicated analyses like life table response experiments and analysis of transient dynamics.

# Citation list

1. Bates et al 2015: Fitting mixed effects models using lme4

2. Wood 2011: Fast stable restricted maximum likelihood and marginal likelihood estimates of semiparametric genearlized linear models. 

3. IPMpack paper Metcalf et al.

4. Ellner, Rees & Childs 2016

5. Easterling, Ellner & Dixon 2000

6. Caswell 2001

7. Ramula, Rees & Buckley 2009: Integral projection models perform better for small demographic data sets than matrix population models: a case study of two perennial herbs

8. Compagnoni et al 2020 (hopefully). Plant review, uses ipmr and PADRINO to rebuild selected kernels for re-analysis.

9. PADRINO

10. Salgo 2016 Compadre + Comadre (find that paper)

11. Henry & Wickham 2016, rlang

12. Bogdan et al. (in prep) iceplant in Israel

13. Bennett et al. 2020 pollen_lim ~ demography paper (hopeful!)


